"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/StringChecks.js
var StringChecks;
var init_StringChecks = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/StringChecks.js"() {
    "use strict";
    StringChecks = /** @class */
    function() {
      function StringChecks2() {
      }
      StringChecks2.explainIfInvalidTSDocTagName = function(tagName) {
        if (tagName[0] !== "@") {
          return 'A TSDoc tag name must start with an "@" symbol';
        }
        if (!StringChecks2._tsdocTagNameRegExp.test(tagName)) {
          return "A TSDoc tag name must start with a letter and contain only letters and numbers";
        }
        return void 0;
      };
      StringChecks2.validateTSDocTagName = function(tagName) {
        var explanation = StringChecks2.explainIfInvalidTSDocTagName(tagName);
        if (explanation) {
          throw new Error(explanation);
        }
      };
      StringChecks2.explainIfInvalidLinkUrl = function(url) {
        if (url.length === 0) {
          return "The URL cannot be empty";
        }
        if (!StringChecks2._urlSchemeRegExp.test(url)) {
          return 'An @link URL must begin with a scheme comprised only of letters and numbers followed by "://". (For general URLs, use an HTML "<a>" tag instead.)';
        }
        if (!StringChecks2._urlSchemeAfterRegExp.test(url)) {
          return 'An @link URL must have at least one character after "://"';
        }
        return void 0;
      };
      StringChecks2.explainIfInvalidHtmlName = function(htmlName) {
        if (!StringChecks2._htmlNameRegExp.test(htmlName)) {
          return "An HTML name must be an ASCII letter followed by zero or more letters, digits, or hyphens";
        }
        return void 0;
      };
      StringChecks2.validateHtmlName = function(htmlName) {
        var explanation = StringChecks2.explainIfInvalidHtmlName(htmlName);
        if (explanation) {
          throw new Error(explanation);
        }
      };
      StringChecks2.explainIfInvalidPackageName = function(packageName) {
        if (packageName.length === 0) {
          return "The package name cannot be an empty string";
        }
        if (!StringChecks2._validPackageNameRegExp.test(packageName)) {
          return "The package name " + JSON.stringify(packageName) + " is not a valid package name";
        }
        return void 0;
      };
      StringChecks2.explainIfInvalidImportPath = function(importPath, prefixedByPackageName) {
        if (importPath.length > 0) {
          if (importPath.indexOf("//") >= 0) {
            return 'An import path must not contain "//"';
          }
          if (importPath[importPath.length - 1] === "/") {
            return 'An import path must not end with "/"';
          }
          if (!prefixedByPackageName) {
            if (importPath[0] === "/") {
              return 'An import path must not start with "/" unless prefixed by a package name';
            }
          }
        }
        return void 0;
      };
      StringChecks2.isSystemSelector = function(selector) {
        return StringChecks2._systemSelectors.has(selector);
      };
      StringChecks2.explainIfInvalidUnquotedIdentifier = function(identifier) {
        if (identifier.length === 0) {
          return "The identifier cannot be an empty string";
        }
        if (StringChecks2._identifierBadCharRegExp.test(identifier)) {
          return "The identifier cannot non-word characters";
        }
        if (StringChecks2._identifierNumberStartRegExp.test(identifier)) {
          return "The identifier must not start with a number";
        }
        return void 0;
      };
      StringChecks2.explainIfInvalidUnquotedMemberIdentifier = function(identifier) {
        var explanation = StringChecks2.explainIfInvalidUnquotedIdentifier(identifier);
        if (explanation !== void 0) {
          return explanation;
        }
        if (StringChecks2.isSystemSelector(identifier)) {
          return 'The identifier "' + identifier + '" must be quoted because it is a TSDoc system selector name';
        }
        return void 0;
      };
      StringChecks2._tsdocTagNameRegExp = /^@[a-z][a-z0-9]*$/i;
      StringChecks2._urlSchemeRegExp = /^[a-z][a-z0-9]*\:\/\//i;
      StringChecks2._urlSchemeAfterRegExp = /^[a-z][a-z0-9]*\:\/\/./i;
      StringChecks2._htmlNameRegExp = /^[a-z]+[a-z0-9\-]*$/i;
      StringChecks2._identifierBadCharRegExp = /[^a-z0-9_$]/i;
      StringChecks2._identifierNumberStartRegExp = /^[0-9]/;
      StringChecks2._validPackageNameRegExp = /^(?:@[a-z0-9\-_\.]+\/)?[a-z0-9\-_\.]+$/i;
      StringChecks2._systemSelectors = /* @__PURE__ */ new Set([
        // For classes:
        "instance",
        "static",
        "constructor",
        // For merged declarations:
        "class",
        "enum",
        "function",
        "interface",
        "namespace",
        "type",
        "variable"
      ]);
      return StringChecks2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/configuration/DocNodeManager.js
var DocNodeManager;
var init_DocNodeManager = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/configuration/DocNodeManager.js"() {
    "use strict";
    init_StringChecks();
    DocNodeManager = /** @class */
    function() {
      function DocNodeManager2() {
        this._docNodeDefinitionsByKind = /* @__PURE__ */ new Map();
        this._docNodeDefinitionsByConstructor = /* @__PURE__ */ new Map();
      }
      DocNodeManager2.prototype.registerDocNodes = function(packageName, definitions) {
        var packageNameError = StringChecks.explainIfInvalidPackageName(packageName);
        if (packageNameError) {
          throw new Error("Invalid NPM package name: " + packageNameError);
        }
        for (var _i = 0, definitions_1 = definitions; _i < definitions_1.length; _i++) {
          var definition = definitions_1[_i];
          if (!DocNodeManager2._nodeKindRegExp.test(definition.docNodeKind)) {
            throw new Error("The DocNode kind " + JSON.stringify(definition.docNodeKind) + " is not a valid identifier. It must start with an underscore or letter, and be comprised of letters, numbers, and underscores");
          }
          var existingDefinition = this._docNodeDefinitionsByKind.get(definition.docNodeKind);
          if (existingDefinition !== void 0) {
            throw new Error('The DocNode kind "' + definition.docNodeKind + '" was already registered' + (" by " + existingDefinition.packageName));
          }
          existingDefinition = this._docNodeDefinitionsByConstructor.get(definition.constructor);
          if (existingDefinition !== void 0) {
            throw new Error("This DocNode constructor was already registered by " + existingDefinition.packageName + (" as " + existingDefinition.docNodeKind));
          }
          var newDefinition = {
            docNodeKind: definition.docNodeKind,
            constructor: definition.constructor,
            packageName,
            allowedChildKinds: /* @__PURE__ */ new Set()
          };
          this._docNodeDefinitionsByKind.set(definition.docNodeKind, newDefinition);
          this._docNodeDefinitionsByConstructor.set(definition.constructor, newDefinition);
        }
      };
      DocNodeManager2.prototype.throwIfNotRegisteredKind = function(docNodeKind) {
        if (!this._docNodeDefinitionsByKind.has(docNodeKind)) {
          throw new Error('The DocNode kind "' + docNodeKind + '" was not registered with this TSDocConfiguration');
        }
      };
      DocNodeManager2.prototype.registerAllowableChildren = function(parentKind, childKinds) {
        var parentDefinition = this._getDefinition(parentKind);
        for (var _i = 0, childKinds_1 = childKinds; _i < childKinds_1.length; _i++) {
          var childKind = childKinds_1[_i];
          this._getDefinition(childKind);
          parentDefinition.allowedChildKinds.add(childKind);
        }
      };
      DocNodeManager2.prototype.isAllowedChild = function(parentKind, childKind) {
        var parentDefinition = this._getDefinition(parentKind);
        return parentDefinition.allowedChildKinds.has(childKind);
      };
      DocNodeManager2.prototype._getDefinition = function(docNodeKind) {
        var definition = this._docNodeDefinitionsByKind.get(docNodeKind);
        if (definition === void 0) {
          throw new Error('The DocNode kind "' + docNodeKind + '" was not registered with this TSDocConfiguration');
        }
        return definition;
      };
      DocNodeManager2._nodeKindRegExp = /^[_a-z][_a-z0-9]*$/i;
      return DocNodeManager2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/details/Standardization.js
var Standardization;
var init_Standardization = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/details/Standardization.js"() {
    "use strict";
    (function(Standardization2) {
      Standardization2["Core"] = "Core";
      Standardization2["Extended"] = "Extended";
      Standardization2["Discretionary"] = "Discretionary";
      Standardization2["None"] = "None";
    })(Standardization || (Standardization = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/configuration/TSDocTagDefinition.js
var TSDocTagSyntaxKind, TSDocTagDefinition;
var init_TSDocTagDefinition = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/configuration/TSDocTagDefinition.js"() {
    "use strict";
    init_StringChecks();
    init_Standardization();
    (function(TSDocTagSyntaxKind2) {
      TSDocTagSyntaxKind2[TSDocTagSyntaxKind2["InlineTag"] = 0] = "InlineTag";
      TSDocTagSyntaxKind2[TSDocTagSyntaxKind2["BlockTag"] = 1] = "BlockTag";
      TSDocTagSyntaxKind2[TSDocTagSyntaxKind2["ModifierTag"] = 2] = "ModifierTag";
    })(TSDocTagSyntaxKind || (TSDocTagSyntaxKind = {}));
    TSDocTagDefinition = /** @class */
    function() {
      function TSDocTagDefinition2(parameters) {
        StringChecks.validateTSDocTagName(parameters.tagName);
        this.tagName = parameters.tagName;
        this.tagNameWithUpperCase = parameters.tagName.toUpperCase();
        this.syntaxKind = parameters.syntaxKind;
        this.standardization = parameters.standardization || Standardization.None;
        this.allowMultiple = !!parameters.allowMultiple;
      }
      TSDocTagDefinition2.validateTSDocTagName = function(tagName) {
        StringChecks.validateTSDocTagName(tagName);
      };
      return TSDocTagDefinition2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/details/StandardTags.js
var StandardTags;
var init_StandardTags = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/details/StandardTags.js"() {
    "use strict";
    init_TSDocTagDefinition();
    init_Standardization();
    StandardTags = /** @class */
    function() {
      function StandardTags2() {
      }
      StandardTags2._defineTag = function(parameters) {
        return new TSDocTagDefinition(parameters);
      };
      StandardTags2.alpha = StandardTags2._defineTag({
        tagName: "@alpha",
        syntaxKind: TSDocTagSyntaxKind.ModifierTag,
        standardization: Standardization.Discretionary
      });
      StandardTags2.beta = StandardTags2._defineTag({
        tagName: "@beta",
        syntaxKind: TSDocTagSyntaxKind.ModifierTag,
        standardization: Standardization.Discretionary
      });
      StandardTags2.decorator = StandardTags2._defineTag({
        tagName: "@decorator",
        syntaxKind: TSDocTagSyntaxKind.BlockTag,
        allowMultiple: true,
        standardization: Standardization.Extended
      });
      StandardTags2.defaultValue = StandardTags2._defineTag({
        tagName: "@defaultValue",
        syntaxKind: TSDocTagSyntaxKind.BlockTag,
        standardization: Standardization.Extended
      });
      StandardTags2.deprecated = StandardTags2._defineTag({
        tagName: "@deprecated",
        syntaxKind: TSDocTagSyntaxKind.BlockTag,
        standardization: Standardization.Core
      });
      StandardTags2.eventProperty = StandardTags2._defineTag({
        tagName: "@eventProperty",
        syntaxKind: TSDocTagSyntaxKind.ModifierTag,
        standardization: Standardization.Extended
      });
      StandardTags2.example = StandardTags2._defineTag({
        tagName: "@example",
        syntaxKind: TSDocTagSyntaxKind.BlockTag,
        allowMultiple: true,
        standardization: Standardization.Extended
      });
      StandardTags2.experimental = StandardTags2._defineTag({
        tagName: "@experimental",
        syntaxKind: TSDocTagSyntaxKind.ModifierTag,
        standardization: Standardization.Discretionary
      });
      StandardTags2.inheritDoc = StandardTags2._defineTag({
        tagName: "@inheritDoc",
        syntaxKind: TSDocTagSyntaxKind.InlineTag,
        standardization: Standardization.Extended
      });
      StandardTags2.internal = StandardTags2._defineTag({
        tagName: "@internal",
        syntaxKind: TSDocTagSyntaxKind.ModifierTag,
        standardization: Standardization.Discretionary
      });
      StandardTags2.label = StandardTags2._defineTag({
        tagName: "@label",
        syntaxKind: TSDocTagSyntaxKind.InlineTag,
        standardization: Standardization.Core
      });
      StandardTags2.link = StandardTags2._defineTag({
        tagName: "@link",
        syntaxKind: TSDocTagSyntaxKind.InlineTag,
        allowMultiple: true,
        standardization: Standardization.Core
      });
      StandardTags2.override = StandardTags2._defineTag({
        tagName: "@override",
        syntaxKind: TSDocTagSyntaxKind.ModifierTag,
        standardization: Standardization.Extended
      });
      StandardTags2.packageDocumentation = StandardTags2._defineTag({
        tagName: "@packageDocumentation",
        syntaxKind: TSDocTagSyntaxKind.ModifierTag,
        standardization: Standardization.Core
      });
      StandardTags2.param = StandardTags2._defineTag({
        tagName: "@param",
        syntaxKind: TSDocTagSyntaxKind.BlockTag,
        allowMultiple: true,
        standardization: Standardization.Core
      });
      StandardTags2.privateRemarks = StandardTags2._defineTag({
        tagName: "@privateRemarks",
        syntaxKind: TSDocTagSyntaxKind.BlockTag,
        standardization: Standardization.Core
      });
      StandardTags2.public = StandardTags2._defineTag({
        tagName: "@public",
        syntaxKind: TSDocTagSyntaxKind.ModifierTag,
        standardization: Standardization.Discretionary
      });
      StandardTags2.readonly = StandardTags2._defineTag({
        tagName: "@readonly",
        syntaxKind: TSDocTagSyntaxKind.ModifierTag,
        standardization: Standardization.Extended
      });
      StandardTags2.remarks = StandardTags2._defineTag({
        tagName: "@remarks",
        syntaxKind: TSDocTagSyntaxKind.BlockTag,
        standardization: Standardization.Core
      });
      StandardTags2.returns = StandardTags2._defineTag({
        tagName: "@returns",
        syntaxKind: TSDocTagSyntaxKind.BlockTag,
        standardization: Standardization.Core
      });
      StandardTags2.sealed = StandardTags2._defineTag({
        tagName: "@sealed",
        syntaxKind: TSDocTagSyntaxKind.ModifierTag,
        standardization: Standardization.Extended
      });
      StandardTags2.see = StandardTags2._defineTag({
        tagName: "@see",
        syntaxKind: TSDocTagSyntaxKind.BlockTag,
        standardization: Standardization.Extended
      });
      StandardTags2.throws = StandardTags2._defineTag({
        tagName: "@throws",
        syntaxKind: TSDocTagSyntaxKind.BlockTag,
        allowMultiple: true,
        standardization: Standardization.Extended
      });
      StandardTags2.typeParam = StandardTags2._defineTag({
        tagName: "@typeParam",
        syntaxKind: TSDocTagSyntaxKind.BlockTag,
        allowMultiple: true,
        standardization: Standardization.Core
      });
      StandardTags2.virtual = StandardTags2._defineTag({
        tagName: "@virtual",
        syntaxKind: TSDocTagSyntaxKind.ModifierTag,
        standardization: Standardization.Extended
      });
      StandardTags2.allDefinitions = [
        StandardTags2.alpha,
        StandardTags2.beta,
        StandardTags2.defaultValue,
        StandardTags2.decorator,
        StandardTags2.deprecated,
        StandardTags2.eventProperty,
        StandardTags2.example,
        StandardTags2.experimental,
        StandardTags2.inheritDoc,
        StandardTags2.internal,
        StandardTags2.label,
        StandardTags2.link,
        StandardTags2.override,
        StandardTags2.packageDocumentation,
        StandardTags2.param,
        StandardTags2.privateRemarks,
        StandardTags2.public,
        StandardTags2.readonly,
        StandardTags2.remarks,
        StandardTags2.returns,
        StandardTags2.sealed,
        StandardTags2.see,
        StandardTags2.throws,
        StandardTags2.typeParam,
        StandardTags2.virtual
      ];
      return StandardTags2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/configuration/TSDocValidationConfiguration.js
var TSDocValidationConfiguration;
var init_TSDocValidationConfiguration = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/configuration/TSDocValidationConfiguration.js"() {
    "use strict";
    TSDocValidationConfiguration = /** @class */
    /* @__PURE__ */ function() {
      function TSDocValidationConfiguration2() {
        this.ignoreUndefinedTags = false;
        this.reportUnsupportedTags = false;
        this.reportUnsupportedHtmlElements = false;
      }
      return TSDocValidationConfiguration2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocNode.js
var DocNodeKind, DocNode;
var init_DocNode = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocNode.js"() {
    "use strict";
    (function(DocNodeKind2) {
      DocNodeKind2["Block"] = "Block";
      DocNodeKind2["BlockTag"] = "BlockTag";
      DocNodeKind2["Excerpt"] = "Excerpt";
      DocNodeKind2["FencedCode"] = "FencedCode";
      DocNodeKind2["CodeSpan"] = "CodeSpan";
      DocNodeKind2["Comment"] = "Comment";
      DocNodeKind2["DeclarationReference"] = "DeclarationReference";
      DocNodeKind2["ErrorText"] = "ErrorText";
      DocNodeKind2["EscapedText"] = "EscapedText";
      DocNodeKind2["HtmlAttribute"] = "HtmlAttribute";
      DocNodeKind2["HtmlEndTag"] = "HtmlEndTag";
      DocNodeKind2["HtmlStartTag"] = "HtmlStartTag";
      DocNodeKind2["InheritDocTag"] = "InheritDocTag";
      DocNodeKind2["InlineTag"] = "InlineTag";
      DocNodeKind2["LinkTag"] = "LinkTag";
      DocNodeKind2["MemberIdentifier"] = "MemberIdentifier";
      DocNodeKind2["MemberReference"] = "MemberReference";
      DocNodeKind2["MemberSelector"] = "MemberSelector";
      DocNodeKind2["MemberSymbol"] = "MemberSymbol";
      DocNodeKind2["Paragraph"] = "Paragraph";
      DocNodeKind2["ParamBlock"] = "ParamBlock";
      DocNodeKind2["ParamCollection"] = "ParamCollection";
      DocNodeKind2["PlainText"] = "PlainText";
      DocNodeKind2["Section"] = "Section";
      DocNodeKind2["SoftBreak"] = "SoftBreak";
    })(DocNodeKind || (DocNodeKind = {}));
    DocNode = /** @class */
    function() {
      function DocNode2(parameters) {
        this.configuration = parameters.configuration;
      }
      DocNode2.prototype.getChildNodes = function() {
        this.configuration.docNodeManager.throwIfNotRegisteredKind(this.kind);
        return this.onGetChildNodes().filter(function(x) {
          return x !== void 0;
        });
      };
      DocNode2.prototype.onGetChildNodes = function() {
        return [];
      };
      DocNode2.isParsedParameters = function(parameters) {
        return parameters.parsed === true;
      };
      return DocNode2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/BuiltInDocNodes.js
var BuiltInDocNodes;
var init_BuiltInDocNodes = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/BuiltInDocNodes.js"() {
    "use strict";
    init_DocNode();
    init_lib();
    BuiltInDocNodes = /** @class */
    function() {
      function BuiltInDocNodes2() {
      }
      BuiltInDocNodes2.register = function(configuration) {
        var docNodeManager = configuration.docNodeManager;
        docNodeManager.registerDocNodes("@microsoft/tsdoc", [
          { docNodeKind: DocNodeKind.Block, constructor: DocBlock },
          { docNodeKind: DocNodeKind.BlockTag, constructor: DocBlockTag },
          { docNodeKind: DocNodeKind.CodeSpan, constructor: DocCodeSpan },
          { docNodeKind: DocNodeKind.Comment, constructor: DocComment },
          { docNodeKind: DocNodeKind.DeclarationReference, constructor: DocDeclarationReference },
          { docNodeKind: DocNodeKind.ErrorText, constructor: DocErrorText },
          { docNodeKind: DocNodeKind.EscapedText, constructor: DocEscapedText },
          { docNodeKind: DocNodeKind.Excerpt, constructor: DocExcerpt },
          { docNodeKind: DocNodeKind.FencedCode, constructor: DocFencedCode },
          { docNodeKind: DocNodeKind.HtmlAttribute, constructor: DocHtmlAttribute },
          { docNodeKind: DocNodeKind.HtmlEndTag, constructor: DocHtmlEndTag },
          { docNodeKind: DocNodeKind.HtmlStartTag, constructor: DocHtmlStartTag },
          { docNodeKind: DocNodeKind.InheritDocTag, constructor: DocInheritDocTag },
          { docNodeKind: DocNodeKind.InlineTag, constructor: DocInlineTag },
          { docNodeKind: DocNodeKind.LinkTag, constructor: DocLinkTag },
          { docNodeKind: DocNodeKind.MemberIdentifier, constructor: DocMemberIdentifier },
          { docNodeKind: DocNodeKind.MemberReference, constructor: DocMemberReference },
          { docNodeKind: DocNodeKind.MemberSelector, constructor: DocMemberSelector },
          { docNodeKind: DocNodeKind.MemberSymbol, constructor: DocMemberSymbol },
          { docNodeKind: DocNodeKind.Paragraph, constructor: DocParagraph },
          { docNodeKind: DocNodeKind.ParamBlock, constructor: DocParamBlock },
          { docNodeKind: DocNodeKind.ParamCollection, constructor: DocParamCollection },
          { docNodeKind: DocNodeKind.PlainText, constructor: DocPlainText },
          { docNodeKind: DocNodeKind.Section, constructor: DocSection },
          { docNodeKind: DocNodeKind.SoftBreak, constructor: DocSoftBreak }
        ]);
        docNodeManager.registerAllowableChildren(DocNodeKind.Section, [
          DocNodeKind.FencedCode,
          DocNodeKind.Paragraph,
          DocNodeKind.HtmlStartTag,
          DocNodeKind.HtmlEndTag
        ]);
        docNodeManager.registerAllowableChildren(DocNodeKind.Paragraph, [
          DocNodeKind.BlockTag,
          DocNodeKind.CodeSpan,
          DocNodeKind.ErrorText,
          DocNodeKind.EscapedText,
          DocNodeKind.HtmlStartTag,
          DocNodeKind.HtmlEndTag,
          DocNodeKind.InlineTag,
          DocNodeKind.LinkTag,
          DocNodeKind.PlainText,
          DocNodeKind.SoftBreak
        ]);
      };
      return BuiltInDocNodes2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/TSDocMessageId.js
var TSDocMessageId, allTsdocMessageIds, allTsdocMessageIdsSet;
var init_TSDocMessageId = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/TSDocMessageId.js"() {
    "use strict";
    (function(TSDocMessageId2) {
      TSDocMessageId2["ConfigFileNotFound"] = "tsdoc-config-file-not-found";
      TSDocMessageId2["ConfigInvalidJson"] = "tsdoc-config-invalid-json";
      TSDocMessageId2["ConfigFileUnsupportedSchema"] = "tsdoc-config-unsupported-schema";
      TSDocMessageId2["ConfigFileSchemaError"] = "tsdoc-config-schema-error";
      TSDocMessageId2["ConfigFileCyclicExtends"] = "tsdoc-config-cyclic-extends";
      TSDocMessageId2["ConfigFileUnresolvedExtends"] = "tsdoc-config-unresolved-extends";
      TSDocMessageId2["ConfigFileUndefinedTag"] = "tsdoc-config-undefined-tag";
      TSDocMessageId2["ConfigFileDuplicateTagName"] = "tsdoc-config-duplicate-tag-name";
      TSDocMessageId2["ConfigFileInvalidTagName"] = "tsdoc-config-invalid-tag-name";
      TSDocMessageId2["CommentNotFound"] = "tsdoc-comment-not-found";
      TSDocMessageId2["CommentOpeningDelimiterSyntax"] = "tsdoc-comment-missing-opening-delimiter";
      TSDocMessageId2["CommentMissingClosingDelimiter"] = "tsdoc-comment-missing-closing-delimiter";
      TSDocMessageId2["ExtraInheritDocTag"] = "tsdoc-extra-inheritdoc-tag";
      TSDocMessageId2["EscapeRightBrace"] = "tsdoc-escape-right-brace";
      TSDocMessageId2["EscapeGreaterThan"] = "tsdoc-escape-greater-than";
      TSDocMessageId2["MissingDeprecationMessage"] = "tsdoc-missing-deprecation-message";
      TSDocMessageId2["InheritDocIncompatibleTag"] = "tsdoc-inheritdoc-incompatible-tag";
      TSDocMessageId2["InheritDocIncompatibleSummary"] = "tsdoc-inheritdoc-incompatible-summary";
      TSDocMessageId2["InlineTagMissingBraces"] = "tsdoc-inline-tag-missing-braces";
      TSDocMessageId2["TagShouldNotHaveBraces"] = "tsdoc-tag-should-not-have-braces";
      TSDocMessageId2["UnsupportedTag"] = "tsdoc-unsupported-tag";
      TSDocMessageId2["UndefinedTag"] = "tsdoc-undefined-tag";
      TSDocMessageId2["ParamTagWithInvalidType"] = "tsdoc-param-tag-with-invalid-type";
      TSDocMessageId2["ParamTagWithInvalidOptionalName"] = "tsdoc-param-tag-with-invalid-optional-name";
      TSDocMessageId2["ParamTagWithInvalidName"] = "tsdoc-param-tag-with-invalid-name";
      TSDocMessageId2["ParamTagMissingHyphen"] = "tsdoc-param-tag-missing-hyphen";
      TSDocMessageId2["UnnecessaryBackslash"] = "tsdoc-unnecessary-backslash";
      TSDocMessageId2["MissingTag"] = "tsdoc-missing-tag";
      TSDocMessageId2["AtSignInWord"] = "tsdoc-at-sign-in-word";
      TSDocMessageId2["AtSignWithoutTagName"] = "tsdoc-at-sign-without-tag-name";
      TSDocMessageId2["MalformedInlineTag"] = "tsdoc-malformed-inline-tag";
      TSDocMessageId2["CharactersAfterBlockTag"] = "tsdoc-characters-after-block-tag";
      TSDocMessageId2["MalformedTagName"] = "tsdoc-malformed-tag-name";
      TSDocMessageId2["CharactersAfterInlineTag"] = "tsdoc-characters-after-inline-tag";
      TSDocMessageId2["InlineTagMissingRightBrace"] = "tsdoc-inline-tag-missing-right-brace";
      TSDocMessageId2["InlineTagUnescapedBrace"] = "tsdoc-inline-tag-unescaped-brace";
      TSDocMessageId2["InheritDocTagSyntax"] = "tsdoc-inheritdoc-tag-syntax";
      TSDocMessageId2["LinkTagEmpty"] = "tsdoc-link-tag-empty";
      TSDocMessageId2["LinkTagUnescapedText"] = "tsdoc-link-tag-unescaped-text";
      TSDocMessageId2["LinkTagDestinationSyntax"] = "tsdoc-link-tag-destination-syntax";
      TSDocMessageId2["LinkTagInvalidUrl"] = "tsdoc-link-tag-invalid-url";
      TSDocMessageId2["ReferenceMissingHash"] = "tsdoc-reference-missing-hash";
      TSDocMessageId2["ReferenceHashSyntax"] = "tsdoc-reference-hash-syntax";
      TSDocMessageId2["ReferenceMalformedPackageName"] = "tsdoc-reference-malformed-package-name";
      TSDocMessageId2["ReferenceMalformedImportPath"] = "tsdoc-reference-malformed-import-path";
      TSDocMessageId2["MissingReference"] = "tsdoc-missing-reference";
      TSDocMessageId2["ReferenceMissingDot"] = "tsdoc-reference-missing-dot";
      TSDocMessageId2["ReferenceSelectorMissingParens"] = "tsdoc-reference-selector-missing-parens";
      TSDocMessageId2["ReferenceMissingColon"] = "tsdoc-reference-missing-colon";
      TSDocMessageId2["ReferenceMissingRightParen"] = "tsdoc-reference-missing-right-paren";
      TSDocMessageId2["ReferenceSymbolSyntax"] = "tsdoc-reference-symbol-syntax";
      TSDocMessageId2["ReferenceMissingRightBracket"] = "tsdoc-reference-missing-right-bracket";
      TSDocMessageId2["ReferenceMissingQuote"] = "tsdoc-reference-missing-quote";
      TSDocMessageId2["ReferenceEmptyIdentifier"] = "tsdoc-reference-empty-identifier";
      TSDocMessageId2["ReferenceMissingIdentifier"] = "tsdoc-reference-missing-identifier";
      TSDocMessageId2["ReferenceUnquotedIdentifier"] = "tsdoc-reference-unquoted-identifier";
      TSDocMessageId2["ReferenceMissingLabel"] = "tsdoc-reference-missing-label";
      TSDocMessageId2["ReferenceSelectorSyntax"] = "tsdoc-reference-selector-syntax";
      TSDocMessageId2["HtmlTagMissingGreaterThan"] = "tsdoc-html-tag-missing-greater-than";
      TSDocMessageId2["HtmlTagMissingEquals"] = "tsdoc-html-tag-missing-equals";
      TSDocMessageId2["HtmlTagMissingString"] = "tsdoc-html-tag-missing-string";
      TSDocMessageId2["HtmlStringMissingQuote"] = "tsdoc-html-string-missing-quote";
      TSDocMessageId2["TextAfterHtmlString"] = "tsdoc-text-after-html-string";
      TSDocMessageId2["MissingHtmlEndTag"] = "tsdoc-missing-html-end-tag";
      TSDocMessageId2["MalformedHtmlName"] = "tsdoc-malformed-html-name";
      TSDocMessageId2["UnsupportedHtmlElementName"] = "tsdoc-unsupported-html-name";
      TSDocMessageId2["CodeFenceOpeningIndent"] = "tsdoc-code-fence-opening-indent";
      TSDocMessageId2["CodeFenceSpecifierSyntax"] = "tsdoc-code-fence-specifier-syntax";
      TSDocMessageId2["CodeFenceClosingIndent"] = "tsdoc-code-fence-closing-indent";
      TSDocMessageId2["CodeFenceMissingDelimiter"] = "tsdoc-code-fence-missing-delimiter";
      TSDocMessageId2["CodeFenceClosingSyntax"] = "tsdoc-code-fence-closing-syntax";
      TSDocMessageId2["CodeSpanEmpty"] = "tsdoc-code-span-empty";
      TSDocMessageId2["CodeSpanMissingDelimiter"] = "tsdoc-code-span-missing-delimiter";
    })(TSDocMessageId || (TSDocMessageId = {}));
    allTsdocMessageIds = [
      // To make comparisons easy, keep these in the same order as the enum above:
      "tsdoc-config-file-not-found",
      "tsdoc-config-invalid-json",
      "tsdoc-config-unsupported-schema",
      "tsdoc-config-schema-error",
      "tsdoc-config-cyclic-extends",
      "tsdoc-config-unresolved-extends",
      "tsdoc-config-undefined-tag",
      "tsdoc-config-duplicate-tag-name",
      "tsdoc-config-invalid-tag-name",
      "tsdoc-comment-not-found",
      "tsdoc-comment-missing-opening-delimiter",
      "tsdoc-comment-missing-closing-delimiter",
      "tsdoc-extra-inheritdoc-tag",
      "tsdoc-escape-right-brace",
      "tsdoc-escape-greater-than",
      "tsdoc-missing-deprecation-message",
      "tsdoc-inheritdoc-incompatible-tag",
      "tsdoc-inheritdoc-incompatible-summary",
      "tsdoc-inline-tag-missing-braces",
      "tsdoc-tag-should-not-have-braces",
      "tsdoc-unsupported-tag",
      "tsdoc-undefined-tag",
      "tsdoc-param-tag-with-invalid-type",
      "tsdoc-param-tag-with-invalid-optional-name",
      "tsdoc-param-tag-with-invalid-name",
      "tsdoc-param-tag-missing-hyphen",
      "tsdoc-unnecessary-backslash",
      "tsdoc-missing-tag",
      "tsdoc-at-sign-in-word",
      "tsdoc-at-sign-without-tag-name",
      "tsdoc-malformed-inline-tag",
      "tsdoc-characters-after-block-tag",
      "tsdoc-malformed-tag-name",
      "tsdoc-characters-after-inline-tag",
      "tsdoc-inline-tag-missing-right-brace",
      "tsdoc-inline-tag-unescaped-brace",
      "tsdoc-inheritdoc-tag-syntax",
      "tsdoc-link-tag-empty",
      "tsdoc-link-tag-unescaped-text",
      "tsdoc-link-tag-destination-syntax",
      "tsdoc-link-tag-invalid-url",
      "tsdoc-reference-missing-hash",
      "tsdoc-reference-hash-syntax",
      "tsdoc-reference-malformed-package-name",
      "tsdoc-reference-malformed-import-path",
      "tsdoc-missing-reference",
      "tsdoc-reference-missing-dot",
      "tsdoc-reference-selector-missing-parens",
      "tsdoc-reference-missing-colon",
      "tsdoc-reference-missing-right-paren",
      "tsdoc-reference-symbol-syntax",
      "tsdoc-reference-missing-right-bracket",
      "tsdoc-reference-missing-quote",
      "tsdoc-reference-empty-identifier",
      "tsdoc-reference-missing-identifier",
      "tsdoc-reference-unquoted-identifier",
      "tsdoc-reference-missing-label",
      "tsdoc-reference-selector-syntax",
      "tsdoc-html-tag-missing-greater-than",
      "tsdoc-html-tag-missing-equals",
      "tsdoc-html-tag-missing-string",
      "tsdoc-html-string-missing-quote",
      "tsdoc-text-after-html-string",
      "tsdoc-missing-html-end-tag",
      "tsdoc-malformed-html-name",
      "tsdoc-code-fence-opening-indent",
      "tsdoc-code-fence-specifier-syntax",
      "tsdoc-code-fence-closing-indent",
      "tsdoc-code-fence-missing-delimiter",
      "tsdoc-code-fence-closing-syntax",
      "tsdoc-code-span-empty",
      "tsdoc-code-span-missing-delimiter"
    ];
    allTsdocMessageIds.sort();
    allTsdocMessageIdsSet = new Set(allTsdocMessageIds);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/configuration/TSDocConfiguration.js
var TSDocConfiguration;
var init_TSDocConfiguration = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/configuration/TSDocConfiguration.js"() {
    "use strict";
    init_StandardTags();
    init_TSDocValidationConfiguration();
    init_DocNodeManager();
    init_BuiltInDocNodes();
    init_TSDocMessageId();
    TSDocConfiguration = /** @class */
    function() {
      function TSDocConfiguration2() {
        this._tagDefinitions = [];
        this._tagDefinitionsByName = /* @__PURE__ */ new Map();
        this._supportedTagDefinitions = /* @__PURE__ */ new Set();
        this._validation = new TSDocValidationConfiguration();
        this._docNodeManager = new DocNodeManager();
        this._supportedHtmlElements = /* @__PURE__ */ new Set();
        this.clear(false);
        BuiltInDocNodes.register(this);
      }
      TSDocConfiguration2.prototype.clear = function(noStandardTags) {
        if (noStandardTags === void 0) {
          noStandardTags = false;
        }
        this._tagDefinitions.length = 0;
        this._tagDefinitionsByName.clear();
        this._supportedTagDefinitions.clear();
        this._validation.ignoreUndefinedTags = false;
        this._validation.reportUnsupportedTags = false;
        this._validation.reportUnsupportedHtmlElements = false;
        this._supportedHtmlElements.clear();
        if (!noStandardTags) {
          this.addTagDefinitions(StandardTags.allDefinitions);
        }
      };
      Object.defineProperty(TSDocConfiguration2.prototype, "tagDefinitions", {
        /**
         * The TSDoc tags that are defined in this configuration.
         *
         * @remarks
         * The subset of "supported" tags is tracked by {@link TSDocConfiguration.supportedTagDefinitions}.
         */
        get: function() {
          return this._tagDefinitions;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TSDocConfiguration2.prototype, "supportedTagDefinitions", {
        /**
         * Returns the subset of {@link TSDocConfiguration.tagDefinitions}
         * that are supported in this configuration.
         *
         * @remarks
         * This property is only used when
         * {@link TSDocValidationConfiguration.reportUnsupportedTags} is enabled.
         */
        get: function() {
          var _this = this;
          return this.tagDefinitions.filter(function(x) {
            return _this.isTagSupported(x);
          });
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TSDocConfiguration2.prototype, "validation", {
        /**
         * Enable/disable validation checks performed by the parser.
         */
        get: function() {
          return this._validation;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TSDocConfiguration2.prototype, "supportedHtmlElements", {
        /**
         * The HTML element names that are supported in this configuration. Used in conjunction with the `reportUnsupportedHtmlElements` setting.
         */
        get: function() {
          return Array.from(this._supportedHtmlElements.values());
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TSDocConfiguration2.prototype, "docNodeManager", {
        /**
         * Register custom DocNode subclasses.
         */
        get: function() {
          return this._docNodeManager;
        },
        enumerable: false,
        configurable: true
      });
      TSDocConfiguration2.prototype.tryGetTagDefinition = function(tagName) {
        return this._tagDefinitionsByName.get(tagName.toUpperCase());
      };
      TSDocConfiguration2.prototype.tryGetTagDefinitionWithUpperCase = function(alreadyUpperCaseTagName) {
        return this._tagDefinitionsByName.get(alreadyUpperCaseTagName);
      };
      TSDocConfiguration2.prototype.addTagDefinition = function(tagDefinition) {
        var existingDefinition = this._tagDefinitionsByName.get(tagDefinition.tagNameWithUpperCase);
        if (existingDefinition === tagDefinition) {
          return;
        }
        if (existingDefinition) {
          throw new Error("A tag is already defined using the name " + existingDefinition.tagName);
        }
        this._tagDefinitions.push(tagDefinition);
        this._tagDefinitionsByName.set(tagDefinition.tagNameWithUpperCase, tagDefinition);
      };
      TSDocConfiguration2.prototype.addTagDefinitions = function(tagDefinitions, supported) {
        for (var _i = 0, tagDefinitions_1 = tagDefinitions; _i < tagDefinitions_1.length; _i++) {
          var tagDefinition = tagDefinitions_1[_i];
          this.addTagDefinition(tagDefinition);
          if (supported !== void 0) {
            this.setSupportForTag(tagDefinition, supported);
          }
        }
      };
      TSDocConfiguration2.prototype.isTagSupported = function(tagDefinition) {
        this._requireTagToBeDefined(tagDefinition);
        return this._supportedTagDefinitions.has(tagDefinition);
      };
      TSDocConfiguration2.prototype.setSupportForTag = function(tagDefinition, supported) {
        this._requireTagToBeDefined(tagDefinition);
        if (supported) {
          this._supportedTagDefinitions.add(tagDefinition);
        } else {
          this._supportedTagDefinitions.delete(tagDefinition);
        }
        this.validation.reportUnsupportedTags = true;
      };
      TSDocConfiguration2.prototype.setSupportForTags = function(tagDefinitions, supported) {
        for (var _i = 0, tagDefinitions_2 = tagDefinitions; _i < tagDefinitions_2.length; _i++) {
          var tagDefinition = tagDefinitions_2[_i];
          this.setSupportForTag(tagDefinition, supported);
        }
      };
      TSDocConfiguration2.prototype.setSupportedHtmlElements = function(htmlTags) {
        this._supportedHtmlElements.clear();
        this._validation.reportUnsupportedHtmlElements = true;
        for (var _i = 0, htmlTags_1 = htmlTags; _i < htmlTags_1.length; _i++) {
          var htmlTag = htmlTags_1[_i];
          this._supportedHtmlElements.add(htmlTag);
        }
      };
      TSDocConfiguration2.prototype.isHtmlElementSupported = function(htmlTag) {
        return this._supportedHtmlElements.has(htmlTag);
      };
      TSDocConfiguration2.prototype.isKnownMessageId = function(messageId) {
        return allTsdocMessageIdsSet.has(messageId);
      };
      Object.defineProperty(TSDocConfiguration2.prototype, "allTsdocMessageIds", {
        /**
         * Returns the list of {@link TSDocMessageId} strings that are implemented by this release of the TSDoc parser.
         *
         * @privateRemarks
         *
         * Why this API is associated with TSDocConfiguration:  In the future, if we enable support for custom extensions
         * of the TSDoc parser, we may provide a way to register custom message identifiers.
         */
        get: function() {
          return allTsdocMessageIds;
        },
        enumerable: false,
        configurable: true
      });
      TSDocConfiguration2.prototype._requireTagToBeDefined = function(tagDefinition) {
        var matching = this._tagDefinitionsByName.get(tagDefinition.tagNameWithUpperCase);
        if (matching) {
          if (matching === tagDefinition) {
            return;
          }
        }
        throw new Error("The specified TSDocTagDefinition is not defined for this TSDocConfiguration");
      };
      return TSDocConfiguration2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/details/ModifierTagSet.js
var ModifierTagSet;
var init_ModifierTagSet = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/details/ModifierTagSet.js"() {
    "use strict";
    init_TSDocTagDefinition();
    ModifierTagSet = /** @class */
    function() {
      function ModifierTagSet2() {
        this._nodes = [];
        this._nodesByName = /* @__PURE__ */ new Map();
      }
      Object.defineProperty(ModifierTagSet2.prototype, "nodes", {
        /**
         * The original block tag nodes that defined the modifiers in this set, excluding duplicates.
         */
        get: function() {
          return this._nodes;
        },
        enumerable: false,
        configurable: true
      });
      ModifierTagSet2.prototype.hasTagName = function(modifierTagName) {
        return this._nodesByName.has(modifierTagName.toUpperCase());
      };
      ModifierTagSet2.prototype.hasTag = function(modifierTagDefinition) {
        return !!this.tryGetTag(modifierTagDefinition);
      };
      ModifierTagSet2.prototype.tryGetTag = function(modifierTagDefinition) {
        if (modifierTagDefinition.syntaxKind !== TSDocTagSyntaxKind.ModifierTag) {
          throw new Error("The tag definition is not a modifier tag");
        }
        return this._nodesByName.get(modifierTagDefinition.tagNameWithUpperCase);
      };
      ModifierTagSet2.prototype.addTag = function(blockTag) {
        if (this._nodesByName.has(blockTag.tagNameWithUpperCase)) {
          return false;
        }
        this._nodesByName.set(blockTag.tagNameWithUpperCase, blockTag);
        this._nodes.push(blockTag);
        return true;
      };
      return ModifierTagSet2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/details/StandardModifierTagSet.js
var __extends, StandardModifierTagSet;
var init_StandardModifierTagSet = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/details/StandardModifierTagSet.js"() {
    "use strict";
    init_ModifierTagSet();
    init_StandardTags();
    __extends = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    StandardModifierTagSet = /** @class */
    function(_super) {
      __extends(StandardModifierTagSet2, _super);
      function StandardModifierTagSet2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      StandardModifierTagSet2.prototype.isAlpha = function() {
        return this.hasTag(StandardTags.alpha);
      };
      StandardModifierTagSet2.prototype.isBeta = function() {
        return this.hasTag(StandardTags.beta);
      };
      StandardModifierTagSet2.prototype.isEventProperty = function() {
        return this.hasTag(StandardTags.eventProperty);
      };
      StandardModifierTagSet2.prototype.isExperimental = function() {
        return this.hasTag(StandardTags.experimental);
      };
      StandardModifierTagSet2.prototype.isInternal = function() {
        return this.hasTag(StandardTags.internal);
      };
      StandardModifierTagSet2.prototype.isOverride = function() {
        return this.hasTag(StandardTags.override);
      };
      StandardModifierTagSet2.prototype.isPackageDocumentation = function() {
        return this.hasTag(StandardTags.packageDocumentation);
      };
      StandardModifierTagSet2.prototype.isPublic = function() {
        return this.hasTag(StandardTags.public);
      };
      StandardModifierTagSet2.prototype.isReadonly = function() {
        return this.hasTag(StandardTags.readonly);
      };
      StandardModifierTagSet2.prototype.isSealed = function() {
        return this.hasTag(StandardTags.sealed);
      };
      StandardModifierTagSet2.prototype.isVirtual = function() {
        return this.hasTag(StandardTags.virtual);
      };
      return StandardModifierTagSet2;
    }(ModifierTagSet);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocNodeContainer.js
var __extends2, DocNodeContainer;
var init_DocNodeContainer = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocNodeContainer.js"() {
    "use strict";
    init_DocNode();
    __extends2 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocNodeContainer = /** @class */
    function(_super) {
      __extends2(DocNodeContainer2, _super);
      function DocNodeContainer2(parameters, childNodes) {
        var _this = _super.call(this, parameters) || this;
        _this._nodes = [];
        if (childNodes !== void 0 && childNodes.length > 0) {
          _this.appendNodes(childNodes);
        }
        return _this;
      }
      Object.defineProperty(DocNodeContainer2.prototype, "nodes", {
        /**
         * The nodes that were added to this container.
         */
        get: function() {
          return this._nodes;
        },
        enumerable: false,
        configurable: true
      });
      DocNodeContainer2.prototype.appendNode = function(docNode) {
        if (!this.configuration.docNodeManager.isAllowedChild(this.kind, docNode.kind)) {
          throw new Error("The TSDocConfiguration does not allow a " + this.kind + " node to" + (" contain a node of type " + docNode.kind));
        }
        this._nodes.push(docNode);
      };
      DocNodeContainer2.prototype.appendNodes = function(docNodes) {
        for (var _i = 0, docNodes_1 = docNodes; _i < docNodes_1.length; _i++) {
          var docNode = docNodes_1[_i];
          this.appendNode(docNode);
        }
      };
      DocNodeContainer2.prototype.clearNodes = function() {
        this._nodes.length = 0;
      };
      DocNodeContainer2.prototype.onGetChildNodes = function() {
        return this._nodes;
      };
      return DocNodeContainer2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocParagraph.js
var __extends3, DocParagraph;
var init_DocParagraph = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocParagraph.js"() {
    "use strict";
    init_DocNode();
    init_DocNodeContainer();
    __extends3 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocParagraph = /** @class */
    function(_super) {
      __extends3(DocParagraph2, _super);
      function DocParagraph2(parameters, childNodes) {
        return _super.call(this, parameters, childNodes) || this;
      }
      Object.defineProperty(DocParagraph2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.Paragraph;
        },
        enumerable: false,
        configurable: true
      });
      return DocParagraph2;
    }(DocNodeContainer);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocSection.js
var __extends4, DocSection;
var init_DocSection = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocSection.js"() {
    "use strict";
    init_DocNode();
    init_DocParagraph();
    init_DocNodeContainer();
    __extends4 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocSection = /** @class */
    function(_super) {
      __extends4(DocSection2, _super);
      function DocSection2(parameters, childNodes) {
        return _super.call(this, parameters, childNodes) || this;
      }
      Object.defineProperty(DocSection2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.Section;
        },
        enumerable: false,
        configurable: true
      });
      DocSection2.prototype.appendNodeInParagraph = function(docNode) {
        var paragraphNode = void 0;
        if (this.nodes.length > 0) {
          var lastNode = this.nodes[this.nodes.length - 1];
          if (lastNode.kind === DocNodeKind.Paragraph) {
            paragraphNode = lastNode;
          }
        }
        if (!paragraphNode) {
          paragraphNode = new DocParagraph({ configuration: this.configuration });
          this.appendNode(paragraphNode);
        }
        paragraphNode.appendNode(docNode);
      };
      DocSection2.prototype.appendNodesInParagraph = function(docNodes) {
        for (var _i = 0, docNodes_1 = docNodes; _i < docNodes_1.length; _i++) {
          var docNode = docNodes_1[_i];
          this.appendNodeInParagraph(docNode);
        }
      };
      return DocSection2;
    }(DocNodeContainer);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocBlock.js
var __extends5, DocBlock;
var init_DocBlock = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocBlock.js"() {
    "use strict";
    init_DocNode();
    init_DocSection();
    __extends5 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocBlock = /** @class */
    function(_super) {
      __extends5(DocBlock2, _super);
      function DocBlock2(parameters) {
        var _this = _super.call(this, parameters) || this;
        _this._blockTag = parameters.blockTag;
        _this._content = new DocSection({ configuration: _this.configuration });
        return _this;
      }
      Object.defineProperty(DocBlock2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.Block;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocBlock2.prototype, "blockTag", {
        /**
         * The TSDoc tag that introduces this section.
         */
        get: function() {
          return this._blockTag;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocBlock2.prototype, "content", {
        /**
         * The TSDoc tag that introduces this section.
         */
        get: function() {
          return this._content;
        },
        enumerable: false,
        configurable: true
      });
      DocBlock2.prototype.onGetChildNodes = function() {
        return [this.blockTag, this._content];
      };
      return DocBlock2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/Token.js
var TokenKind, Token;
var init_Token = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/Token.js"() {
    "use strict";
    (function(TokenKind2) {
      TokenKind2[TokenKind2["EndOfInput"] = 2001] = "EndOfInput";
      TokenKind2[TokenKind2["Newline"] = 2002] = "Newline";
      TokenKind2[TokenKind2["Spacing"] = 2003] = "Spacing";
      TokenKind2[TokenKind2["AsciiWord"] = 2004] = "AsciiWord";
      TokenKind2[TokenKind2["OtherPunctuation"] = 2005] = "OtherPunctuation";
      TokenKind2[TokenKind2["Other"] = 2006] = "Other";
      TokenKind2[TokenKind2["Backslash"] = 2007] = "Backslash";
      TokenKind2[TokenKind2["LessThan"] = 2008] = "LessThan";
      TokenKind2[TokenKind2["GreaterThan"] = 2009] = "GreaterThan";
      TokenKind2[TokenKind2["Equals"] = 2010] = "Equals";
      TokenKind2[TokenKind2["SingleQuote"] = 2011] = "SingleQuote";
      TokenKind2[TokenKind2["DoubleQuote"] = 2012] = "DoubleQuote";
      TokenKind2[TokenKind2["Slash"] = 2013] = "Slash";
      TokenKind2[TokenKind2["Hyphen"] = 2014] = "Hyphen";
      TokenKind2[TokenKind2["AtSign"] = 2015] = "AtSign";
      TokenKind2[TokenKind2["LeftCurlyBracket"] = 2016] = "LeftCurlyBracket";
      TokenKind2[TokenKind2["RightCurlyBracket"] = 2017] = "RightCurlyBracket";
      TokenKind2[TokenKind2["Backtick"] = 2018] = "Backtick";
      TokenKind2[TokenKind2["Period"] = 2019] = "Period";
      TokenKind2[TokenKind2["Colon"] = 2020] = "Colon";
      TokenKind2[TokenKind2["Comma"] = 2021] = "Comma";
      TokenKind2[TokenKind2["LeftSquareBracket"] = 2022] = "LeftSquareBracket";
      TokenKind2[TokenKind2["RightSquareBracket"] = 2023] = "RightSquareBracket";
      TokenKind2[TokenKind2["Pipe"] = 2024] = "Pipe";
      TokenKind2[TokenKind2["LeftParenthesis"] = 2025] = "LeftParenthesis";
      TokenKind2[TokenKind2["RightParenthesis"] = 2026] = "RightParenthesis";
      TokenKind2[TokenKind2["PoundSymbol"] = 2027] = "PoundSymbol";
      TokenKind2[TokenKind2["Plus"] = 2028] = "Plus";
      TokenKind2[TokenKind2["DollarSign"] = 2029] = "DollarSign";
    })(TokenKind || (TokenKind = {}));
    Token = /** @class */
    function() {
      function Token2(kind, range, line) {
        this.kind = kind;
        this.range = range;
        this.line = line;
      }
      Token2.prototype.toString = function() {
        if (this.kind === TokenKind.Newline) {
          return "\n";
        }
        return this.range.toString();
      };
      return Token2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocExcerpt.js
var __extends6, ExcerptKind, DocExcerpt;
var init_DocExcerpt = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocExcerpt.js"() {
    "use strict";
    init_DocNode();
    init_Token();
    __extends6 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(ExcerptKind2) {
      ExcerptKind2["Spacing"] = "Spacing";
      ExcerptKind2["BlockTag"] = "BlockTag";
      ExcerptKind2["CodeSpan_OpeningDelimiter"] = "CodeSpan_OpeningDelimiter";
      ExcerptKind2["CodeSpan_Code"] = "CodeSpan_Code";
      ExcerptKind2["CodeSpan_ClosingDelimiter"] = "CodeSpan_ClosingDelimiter";
      ExcerptKind2["DeclarationReference_PackageName"] = "DeclarationReference_PackageName";
      ExcerptKind2["DeclarationReference_ImportPath"] = "DeclarationReference_ImportPath";
      ExcerptKind2["DeclarationReference_ImportHash"] = "DeclarationReference_ImportHash";
      ExcerptKind2["ErrorText"] = "ErrorText";
      ExcerptKind2["NonstandardText"] = "NonstandardText";
      ExcerptKind2["EscapedText"] = "EscapedText";
      ExcerptKind2["FencedCode_OpeningFence"] = "FencedCode_OpeningFence";
      ExcerptKind2["FencedCode_Language"] = "FencedCode_Language";
      ExcerptKind2["FencedCode_Code"] = "FencedCode_Code";
      ExcerptKind2["FencedCode_ClosingFence"] = "FencedCode_ClosingFence";
      ExcerptKind2["HtmlAttribute_Name"] = "HtmlAttribute_Name";
      ExcerptKind2["HtmlAttribute_Equals"] = "HtmlAttribute_Equals";
      ExcerptKind2["HtmlAttribute_Value"] = "HtmlAttribute_Value";
      ExcerptKind2["HtmlEndTag_OpeningDelimiter"] = "HtmlEndTag_OpeningDelimiter";
      ExcerptKind2["HtmlEndTag_Name"] = "HtmlEndTag_Name";
      ExcerptKind2["HtmlEndTag_ClosingDelimiter"] = "HtmlEndTag_ClosingDelimiter";
      ExcerptKind2["HtmlStartTag_OpeningDelimiter"] = "HtmlStartTag_OpeningDelimiter";
      ExcerptKind2["HtmlStartTag_Name"] = "HtmlStartTag_Name";
      ExcerptKind2["HtmlStartTag_ClosingDelimiter"] = "HtmlStartTag_ClosingDelimiter";
      ExcerptKind2["InlineTag_OpeningDelimiter"] = "InlineTag_OpeningDelimiter";
      ExcerptKind2["InlineTag_TagName"] = "InlineTag_TagName";
      ExcerptKind2["InlineTag_TagContent"] = "InlineTag_TagContent";
      ExcerptKind2["InlineTag_ClosingDelimiter"] = "InlineTag_ClosingDelimiter";
      ExcerptKind2["LinkTag_UrlDestination"] = "LinkTag_UrlDestination";
      ExcerptKind2["LinkTag_Pipe"] = "LinkTag_Pipe";
      ExcerptKind2["LinkTag_LinkText"] = "LinkTag_LinkText";
      ExcerptKind2["MemberIdentifier_LeftQuote"] = "MemberIdentifier_LeftQuote";
      ExcerptKind2["MemberIdentifier_Identifier"] = "MemberIdentifier_Identifier";
      ExcerptKind2["MemberIdentifier_RightQuote"] = "MemberIdentifier_RightQuote";
      ExcerptKind2["MemberReference_Dot"] = "MemberReference_Dot";
      ExcerptKind2["MemberReference_LeftParenthesis"] = "MemberReference_LeftParenthesis";
      ExcerptKind2["MemberReference_Colon"] = "MemberReference_Colon";
      ExcerptKind2["MemberReference_RightParenthesis"] = "MemberReference_RightParenthesis";
      ExcerptKind2["MemberSelector"] = "MemberSelector";
      ExcerptKind2["DocMemberSymbol_LeftBracket"] = "DocMemberSymbol_LeftBracket";
      ExcerptKind2["DocMemberSymbol_RightBracket"] = "DocMemberSymbol_RightBracket";
      ExcerptKind2["ParamBlock_ParameterName"] = "ParamBlock_ParameterName";
      ExcerptKind2["ParamBlock_Hyphen"] = "ParamBlock_Hyphen";
      ExcerptKind2["PlainText"] = "PlainText";
      ExcerptKind2["SoftBreak"] = "SoftBreak";
    })(ExcerptKind || (ExcerptKind = {}));
    DocExcerpt = /** @class */
    function(_super) {
      __extends6(DocExcerpt2, _super);
      function DocExcerpt2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (parameters.excerptKind === ExcerptKind.Spacing) {
          for (var _i = 0, _a = parameters.content.tokens; _i < _a.length; _i++) {
            var token = _a[_i];
            switch (token.kind) {
              case TokenKind.Spacing:
              case TokenKind.Newline:
              case TokenKind.EndOfInput:
                break;
              default:
                throw new Error("The excerptKind=Spacing but the range contains a non-whitespace token");
            }
          }
        }
        _this._excerptKind = parameters.excerptKind;
        _this._content = parameters.content;
        return _this;
      }
      Object.defineProperty(DocExcerpt2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.Excerpt;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocExcerpt2.prototype, "excerptKind", {
        /**
         * Indicates the kind of DocExcerpt.
         */
        get: function() {
          return this._excerptKind;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocExcerpt2.prototype, "content", {
        /**
         * The input token sequence corresponding to this excerpt.
         * @remarks
         * Note that a token sequence can span multiple input lines and may contain gaps, for example to skip the `*`
         * character that starts a new TSDoc comment line.
         */
        get: function() {
          return this._content;
        },
        enumerable: false,
        configurable: true
      });
      return DocExcerpt2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocBlockTag.js
var __extends7, DocBlockTag;
var init_DocBlockTag = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocBlockTag.js"() {
    "use strict";
    init_DocNode();
    init_StringChecks();
    init_DocExcerpt();
    __extends7 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocBlockTag = /** @class */
    function(_super) {
      __extends7(DocBlockTag2, _super);
      function DocBlockTag2(parameters) {
        var _this = _super.call(this, parameters) || this;
        StringChecks.validateTSDocTagName(parameters.tagName);
        _this._tagName = parameters.tagName;
        _this._tagNameWithUpperCase = parameters.tagName.toUpperCase();
        if (DocNode.isParsedParameters(parameters)) {
          _this._tagNameExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.BlockTag,
            content: parameters.tagNameExcerpt
          });
        }
        return _this;
      }
      Object.defineProperty(DocBlockTag2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.BlockTag;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocBlockTag2.prototype, "tagName", {
        /**
         * The TSDoc tag name.  TSDoc tag names start with an at-sign (`@`) followed
         * by ASCII letters using "camelCase" capitalization.
         */
        get: function() {
          return this._tagName;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocBlockTag2.prototype, "tagNameWithUpperCase", {
        /**
         * The TSDoc tag name in all capitals, which is used for performing
         * case-insensitive comparisons or lookups.
         */
        get: function() {
          return this._tagNameWithUpperCase;
        },
        enumerable: false,
        configurable: true
      });
      DocBlockTag2.prototype.onGetChildNodes = function() {
        return [this._tagNameExcerpt];
      };
      DocBlockTag2.prototype.getTokenSequence = function() {
        if (!this._tagNameExcerpt) {
          throw new Error("DocBlockTag.getTokenSequence() failed because this object did not originate from a parsed input");
        }
        return this._tagNameExcerpt.content;
      };
      return DocBlockTag2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocCodeSpan.js
var __extends8, DocCodeSpan;
var init_DocCodeSpan = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocCodeSpan.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    __extends8 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocCodeSpan = /** @class */
    function(_super) {
      __extends8(DocCodeSpan2, _super);
      function DocCodeSpan2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          _this._openingDelimiterExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.CodeSpan_OpeningDelimiter,
            content: parameters.openingDelimiterExcerpt
          });
          _this._codeExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.CodeSpan_Code,
            content: parameters.codeExcerpt
          });
          _this._closingDelimiterExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.CodeSpan_ClosingDelimiter,
            content: parameters.closingDelimiterExcerpt
          });
        } else {
          _this._code = parameters.code;
        }
        return _this;
      }
      Object.defineProperty(DocCodeSpan2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.CodeSpan;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocCodeSpan2.prototype, "code", {
        /**
         * The text that should be rendered as code, excluding the backtick delimiters.
         */
        get: function() {
          if (this._code === void 0) {
            this._code = this._codeExcerpt.content.toString();
          }
          return this._code;
        },
        enumerable: false,
        configurable: true
      });
      DocCodeSpan2.prototype.onGetChildNodes = function() {
        return [this._openingDelimiterExcerpt, this._codeExcerpt, this._closingDelimiterExcerpt];
      };
      return DocCodeSpan2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/emitters/StringBuilder.js
var StringBuilder;
var init_StringBuilder = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/emitters/StringBuilder.js"() {
    "use strict";
    StringBuilder = /** @class */
    function() {
      function StringBuilder2() {
        this._chunks = [];
      }
      StringBuilder2.prototype.append = function(text) {
        this._chunks.push(text);
      };
      StringBuilder2.prototype.toString = function() {
        if (this._chunks.length === 0) {
          return "";
        }
        if (this._chunks.length > 1) {
          var joined = this._chunks.join("");
          this._chunks.length = 1;
          this._chunks[0] = joined;
        }
        return this._chunks[0];
      };
      return StringBuilder2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/transforms/TrimSpacesTransform.js
var TrimSpacesTransform;
var init_TrimSpacesTransform = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/transforms/TrimSpacesTransform.js"() {
    "use strict";
    init_nodes();
    TrimSpacesTransform = /** @class */
    function() {
      function TrimSpacesTransform2() {
      }
      TrimSpacesTransform2.transform = function(docParagraph) {
        var transformedNodes = [];
        var pendingSpace = false;
        var accumulatedTextChunks = [];
        var accumulatedNodes = [];
        var finishedSkippingLeadingSpaces = false;
        for (var _i = 0, _a = docParagraph.nodes; _i < _a.length; _i++) {
          var node = _a[_i];
          switch (node.kind) {
            case DocNodeKind.PlainText:
              var docPlainText = node;
              var text = docPlainText.text;
              var startedWithSpace = /^\s/.test(text);
              var endedWithSpace = /\s$/.test(text);
              var collapsedText = text.replace(/\s+/g, " ").trim();
              if (startedWithSpace && finishedSkippingLeadingSpaces) {
                pendingSpace = true;
              }
              if (collapsedText.length > 0) {
                if (pendingSpace) {
                  accumulatedTextChunks.push(" ");
                  pendingSpace = false;
                }
                accumulatedTextChunks.push(collapsedText);
                accumulatedNodes.push(node);
                finishedSkippingLeadingSpaces = true;
              }
              if (endedWithSpace && finishedSkippingLeadingSpaces) {
                pendingSpace = true;
              }
              break;
            case DocNodeKind.SoftBreak:
              if (finishedSkippingLeadingSpaces) {
                pendingSpace = true;
              }
              accumulatedNodes.push(node);
              break;
            default:
              if (pendingSpace) {
                accumulatedTextChunks.push(" ");
                pendingSpace = false;
              }
              if (accumulatedTextChunks.length > 0) {
                transformedNodes.push(new DocPlainText({
                  configuration: docParagraph.configuration,
                  text: accumulatedTextChunks.join("")
                }));
                accumulatedTextChunks.length = 0;
                accumulatedNodes.length = 0;
              }
              transformedNodes.push(node);
              finishedSkippingLeadingSpaces = true;
          }
        }
        if (accumulatedTextChunks.length > 0) {
          transformedNodes.push(new DocPlainText({
            configuration: docParagraph.configuration,
            text: accumulatedTextChunks.join("")
          }));
          accumulatedTextChunks.length = 0;
          accumulatedNodes.length = 0;
        }
        var transformedParagraph = new DocParagraph({
          configuration: docParagraph.configuration
        });
        transformedParagraph.appendNodes(transformedNodes);
        return transformedParagraph;
      };
      return TrimSpacesTransform2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/transforms/DocNodeTransforms.js
var DocNodeTransforms;
var init_DocNodeTransforms = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/transforms/DocNodeTransforms.js"() {
    "use strict";
    init_TrimSpacesTransform();
    DocNodeTransforms = /** @class */
    function() {
      function DocNodeTransforms2() {
      }
      DocNodeTransforms2.trimSpacesInParagraph = function(docParagraph) {
        return TrimSpacesTransform.transform(docParagraph);
      };
      return DocNodeTransforms2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/emitters/TSDocEmitter.js
var __spreadArrays, LineState, TSDocEmitter;
var init_TSDocEmitter = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/emitters/TSDocEmitter.js"() {
    "use strict";
    init_DocNode();
    init_DocNodeTransforms();
    init_StandardTags();
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    (function(LineState2) {
      LineState2[LineState2["Closed"] = 0] = "Closed";
      LineState2[LineState2["StartOfLine"] = 1] = "StartOfLine";
      LineState2[LineState2["MiddleOfLine"] = 2] = "MiddleOfLine";
    })(LineState || (LineState = {}));
    TSDocEmitter = /** @class */
    function() {
      function TSDocEmitter2() {
        this.eol = "\n";
        this._emitCommentFraming = true;
        this._lineState = LineState.Closed;
        this._previousLineHadContent = false;
        this._hangingParagraph = false;
      }
      TSDocEmitter2.prototype.renderComment = function(output, docComment) {
        this._emitCommentFraming = true;
        this._renderCompleteObject(output, docComment);
      };
      TSDocEmitter2.prototype.renderHtmlTag = function(output, htmlTag) {
        this._emitCommentFraming = false;
        this._renderCompleteObject(output, htmlTag);
      };
      TSDocEmitter2.prototype.renderDeclarationReference = function(output, declarationReference) {
        this._emitCommentFraming = false;
        this._renderCompleteObject(output, declarationReference);
      };
      TSDocEmitter2.prototype._renderCompleteObject = function(output, docNode) {
        this._output = output;
        this._lineState = LineState.Closed;
        this._previousLineHadContent = false;
        this._hangingParagraph = false;
        this._renderNode(docNode);
        this._writeEnd();
      };
      TSDocEmitter2.prototype._renderNode = function(docNode) {
        var _this = this;
        if (docNode === void 0) {
          return;
        }
        switch (docNode.kind) {
          case DocNodeKind.Block:
            var docBlock = docNode;
            this._ensureLineSkipped();
            this._renderNode(docBlock.blockTag);
            if (docBlock.blockTag.tagNameWithUpperCase === StandardTags.returns.tagNameWithUpperCase) {
              this._writeContent(" ");
              this._hangingParagraph = true;
            }
            this._renderNode(docBlock.content);
            break;
          case DocNodeKind.BlockTag:
            var docBlockTag = docNode;
            if (this._lineState === LineState.MiddleOfLine) {
              this._writeContent(" ");
            }
            this._writeContent(docBlockTag.tagName);
            break;
          case DocNodeKind.CodeSpan:
            var docCodeSpan = docNode;
            this._writeContent("`");
            this._writeContent(docCodeSpan.code);
            this._writeContent("`");
            break;
          case DocNodeKind.Comment:
            var docComment = docNode;
            this._renderNodes(__spreadArrays([
              docComment.summarySection,
              docComment.remarksBlock,
              docComment.privateRemarks,
              docComment.deprecatedBlock,
              docComment.params,
              docComment.typeParams,
              docComment.returnsBlock
            ], docComment.customBlocks, docComment.seeBlocks, [
              docComment.inheritDocTag
            ]));
            if (docComment.modifierTagSet.nodes.length > 0) {
              this._ensureLineSkipped();
              this._renderNodes(docComment.modifierTagSet.nodes);
            }
            break;
          case DocNodeKind.DeclarationReference:
            var docDeclarationReference = docNode;
            this._writeContent(docDeclarationReference.packageName);
            this._writeContent(docDeclarationReference.importPath);
            if (docDeclarationReference.packageName !== void 0 || docDeclarationReference.importPath !== void 0) {
              this._writeContent("#");
            }
            this._renderNodes(docDeclarationReference.memberReferences);
            break;
          case DocNodeKind.ErrorText:
            var docErrorText = docNode;
            this._writeContent(docErrorText.text);
            break;
          case DocNodeKind.EscapedText:
            var docEscapedText = docNode;
            this._writeContent(docEscapedText.encodedText);
            break;
          case DocNodeKind.FencedCode:
            var docFencedCode = docNode;
            this._ensureAtStartOfLine();
            this._writeContent("```");
            this._writeContent(docFencedCode.language);
            this._writeNewline();
            this._writeContent(docFencedCode.code);
            this._writeContent("```");
            this._writeNewline();
            this._writeNewline();
            break;
          case DocNodeKind.HtmlAttribute:
            var docHtmlAttribute = docNode;
            this._writeContent(docHtmlAttribute.name);
            this._writeContent(docHtmlAttribute.spacingAfterName);
            this._writeContent("=");
            this._writeContent(docHtmlAttribute.spacingAfterEquals);
            this._writeContent(docHtmlAttribute.value);
            this._writeContent(docHtmlAttribute.spacingAfterValue);
            break;
          case DocNodeKind.HtmlEndTag:
            var docHtmlEndTag = docNode;
            this._writeContent("</");
            this._writeContent(docHtmlEndTag.name);
            this._writeContent(">");
            break;
          case DocNodeKind.HtmlStartTag:
            var docHtmlStartTag = docNode;
            this._writeContent("<");
            this._writeContent(docHtmlStartTag.name);
            this._writeContent(docHtmlStartTag.spacingAfterName);
            var needsSpace = docHtmlStartTag.spacingAfterName === void 0 || docHtmlStartTag.spacingAfterName.length === 0;
            for (var _i = 0, _a = docHtmlStartTag.htmlAttributes; _i < _a.length; _i++) {
              var attribute = _a[_i];
              if (needsSpace) {
                this._writeContent(" ");
              }
              this._renderNode(attribute);
              needsSpace = attribute.spacingAfterValue === void 0 || attribute.spacingAfterValue.length === 0;
            }
            this._writeContent(docHtmlStartTag.selfClosingTag ? "/>" : ">");
            break;
          case DocNodeKind.InheritDocTag:
            var docInheritDocTag_1 = docNode;
            this._renderInlineTag(docInheritDocTag_1, function() {
              if (docInheritDocTag_1.declarationReference) {
                _this._writeContent(" ");
                _this._renderNode(docInheritDocTag_1.declarationReference);
              }
            });
            break;
          case DocNodeKind.InlineTag:
            var docInlineTag_1 = docNode;
            this._renderInlineTag(docInlineTag_1, function() {
              if (docInlineTag_1.tagContent.length > 0) {
                _this._writeContent(" ");
                _this._writeContent(docInlineTag_1.tagContent);
              }
            });
            break;
          case DocNodeKind.LinkTag:
            var docLinkTag_1 = docNode;
            this._renderInlineTag(docLinkTag_1, function() {
              if (docLinkTag_1.urlDestination !== void 0 || docLinkTag_1.codeDestination !== void 0) {
                if (docLinkTag_1.urlDestination !== void 0) {
                  _this._writeContent(" ");
                  _this._writeContent(docLinkTag_1.urlDestination);
                } else if (docLinkTag_1.codeDestination !== void 0) {
                  _this._writeContent(" ");
                  _this._renderNode(docLinkTag_1.codeDestination);
                }
              }
              if (docLinkTag_1.linkText !== void 0) {
                _this._writeContent(" ");
                _this._writeContent("|");
                _this._writeContent(" ");
                _this._writeContent(docLinkTag_1.linkText);
              }
            });
            break;
          case DocNodeKind.MemberIdentifier:
            var docMemberIdentifier = docNode;
            if (docMemberIdentifier.hasQuotes) {
              this._writeContent('"');
              this._writeContent(docMemberIdentifier.identifier);
              this._writeContent('"');
            } else {
              this._writeContent(docMemberIdentifier.identifier);
            }
            break;
          case DocNodeKind.MemberReference:
            var docMemberReference = docNode;
            if (docMemberReference.hasDot) {
              this._writeContent(".");
            }
            if (docMemberReference.selector) {
              this._writeContent("(");
            }
            if (docMemberReference.memberSymbol) {
              this._renderNode(docMemberReference.memberSymbol);
            } else {
              this._renderNode(docMemberReference.memberIdentifier);
            }
            if (docMemberReference.selector) {
              this._writeContent(":");
              this._renderNode(docMemberReference.selector);
              this._writeContent(")");
            }
            break;
          case DocNodeKind.MemberSelector:
            var docMemberSelector = docNode;
            this._writeContent(docMemberSelector.selector);
            break;
          case DocNodeKind.MemberSymbol:
            var docMemberSymbol = docNode;
            this._writeContent("[");
            this._renderNode(docMemberSymbol.symbolReference);
            this._writeContent("]");
            break;
          case DocNodeKind.Section:
            var docSection = docNode;
            this._renderNodes(docSection.nodes);
            break;
          case DocNodeKind.Paragraph:
            var trimmedParagraph = DocNodeTransforms.trimSpacesInParagraph(docNode);
            if (trimmedParagraph.nodes.length > 0) {
              if (this._hangingParagraph) {
                this._hangingParagraph = false;
              } else {
                this._ensureLineSkipped();
              }
              this._renderNodes(trimmedParagraph.nodes);
              this._writeNewline();
            }
            break;
          case DocNodeKind.ParamBlock:
            var docParamBlock = docNode;
            this._ensureLineSkipped();
            this._renderNode(docParamBlock.blockTag);
            this._writeContent(" ");
            this._writeContent(docParamBlock.parameterName);
            this._writeContent(" - ");
            this._hangingParagraph = true;
            this._renderNode(docParamBlock.content);
            this._hangingParagraph = false;
            break;
          case DocNodeKind.ParamCollection:
            var docParamCollection = docNode;
            this._renderNodes(docParamCollection.blocks);
            break;
          case DocNodeKind.PlainText:
            var docPlainText = docNode;
            this._writeContent(docPlainText.text);
            break;
        }
      };
      TSDocEmitter2.prototype._renderInlineTag = function(docInlineTagBase, writeInlineTagContent) {
        this._writeContent("{");
        this._writeContent(docInlineTagBase.tagName);
        writeInlineTagContent();
        this._writeContent("}");
      };
      TSDocEmitter2.prototype._renderNodes = function(docNodes) {
        for (var _i = 0, docNodes_1 = docNodes; _i < docNodes_1.length; _i++) {
          var docNode = docNodes_1[_i];
          this._renderNode(docNode);
        }
      };
      TSDocEmitter2.prototype._ensureAtStartOfLine = function() {
        if (this._lineState === LineState.MiddleOfLine) {
          this._writeNewline();
        }
      };
      TSDocEmitter2.prototype._ensureLineSkipped = function() {
        this._ensureAtStartOfLine();
        if (this._previousLineHadContent) {
          this._writeNewline();
        }
      };
      TSDocEmitter2.prototype._writeContent = function(content) {
        if (content === void 0 || content.length === 0) {
          return;
        }
        var splitLines = content.split(/\r?\n/g);
        if (splitLines.length > 1) {
          var firstLine = true;
          for (var _i = 0, splitLines_1 = splitLines; _i < splitLines_1.length; _i++) {
            var line = splitLines_1[_i];
            if (firstLine) {
              firstLine = false;
            } else {
              this._writeNewline();
            }
            this._writeContent(line);
          }
          return;
        }
        if (this._lineState === LineState.Closed) {
          if (this._emitCommentFraming) {
            this._output.append("/**" + this.eol + " *");
          }
          this._lineState = LineState.StartOfLine;
        }
        if (this._lineState === LineState.StartOfLine) {
          if (this._emitCommentFraming) {
            this._output.append(" ");
          }
        }
        this._output.append(content);
        this._lineState = LineState.MiddleOfLine;
        this._previousLineHadContent = true;
      };
      TSDocEmitter2.prototype._writeNewline = function() {
        if (this._lineState === LineState.Closed) {
          if (this._emitCommentFraming) {
            this._output.append("/**" + this.eol + " *");
          }
          this._lineState = LineState.StartOfLine;
        }
        this._previousLineHadContent = this._lineState === LineState.MiddleOfLine;
        if (this._emitCommentFraming) {
          this._output.append(this.eol + " *");
        } else {
          this._output.append(this.eol);
        }
        this._lineState = LineState.StartOfLine;
        this._hangingParagraph = false;
      };
      TSDocEmitter2.prototype._writeEnd = function() {
        if (this._lineState === LineState.MiddleOfLine) {
          if (this._emitCommentFraming) {
            this._writeNewline();
          }
        }
        if (this._lineState !== LineState.Closed) {
          if (this._emitCommentFraming) {
            this._output.append("/" + this.eol);
          }
          this._lineState = LineState.Closed;
        }
      };
      return TSDocEmitter2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocParamCollection.js
var __extends9, DocParamCollection;
var init_DocParamCollection = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocParamCollection.js"() {
    "use strict";
    init_DocNode();
    __extends9 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocParamCollection = /** @class */
    function(_super) {
      __extends9(DocParamCollection2, _super);
      function DocParamCollection2(parameters) {
        var _this = _super.call(this, parameters) || this;
        _this._blocks = [];
        return _this;
      }
      Object.defineProperty(DocParamCollection2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.ParamCollection;
        },
        enumerable: false,
        configurable: true
      });
      DocParamCollection2.prototype[Symbol.iterator] = function() {
        return this._blocks[Symbol.iterator]();
      };
      Object.defineProperty(DocParamCollection2.prototype, "blocks", {
        /**
         * Returns the blocks in this collection.
         */
        get: function() {
          return this._blocks;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocParamCollection2.prototype, "count", {
        /**
         * Returns the number of blocks in this collection.
         */
        get: function() {
          return this._blocks.length;
        },
        enumerable: false,
        configurable: true
      });
      DocParamCollection2.prototype.add = function(docParamBlock) {
        this._blocks.push(docParamBlock);
        if (this._blocksByName === void 0) {
          this._blocksByName = /* @__PURE__ */ new Map();
        }
        if (!this._blocksByName.has(docParamBlock.parameterName)) {
          this._blocksByName.set(docParamBlock.parameterName, docParamBlock);
        }
      };
      DocParamCollection2.prototype.clear = function() {
        this._blocks.length = 0;
        this._blocksByName = void 0;
      };
      DocParamCollection2.prototype.tryGetBlockByName = function(parameterName) {
        if (this._blocksByName) {
          return this._blocksByName.get(parameterName);
        }
        return void 0;
      };
      DocParamCollection2.prototype.onGetChildNodes = function() {
        return this._blocks;
      };
      return DocParamCollection2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocComment.js
var __extends10, __spreadArrays2, DocComment;
var init_DocComment = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocComment.js"() {
    "use strict";
    init_DocNode();
    init_DocSection();
    init_StandardModifierTagSet();
    init_StringBuilder();
    init_TSDocEmitter();
    init_DocParamCollection();
    __extends10 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays2 = function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    DocComment = /** @class */
    function(_super) {
      __extends10(DocComment2, _super);
      function DocComment2(parameters) {
        var _this = _super.call(this, parameters) || this;
        _this.summarySection = new DocSection({ configuration: _this.configuration });
        _this.remarksBlock = void 0;
        _this.privateRemarks = void 0;
        _this.deprecatedBlock = void 0;
        _this.params = new DocParamCollection({ configuration: _this.configuration });
        _this.typeParams = new DocParamCollection({ configuration: _this.configuration });
        _this.returnsBlock = void 0;
        _this.modifierTagSet = new StandardModifierTagSet();
        _this._seeBlocks = [];
        _this._customBlocks = [];
        return _this;
      }
      Object.defineProperty(DocComment2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.Comment;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocComment2.prototype, "seeBlocks", {
        /**
         * The collection of all `@see` DockBlockTag nodes belonging to this doc comment.
         */
        get: function() {
          return this._seeBlocks;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocComment2.prototype, "customBlocks", {
        /**
         * The collection of all DocBlock nodes belonging to this doc comment.
         */
        get: function() {
          return this._customBlocks;
        },
        enumerable: false,
        configurable: true
      });
      DocComment2.prototype._appendSeeBlock = function(block) {
        this._seeBlocks.push(block);
      };
      DocComment2.prototype.appendCustomBlock = function(block) {
        this._customBlocks.push(block);
      };
      DocComment2.prototype.onGetChildNodes = function() {
        return __spreadArrays2([
          this.summarySection,
          this.remarksBlock,
          this.privateRemarks,
          this.deprecatedBlock,
          this.params.count > 0 ? this.params : void 0,
          this.typeParams.count > 0 ? this.typeParams : void 0,
          this.returnsBlock
        ], this.customBlocks, this.seeBlocks, [
          this.inheritDocTag
        ], this.modifierTagSet.nodes);
      };
      DocComment2.prototype.emitAsTsdoc = function() {
        var stringBuilder = new StringBuilder();
        var emitter = new TSDocEmitter();
        emitter.renderComment(stringBuilder, this);
        return stringBuilder.toString();
      };
      return DocComment2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocDeclarationReference.js
var __extends11, __spreadArrays3, DocDeclarationReference;
var init_DocDeclarationReference = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocDeclarationReference.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    init_StringBuilder();
    init_TSDocEmitter();
    __extends11 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays3 = function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    DocDeclarationReference = /** @class */
    function(_super) {
      __extends11(DocDeclarationReference2, _super);
      function DocDeclarationReference2(parameters) {
        var _a;
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          if (parameters.packageNameExcerpt) {
            _this._packageNameExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.DeclarationReference_PackageName,
              content: parameters.packageNameExcerpt
            });
          }
          if (parameters.importPathExcerpt) {
            _this._importPathExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.DeclarationReference_ImportPath,
              content: parameters.importPathExcerpt
            });
          }
          if (parameters.importHashExcerpt) {
            _this._importHashExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.DeclarationReference_ImportHash,
              content: parameters.importHashExcerpt
            });
          }
          if (parameters.spacingAfterImportHashExcerpt) {
            _this._spacingAfterImportHashExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterImportHashExcerpt
            });
          }
        } else {
          _this._packageName = parameters.packageName;
          _this._importPath = parameters.importPath;
        }
        _this._memberReferences = [];
        if (parameters.memberReferences) {
          (_a = _this._memberReferences).push.apply(_a, parameters.memberReferences);
        }
        return _this;
      }
      Object.defineProperty(DocDeclarationReference2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.DeclarationReference;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocDeclarationReference2.prototype, "packageName", {
        /**
         * The optional package name, which may optionally include an NPM scope.
         *
         * Example: `"@scope/my-package"`
         */
        get: function() {
          if (this._packageName === void 0) {
            if (this._packageNameExcerpt !== void 0) {
              this._packageName = this._packageNameExcerpt.content.toString();
            }
          }
          return this._packageName;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocDeclarationReference2.prototype, "importPath", {
        /**
         * The optional import path.  If a package name is provided, then if an import path is provided,
         * the path must start with a "/" delimiter; otherwise paths are resolved relative to the source file
         * containing the reference.
         *
         * Example: `"/path1/path2"`
         * Example: `"./path1/path2"`
         * Example: `"../path2/path2"`
         */
        get: function() {
          if (this._importPath === void 0) {
            if (this._importPathExcerpt !== void 0) {
              this._importPath = this._importPathExcerpt.content.toString();
            }
          }
          return this._importPath;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocDeclarationReference2.prototype, "memberReferences", {
        /**
         * The chain of member references that indicate the declaration being referenced.
         * If this list is empty, then either the packageName or importPath must be provided,
         * because the reference refers to a module.
         */
        get: function() {
          return this._memberReferences;
        },
        enumerable: false,
        configurable: true
      });
      DocDeclarationReference2.prototype.emitAsTsdoc = function() {
        var stringBuilder = new StringBuilder();
        var emitter = new TSDocEmitter();
        emitter.renderDeclarationReference(stringBuilder, this);
        return stringBuilder.toString();
      };
      DocDeclarationReference2.prototype.onGetChildNodes = function() {
        return __spreadArrays3([
          this._packageNameExcerpt,
          this._importPathExcerpt,
          this._importHashExcerpt,
          this._spacingAfterImportHashExcerpt
        ], this._memberReferences);
      };
      return DocDeclarationReference2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocErrorText.js
var __extends12, DocErrorText;
var init_DocErrorText = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocErrorText.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    __extends12 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocErrorText = /** @class */
    function(_super) {
      __extends12(DocErrorText2, _super);
      function DocErrorText2(parameters) {
        var _this = _super.call(this, parameters) || this;
        _this._textExcerpt = new DocExcerpt({
          configuration: _this.configuration,
          excerptKind: ExcerptKind.ErrorText,
          content: parameters.textExcerpt
        });
        _this._messageId = parameters.messageId;
        _this._errorMessage = parameters.errorMessage;
        _this._errorLocation = parameters.errorLocation;
        return _this;
      }
      Object.defineProperty(DocErrorText2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.ErrorText;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocErrorText2.prototype, "text", {
        /**
         * The characters that should be rendered as plain text because they
         * could not be parsed successfully.
         */
        get: function() {
          if (this._text === void 0) {
            this._text = this._textExcerpt.content.toString();
          }
          return this._text;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocErrorText2.prototype, "textExcerpt", {
        get: function() {
          if (this._textExcerpt) {
            return this._textExcerpt.content;
          } else {
            return void 0;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocErrorText2.prototype, "messageId", {
        /**
         * The TSDoc error message identifier.
         */
        get: function() {
          return this._messageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocErrorText2.prototype, "errorMessage", {
        /**
         * A description of why the character could not be parsed.
         */
        get: function() {
          return this._errorMessage;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocErrorText2.prototype, "errorLocation", {
        /**
         * The range of characters that caused the error.  In general these may be
         * somewhat farther ahead in the input stream from the DocErrorText node itself.
         *
         * @remarks
         * For example, for the malformed HTML tag `<a href="123" @ /a>`, the DocErrorText node
         * will correspond to the `<` character that looked like an HTML tag, whereas the
         * error location might be the `@` character that caused the trouble.
         */
        get: function() {
          return this._errorLocation;
        },
        enumerable: false,
        configurable: true
      });
      DocErrorText2.prototype.onGetChildNodes = function() {
        return [this._textExcerpt];
      };
      return DocErrorText2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocEscapedText.js
var __extends13, EscapeStyle, DocEscapedText;
var init_DocEscapedText = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocEscapedText.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    __extends13 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(EscapeStyle2) {
      EscapeStyle2[EscapeStyle2["CommonMarkBackslash"] = 0] = "CommonMarkBackslash";
    })(EscapeStyle || (EscapeStyle = {}));
    DocEscapedText = /** @class */
    function(_super) {
      __extends13(DocEscapedText2, _super);
      function DocEscapedText2(parameters) {
        var _this = _super.call(this, parameters) || this;
        _this._escapeStyle = parameters.escapeStyle;
        _this._encodedTextExcerpt = new DocExcerpt({
          configuration: _this.configuration,
          excerptKind: ExcerptKind.EscapedText,
          content: parameters.encodedTextExcerpt
        });
        _this._decodedText = parameters.decodedText;
        return _this;
      }
      Object.defineProperty(DocEscapedText2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.EscapedText;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocEscapedText2.prototype, "escapeStyle", {
        /**
         * The style of escaping to be performed.
         */
        get: function() {
          return this._escapeStyle;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocEscapedText2.prototype, "encodedText", {
        /**
         * The text sequence including escapes.
         */
        get: function() {
          if (this._encodedText === void 0) {
            this._encodedText = this._encodedTextExcerpt.content.toString();
          }
          return this._encodedText;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocEscapedText2.prototype, "decodedText", {
        /**
         * The text without escaping.
         */
        get: function() {
          return this._decodedText;
        },
        enumerable: false,
        configurable: true
      });
      DocEscapedText2.prototype.onGetChildNodes = function() {
        return [this._encodedTextExcerpt];
      };
      return DocEscapedText2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocFencedCode.js
var __extends14, DocFencedCode;
var init_DocFencedCode = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocFencedCode.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    __extends14 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocFencedCode = /** @class */
    function(_super) {
      __extends14(DocFencedCode2, _super);
      function DocFencedCode2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          _this._openingFenceExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.FencedCode_OpeningFence,
            content: parameters.openingFenceExcerpt
          });
          if (parameters.spacingAfterOpeningFenceExcerpt) {
            _this._spacingAfterOpeningFenceExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterOpeningFenceExcerpt
            });
          }
          if (parameters.languageExcerpt) {
            _this._languageExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.FencedCode_Language,
              content: parameters.languageExcerpt
            });
          }
          if (parameters.spacingAfterLanguageExcerpt) {
            _this._spacingAfterLanguageExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterLanguageExcerpt
            });
          }
          _this._codeExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.FencedCode_Code,
            content: parameters.codeExcerpt
          });
          if (parameters.spacingBeforeClosingFenceExcerpt) {
            _this._spacingBeforeClosingFenceExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingBeforeClosingFenceExcerpt
            });
          }
          _this._closingFenceExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.FencedCode_ClosingFence,
            content: parameters.closingFenceExcerpt
          });
          if (parameters.spacingAfterClosingFenceExcerpt) {
            _this._spacingAfterClosingFenceExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterClosingFenceExcerpt
            });
          }
        } else {
          _this._code = parameters.code;
          _this._language = parameters.language;
        }
        return _this;
      }
      Object.defineProperty(DocFencedCode2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.FencedCode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocFencedCode2.prototype, "language", {
        /**
         * A name that can optionally be included after the opening code fence delimiter,
         * on the same line as the three backticks.  This name indicates the programming language
         * for the code, which a syntax highlighter may use to style the code block.
         *
         * @remarks
         * The TSDoc standard requires that the language "ts" should be interpreted to mean TypeScript.
         * Other languages names may be supported, but this is implementation dependent.
         *
         * CommonMark refers to this field as the "info string".
         *
         * @privateRemarks
         * Examples of language strings supported by GitHub flavored markdown:
         * https://raw.githubusercontent.com/github/linguist/master/lib/linguist/languages.yml
         */
        get: function() {
          if (this._language === void 0) {
            if (this._languageExcerpt !== void 0) {
              this._language = this._languageExcerpt.content.toString();
            } else {
              this._language = "";
            }
          }
          return this._language;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocFencedCode2.prototype, "code", {
        /**
         * The text that should be rendered as code.
         */
        get: function() {
          if (this._code === void 0) {
            if (this._codeExcerpt !== void 0) {
              this._code = this._codeExcerpt.content.toString();
            }
          }
          return this._code;
        },
        enumerable: false,
        configurable: true
      });
      DocFencedCode2.prototype.onGetChildNodes = function() {
        return [
          this._openingFenceExcerpt,
          this._spacingAfterOpeningFenceExcerpt,
          this._languageExcerpt,
          this._spacingAfterLanguageExcerpt,
          this._codeExcerpt,
          this._spacingBeforeClosingFenceExcerpt,
          this._closingFenceExcerpt,
          this._spacingAfterClosingFenceExcerpt
        ];
      };
      return DocFencedCode2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocHtmlAttribute.js
var __extends15, DocHtmlAttribute;
var init_DocHtmlAttribute = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocHtmlAttribute.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    __extends15 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocHtmlAttribute = /** @class */
    function(_super) {
      __extends15(DocHtmlAttribute2, _super);
      function DocHtmlAttribute2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          _this._nameExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.HtmlAttribute_Name,
            content: parameters.nameExcerpt
          });
          if (parameters.spacingAfterNameExcerpt) {
            _this._spacingAfterNameExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterNameExcerpt
            });
          }
          _this._equalsExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.HtmlAttribute_Equals,
            content: parameters.equalsExcerpt
          });
          if (parameters.spacingAfterEqualsExcerpt) {
            _this._spacingAfterEqualsExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterEqualsExcerpt
            });
          }
          _this._valueExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.HtmlAttribute_Value,
            content: parameters.valueExcerpt
          });
          if (parameters.spacingAfterValueExcerpt) {
            _this._spacingAfterValueExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterValueExcerpt
            });
          }
        } else {
          _this._name = parameters.name;
          _this._spacingAfterName = parameters.spacingAfterName;
          _this._spacingAfterEquals = parameters.spacingAfterEquals;
          _this._value = parameters.value;
          _this._spacingAfterValue = parameters.spacingAfterValue;
        }
        return _this;
      }
      Object.defineProperty(DocHtmlAttribute2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.HtmlAttribute;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocHtmlAttribute2.prototype, "name", {
        /**
         * The HTML attribute name.
         */
        get: function() {
          if (this._name === void 0) {
            this._name = this._nameExcerpt.content.toString();
          }
          return this._name;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocHtmlAttribute2.prototype, "spacingAfterName", {
        /**
         * Explicit whitespace that a renderer should insert after the HTML attribute name.
         * If undefined, then the renderer can use a formatting rule to generate appropriate spacing.
         */
        get: function() {
          if (this._spacingAfterName === void 0) {
            if (this._spacingAfterNameExcerpt !== void 0) {
              this._spacingAfterName = this._spacingAfterNameExcerpt.content.toString();
            }
          }
          return this._spacingAfterName;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocHtmlAttribute2.prototype, "spacingAfterEquals", {
        /**
         * Explicit whitespace that a renderer should insert after the "=".
         * If undefined, then the renderer can use a formatting rule to generate appropriate spacing.
         */
        get: function() {
          if (this._spacingAfterEquals === void 0) {
            if (this._spacingAfterEqualsExcerpt !== void 0) {
              this._spacingAfterEquals = this._spacingAfterEqualsExcerpt.content.toString();
            }
          }
          return this._spacingAfterEquals;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocHtmlAttribute2.prototype, "value", {
        /**
         * The HTML attribute value.
         */
        get: function() {
          if (this._value === void 0) {
            this._value = this._valueExcerpt.content.toString();
          }
          return this._value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocHtmlAttribute2.prototype, "spacingAfterValue", {
        /**
         * Explicit whitespace that a renderer should insert after the HTML attribute name.
         * If undefined, then the renderer can use a formatting rule to generate appropriate spacing.
         */
        get: function() {
          if (this._spacingAfterValue === void 0) {
            if (this._spacingAfterValueExcerpt !== void 0) {
              this._spacingAfterValue = this._spacingAfterValueExcerpt.content.toString();
            }
          }
          return this._spacingAfterValue;
        },
        enumerable: false,
        configurable: true
      });
      DocHtmlAttribute2.prototype.onGetChildNodes = function() {
        return [
          this._nameExcerpt,
          this._spacingAfterNameExcerpt,
          this._equalsExcerpt,
          this._spacingAfterEqualsExcerpt,
          this._valueExcerpt,
          this._spacingAfterValueExcerpt
        ];
      };
      return DocHtmlAttribute2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocHtmlEndTag.js
var __extends16, DocHtmlEndTag;
var init_DocHtmlEndTag = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocHtmlEndTag.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    init_StringBuilder();
    init_TSDocEmitter();
    __extends16 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocHtmlEndTag = /** @class */
    function(_super) {
      __extends16(DocHtmlEndTag2, _super);
      function DocHtmlEndTag2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          _this._openingDelimiterExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.HtmlEndTag_OpeningDelimiter,
            content: parameters.openingDelimiterExcerpt
          });
          _this._nameExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.HtmlEndTag_Name,
            content: parameters.nameExcerpt
          });
          if (parameters.spacingAfterNameExcerpt) {
            _this._spacingAfterNameExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterNameExcerpt
            });
          }
          _this._closingDelimiterExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.HtmlEndTag_ClosingDelimiter,
            content: parameters.closingDelimiterExcerpt
          });
        } else {
          _this._name = parameters.name;
        }
        return _this;
      }
      Object.defineProperty(DocHtmlEndTag2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.HtmlEndTag;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocHtmlEndTag2.prototype, "name", {
        /**
         * The HTML element name.
         */
        get: function() {
          if (this._name === void 0) {
            this._name = this._nameExcerpt.content.toString();
          }
          return this._name;
        },
        enumerable: false,
        configurable: true
      });
      DocHtmlEndTag2.prototype.emitAsHtml = function() {
        var stringBuilder = new StringBuilder();
        var emitter = new TSDocEmitter();
        emitter.renderHtmlTag(stringBuilder, this);
        return stringBuilder.toString();
      };
      DocHtmlEndTag2.prototype.onGetChildNodes = function() {
        return [
          this._openingDelimiterExcerpt,
          this._nameExcerpt,
          this._spacingAfterNameExcerpt,
          this._closingDelimiterExcerpt
        ];
      };
      return DocHtmlEndTag2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocHtmlStartTag.js
var __extends17, __spreadArrays4, DocHtmlStartTag;
var init_DocHtmlStartTag = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocHtmlStartTag.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    init_StringBuilder();
    init_TSDocEmitter();
    __extends17 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays4 = function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    DocHtmlStartTag = /** @class */
    function(_super) {
      __extends17(DocHtmlStartTag2, _super);
      function DocHtmlStartTag2(parameters) {
        var _a;
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          _this._openingDelimiterExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.HtmlStartTag_OpeningDelimiter,
            content: parameters.openingDelimiterExcerpt
          });
          _this._nameExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.HtmlStartTag_Name,
            content: parameters.nameExcerpt
          });
          if (parameters.spacingAfterNameExcerpt) {
            _this._spacingAfterNameExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterNameExcerpt
            });
          }
          _this._closingDelimiterExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.HtmlStartTag_ClosingDelimiter,
            content: parameters.closingDelimiterExcerpt
          });
        } else {
          _this._name = parameters.name;
          _this._spacingAfterName = parameters.spacingAfterName;
        }
        _this._htmlAttributes = [];
        if (parameters.htmlAttributes) {
          (_a = _this._htmlAttributes).push.apply(_a, parameters.htmlAttributes);
        }
        _this._selfClosingTag = !!parameters.selfClosingTag;
        return _this;
      }
      Object.defineProperty(DocHtmlStartTag2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.HtmlStartTag;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocHtmlStartTag2.prototype, "name", {
        /**
         * The HTML element name.
         */
        get: function() {
          if (this._name === void 0) {
            this._name = this._nameExcerpt.content.toString();
          }
          return this._name;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocHtmlStartTag2.prototype, "htmlAttributes", {
        /**
         * The HTML attributes belonging to this HTML element.
         */
        get: function() {
          return this._htmlAttributes;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocHtmlStartTag2.prototype, "selfClosingTag", {
        /**
         * If true, then the HTML tag ends with `/>` instead of `>`.
         */
        get: function() {
          return this._selfClosingTag;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocHtmlStartTag2.prototype, "spacingAfterName", {
        /**
         * Explicit whitespace that a renderer should insert after the HTML element name.
         * If undefined, then the renderer can use a formatting rule to generate appropriate spacing.
         */
        get: function() {
          if (this._spacingAfterName === void 0) {
            if (this._spacingAfterNameExcerpt !== void 0) {
              this._spacingAfterName = this._spacingAfterNameExcerpt.content.toString();
            }
          }
          return this._spacingAfterName;
        },
        enumerable: false,
        configurable: true
      });
      DocHtmlStartTag2.prototype.emitAsHtml = function() {
        var stringBuilder = new StringBuilder();
        var emitter = new TSDocEmitter();
        emitter.renderHtmlTag(stringBuilder, this);
        return stringBuilder.toString();
      };
      DocHtmlStartTag2.prototype.onGetChildNodes = function() {
        return __spreadArrays4([
          this._openingDelimiterExcerpt,
          this._nameExcerpt,
          this._spacingAfterNameExcerpt
        ], this._htmlAttributes, [
          this._closingDelimiterExcerpt
        ]);
      };
      return DocHtmlStartTag2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocInlineTagBase.js
var __extends18, __spreadArrays5, DocInlineTagBase;
var init_DocInlineTagBase = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocInlineTagBase.js"() {
    "use strict";
    init_DocNode();
    init_StringChecks();
    init_DocExcerpt();
    __extends18 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays5 = function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    DocInlineTagBase = /** @class */
    function(_super) {
      __extends18(DocInlineTagBase2, _super);
      function DocInlineTagBase2(parameters) {
        var _this = _super.call(this, parameters) || this;
        StringChecks.validateTSDocTagName(parameters.tagName);
        if (DocNode.isParsedParameters(parameters)) {
          _this._openingDelimiterExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.InlineTag_OpeningDelimiter,
            content: parameters.openingDelimiterExcerpt
          });
          _this._tagNameExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.InlineTag_TagName,
            content: parameters.tagNameExcerpt
          });
          if (parameters.spacingAfterTagNameExcerpt) {
            _this._spacingAfterTagNameExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterTagNameExcerpt
            });
          }
          _this._closingDelimiterExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.InlineTag_ClosingDelimiter,
            content: parameters.closingDelimiterExcerpt
          });
        }
        _this._tagName = parameters.tagName;
        _this._tagNameWithUpperCase = parameters.tagName.toUpperCase();
        return _this;
      }
      Object.defineProperty(DocInlineTagBase2.prototype, "tagName", {
        /**
         * The TSDoc tag name.  TSDoc tag names start with an at-sign (`@`) followed
         * by ASCII letters using "camelCase" capitalization.
         *
         * @remarks
         * For example, if the inline tag is `{@link Guid.toString | the toString() method}`
         * then the tag name would be `@link`.
         */
        get: function() {
          return this._tagName;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocInlineTagBase2.prototype, "tagNameWithUpperCase", {
        /**
         * The TSDoc tag name in all capitals, which is used for performing
         * case-insensitive comparisons or lookups.
         */
        get: function() {
          return this._tagNameWithUpperCase;
        },
        enumerable: false,
        configurable: true
      });
      DocInlineTagBase2.prototype.onGetChildNodes = function() {
        return __spreadArrays5([
          this._openingDelimiterExcerpt,
          this._tagNameExcerpt,
          this._spacingAfterTagNameExcerpt
        ], this.getChildNodesForContent(), [
          this._closingDelimiterExcerpt
        ]);
      };
      return DocInlineTagBase2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocInheritDocTag.js
var __extends19, DocInheritDocTag;
var init_DocInheritDocTag = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocInheritDocTag.js"() {
    "use strict";
    init_DocNode();
    init_DocInlineTagBase();
    __extends19 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocInheritDocTag = /** @class */
    function(_super) {
      __extends19(DocInheritDocTag2, _super);
      function DocInheritDocTag2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (_this.tagNameWithUpperCase !== "@INHERITDOC") {
          throw new Error('DocInheritDocTag requires the tag name to be "{@inheritDoc}"');
        }
        _this._declarationReference = parameters.declarationReference;
        return _this;
      }
      Object.defineProperty(DocInheritDocTag2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.InheritDocTag;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocInheritDocTag2.prototype, "declarationReference", {
        /**
         * The declaration that the documentation will be inherited from.
         * If omitted, the documentation will be inherited from the parent class.
         */
        get: function() {
          return this._declarationReference;
        },
        enumerable: false,
        configurable: true
      });
      DocInheritDocTag2.prototype.getChildNodesForContent = function() {
        return [this._declarationReference];
      };
      return DocInheritDocTag2;
    }(DocInlineTagBase);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocInlineTag.js
var __extends20, DocInlineTag;
var init_DocInlineTag = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocInlineTag.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    init_DocInlineTagBase();
    __extends20 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocInlineTag = /** @class */
    function(_super) {
      __extends20(DocInlineTag2, _super);
      function DocInlineTag2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          if (parameters.tagContentExcerpt) {
            _this._tagContentExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.InlineTag_TagContent,
              content: parameters.tagContentExcerpt
            });
          }
        } else {
          _this._tagContent = parameters.tagContent;
        }
        return _this;
      }
      Object.defineProperty(DocInlineTag2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.InlineTag;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocInlineTag2.prototype, "tagContent", {
        /**
         * The tag content.
         * @remarks
         * For example, if the tag is `{@myTag x=12.34 y=56.78 }` then the tag content
         * would be `x=12.34 y=56.78 `, including the trailing space but not the leading space.
         */
        get: function() {
          if (this._tagContent === void 0) {
            if (this._tagContentExcerpt) {
              this._tagContent = this._tagContentExcerpt.content.toString();
            } else {
              return "";
            }
          }
          return this._tagContent;
        },
        enumerable: false,
        configurable: true
      });
      DocInlineTag2.prototype.getChildNodesForContent = function() {
        return [this._tagContentExcerpt];
      };
      return DocInlineTag2;
    }(DocInlineTagBase);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocLinkTag.js
var __extends21, DocLinkTag;
var init_DocLinkTag = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocLinkTag.js"() {
    "use strict";
    init_DocNode();
    init_DocInlineTagBase();
    init_DocExcerpt();
    __extends21 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocLinkTag = /** @class */
    function(_super) {
      __extends21(DocLinkTag2, _super);
      function DocLinkTag2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (_this.tagNameWithUpperCase !== "@LINK") {
          throw new Error('DocLinkTag requires the tag name to be "{@link}"');
        }
        _this._codeDestination = parameters.codeDestination;
        if (DocNode.isParsedParameters(parameters)) {
          if (parameters.codeDestination !== void 0 && parameters.urlDestinationExcerpt !== void 0) {
            throw new Error("Either the codeDestination or the urlDestination may be specified, but not both");
          }
          if (parameters.urlDestinationExcerpt) {
            _this._urlDestinationExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.LinkTag_UrlDestination,
              content: parameters.urlDestinationExcerpt
            });
          }
          if (parameters.spacingAfterDestinationExcerpt) {
            _this._spacingAfterDestinationExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterDestinationExcerpt
            });
          }
          if (parameters.pipeExcerpt) {
            _this._pipeExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.LinkTag_Pipe,
              content: parameters.pipeExcerpt
            });
          }
          if (parameters.spacingAfterPipeExcerpt) {
            _this._spacingAfterPipeExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterPipeExcerpt
            });
          }
          if (parameters.linkTextExcerpt) {
            _this._linkTextExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.LinkTag_LinkText,
              content: parameters.linkTextExcerpt
            });
          }
          if (parameters.spacingAfterLinkTextExcerpt) {
            _this._spacingAfterLinkTextExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterLinkTextExcerpt
            });
          }
        } else {
          if (parameters.codeDestination !== void 0 && parameters.urlDestination !== void 0) {
            throw new Error("Either the codeDestination or the urlDestination may be specified, but not both");
          }
          _this._urlDestination = parameters.urlDestination;
          _this._linkText = parameters.linkText;
        }
        return _this;
      }
      Object.defineProperty(DocLinkTag2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.LinkTag;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocLinkTag2.prototype, "codeDestination", {
        /**
         * If the link tag refers to a declaration, this returns the declaration reference object;
         * otherwise this property is undefined.
         * @remarks
         * Either the `codeDestination` or the `urlDestination` property will be defined, but never both.
         */
        get: function() {
          return this._codeDestination;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocLinkTag2.prototype, "urlDestination", {
        /**
         * If the link tag was an ordinary URI, this returns the URL string;
         * otherwise this property is undefined.
         * @remarks
         * Either the `codeDestination` or the `urlDestination` property will be defined, but never both.
         */
        get: function() {
          if (this._urlDestination === void 0) {
            if (this._urlDestinationExcerpt !== void 0) {
              this._urlDestination = this._urlDestinationExcerpt.content.toString();
            }
          }
          return this._urlDestination;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocLinkTag2.prototype, "linkText", {
        /**
         * An optional text string that is the hyperlink text.  If omitted, the documentation
         * renderer will use a default string based on the link itself (e.g. the URL text
         * or the declaration identifier).
         *
         * @remarks
         *
         * In HTML, the hyperlink can include leading/trailing space characters around the link text.
         * For example, this HTML will cause a web browser to `y` and also the space character before
         * and after it:
         *
         * ```html
         * x<a href="#Button"> y </a> z
         * ```
         *
         * Unlike HTML, TSDoc trims leading/trailing spaces.  For example, this TSDoc will be
         * displayed `xy z` and underline only the `y` character:
         *
         * ```
         * x{@link Button | y } z
         * ```
         */
        get: function() {
          if (this._linkText === void 0) {
            if (this._linkTextExcerpt !== void 0) {
              this._linkText = this._linkTextExcerpt.content.toString();
            }
          }
          return this._linkText;
        },
        enumerable: false,
        configurable: true
      });
      DocLinkTag2.prototype.getChildNodesForContent = function() {
        return [
          this._codeDestination,
          this._urlDestinationExcerpt,
          this._spacingAfterDestinationExcerpt,
          this._pipeExcerpt,
          this._spacingAfterPipeExcerpt,
          this._linkTextExcerpt,
          this._spacingAfterLinkTextExcerpt
        ];
      };
      return DocLinkTag2;
    }(DocInlineTagBase);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocMemberIdentifier.js
var __extends22, DocMemberIdentifier;
var init_DocMemberIdentifier = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocMemberIdentifier.js"() {
    "use strict";
    init_DocNode();
    init_StringChecks();
    init_DocExcerpt();
    __extends22 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocMemberIdentifier = /** @class */
    function(_super) {
      __extends22(DocMemberIdentifier2, _super);
      function DocMemberIdentifier2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          if (parameters.leftQuoteExcerpt) {
            _this._leftQuoteExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.MemberIdentifier_LeftQuote,
              content: parameters.leftQuoteExcerpt
            });
          }
          _this._identifierExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.MemberIdentifier_Identifier,
            content: parameters.identifierExcerpt
          });
          if (parameters.rightQuoteExcerpt) {
            _this._rightQuoteExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.MemberIdentifier_RightQuote,
              content: parameters.rightQuoteExcerpt
            });
          }
        } else {
          _this._identifier = parameters.identifier;
        }
        return _this;
      }
      DocMemberIdentifier2.isValidIdentifier = function(identifier) {
        return !StringChecks.explainIfInvalidUnquotedMemberIdentifier(identifier);
      };
      Object.defineProperty(DocMemberIdentifier2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.MemberIdentifier;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocMemberIdentifier2.prototype, "identifier", {
        /**
         * The identifier string without any quote encoding.
         *
         * @remarks
         * If the value is not a valid ECMAScript identifier, it will be quoted as a
         * string literal during rendering.
         */
        get: function() {
          if (this._identifier === void 0) {
            this._identifier = this._identifierExcerpt.content.toString();
          }
          return this._identifier;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocMemberIdentifier2.prototype, "hasQuotes", {
        /**
         * Returns true if the identifier will be rendered as a quoted string literal
         * instead of as a programming language identifier.  This is required if the
         * `identifier` property is not a valid ECMAScript identifier.
         */
        get: function() {
          if (this._identifierExcerpt) {
            return !!this._leftQuoteExcerpt;
          } else {
            return !DocMemberIdentifier2.isValidIdentifier(this.identifier);
          }
        },
        enumerable: false,
        configurable: true
      });
      DocMemberIdentifier2.prototype.onGetChildNodes = function() {
        return [this._leftQuoteExcerpt, this._identifierExcerpt, this._rightQuoteExcerpt];
      };
      return DocMemberIdentifier2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocMemberReference.js
var __extends23, DocMemberReference;
var init_DocMemberReference = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocMemberReference.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    __extends23 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocMemberReference = /** @class */
    function(_super) {
      __extends23(DocMemberReference2, _super);
      function DocMemberReference2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          _this._hasDot = !!parameters.dotExcerpt;
          if (parameters.dotExcerpt) {
            _this._dotExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.MemberReference_Dot,
              content: parameters.dotExcerpt
            });
          }
          if (parameters.spacingAfterDotExcerpt) {
            _this._spacingAfterDotExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterDotExcerpt
            });
          }
          if (parameters.leftParenthesisExcerpt) {
            _this._leftParenthesisExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.MemberReference_LeftParenthesis,
              content: parameters.leftParenthesisExcerpt
            });
          }
          if (parameters.spacingAfterLeftParenthesisExcerpt) {
            _this._spacingAfterLeftParenthesisExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterLeftParenthesisExcerpt
            });
          }
          if (parameters.spacingAfterMemberExcerpt) {
            _this._spacingAfterMemberExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterMemberExcerpt
            });
          }
          if (parameters.colonExcerpt) {
            _this._colonExcerpt = new DocExcerpt({
              excerptKind: ExcerptKind.MemberReference_Colon,
              configuration: _this.configuration,
              content: parameters.colonExcerpt
            });
          }
          if (parameters.spacingAfterColonExcerpt) {
            _this._spacingAfterColonExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterColonExcerpt
            });
          }
          if (parameters.spacingAfterSelectorExcerpt) {
            _this._spacingAfterSelectorExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterSelectorExcerpt
            });
          }
          if (parameters.rightParenthesisExcerpt) {
            _this._rightParenthesisExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.MemberReference_RightParenthesis,
              content: parameters.rightParenthesisExcerpt
            });
          }
          if (parameters.spacingAfterRightParenthesisExcerpt) {
            _this._spacingAfterRightParenthesisExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterRightParenthesisExcerpt
            });
          }
        } else {
          _this._hasDot = parameters.hasDot;
        }
        _this._memberIdentifier = parameters.memberIdentifier;
        _this._memberSymbol = parameters.memberSymbol;
        _this._selector = parameters.selector;
        return _this;
      }
      Object.defineProperty(DocMemberReference2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.MemberReference;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocMemberReference2.prototype, "hasDot", {
        /**
         * True if this member reference is preceded by a dot (".") token.
         * It should be false only for the first member in the chain.
         */
        get: function() {
          return this._hasDot;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocMemberReference2.prototype, "memberIdentifier", {
        /**
         * The identifier for the referenced member.
         * @remarks
         * Either `memberIdentifier` or `memberSymbol` may be specified, but not both.
         */
        get: function() {
          return this._memberIdentifier;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocMemberReference2.prototype, "memberSymbol", {
        /**
         * The ECMAScript 6 symbol expression, which may be used instead of an identifier
         * to indicate the referenced member.
         * @remarks
         * Either `memberIdentifier` or `memberSymbol` may be specified, but not both.
         */
        get: function() {
          return this._memberSymbol;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocMemberReference2.prototype, "selector", {
        /**
         * A TSDoc selector, which may be optionally when the identifier or symbol is insufficient
         * to unambiguously determine the referenced declaration.
         */
        get: function() {
          return this._selector;
        },
        enumerable: false,
        configurable: true
      });
      DocMemberReference2.prototype.onGetChildNodes = function() {
        return [
          this._dotExcerpt,
          this._spacingAfterDotExcerpt,
          this._leftParenthesisExcerpt,
          this._spacingAfterLeftParenthesisExcerpt,
          this._memberIdentifier,
          this._memberSymbol,
          this._spacingAfterMemberExcerpt,
          this._colonExcerpt,
          this._spacingAfterColonExcerpt,
          this._selector,
          this._spacingAfterSelectorExcerpt,
          this._rightParenthesisExcerpt,
          this._spacingAfterRightParenthesisExcerpt
        ];
      };
      return DocMemberReference2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocMemberSelector.js
var __extends24, SelectorKind, DocMemberSelector;
var init_DocMemberSelector = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocMemberSelector.js"() {
    "use strict";
    init_DocNode();
    init_StringChecks();
    init_DocExcerpt();
    __extends24 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(SelectorKind2) {
      SelectorKind2["Error"] = "error";
      SelectorKind2["System"] = "system";
      SelectorKind2["Index"] = "index";
      SelectorKind2["Label"] = "label";
    })(SelectorKind || (SelectorKind = {}));
    DocMemberSelector = /** @class */
    function(_super) {
      __extends24(DocMemberSelector2, _super);
      function DocMemberSelector2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          _this._selectorExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.MemberSelector,
            content: parameters.selectorExcerpt
          });
          _this._selector = parameters.selectorExcerpt.toString();
        } else {
          _this._selector = parameters.selector;
        }
        _this._selectorKind = SelectorKind.Error;
        _this._errorMessage = void 0;
        if (_this._selector.length === 0) {
          _this._errorMessage = "The selector cannot be an empty string";
        } else if (DocMemberSelector2._likeIndexSelectorRegExp.test(_this._selector)) {
          if (DocMemberSelector2._indexSelectorRegExp.test(_this._selector)) {
            _this._selectorKind = SelectorKind.Index;
          } else {
            _this._errorMessage = "If the selector begins with a number, it must be a positive integer value";
          }
        } else if (DocMemberSelector2._likeLabelSelectorRegExp.test(_this._selector)) {
          if (DocMemberSelector2._labelSelectorRegExp.test(_this._selector)) {
            _this._selectorKind = SelectorKind.Label;
          } else {
            _this._errorMessage = "A label selector must be comprised of upper case letters, numbers, and underscores and must not start with a number";
          }
        } else {
          if (StringChecks.isSystemSelector(_this._selector)) {
            _this._selectorKind = SelectorKind.System;
          } else if (DocMemberSelector2._likeSystemSelectorRegExp.test(_this._selector)) {
            _this._errorMessage = "The selector " + JSON.stringify(_this._selector) + " is not a recognized TSDoc system selector name";
          } else {
            _this._errorMessage = "Invalid syntax for selector";
          }
        }
        return _this;
      }
      Object.defineProperty(DocMemberSelector2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.MemberSelector;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocMemberSelector2.prototype, "selector", {
        /**
         * The text representation of the selector.
         *
         * @remarks
         * For system selectors, it will be a predefined lower case name.
         * For label selectors, it will be an upper case name defined using the `{@label}` tag.
         * For index selectors, it will be a positive integer.
         */
        get: function() {
          return this._selector;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocMemberSelector2.prototype, "selectorKind", {
        /**
         * Indicates the kind of selector.
         */
        get: function() {
          return this._selectorKind;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocMemberSelector2.prototype, "errorMessage", {
        /**
         * If the `selectorKind` is `SelectorKind.Error`, this string will be defined and provide
         * more detail about why the string was not valid.
         */
        get: function() {
          return this._errorMessage;
        },
        enumerable: false,
        configurable: true
      });
      DocMemberSelector2.prototype.onGetChildNodes = function() {
        return [this._selectorExcerpt];
      };
      DocMemberSelector2._likeIndexSelectorRegExp = /^[0-9]/;
      DocMemberSelector2._indexSelectorRegExp = /^[1-9][0-9]*$/;
      DocMemberSelector2._likeLabelSelectorRegExp = /^[A-Z_]/u;
      DocMemberSelector2._labelSelectorRegExp = /^[A-Z_][A-Z0-9_]+$/;
      DocMemberSelector2._likeSystemSelectorRegExp = /^[a-z]+$/u;
      return DocMemberSelector2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocMemberSymbol.js
var __extends25, DocMemberSymbol;
var init_DocMemberSymbol = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocMemberSymbol.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    __extends25 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocMemberSymbol = /** @class */
    function(_super) {
      __extends25(DocMemberSymbol2, _super);
      function DocMemberSymbol2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          _this._leftBracketExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.DocMemberSymbol_LeftBracket,
            content: parameters.leftBracketExcerpt
          });
          if (parameters.spacingAfterLeftBracketExcerpt) {
            _this._spacingAfterLeftBracketExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterLeftBracketExcerpt
            });
          }
          _this._rightBracketExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.DocMemberSymbol_RightBracket,
            content: parameters.rightBracketExcerpt
          });
        }
        _this._symbolReference = parameters.symbolReference;
        return _this;
      }
      Object.defineProperty(DocMemberSymbol2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.MemberSymbol;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocMemberSymbol2.prototype, "symbolReference", {
        /**
         * The declaration reference for the ECMAScript 6 symbol that will act as
         * the identifier for the member.
         */
        get: function() {
          return this._symbolReference;
        },
        enumerable: false,
        configurable: true
      });
      DocMemberSymbol2.prototype.onGetChildNodes = function() {
        return [
          this._leftBracketExcerpt,
          this._spacingAfterLeftBracketExcerpt,
          this._symbolReference,
          this._rightBracketExcerpt
        ];
      };
      return DocMemberSymbol2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocParamBlock.js
var __extends26, DocParamBlock;
var init_DocParamBlock = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocParamBlock.js"() {
    "use strict";
    init_DocNode();
    init_DocBlock();
    init_DocExcerpt();
    __extends26 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocParamBlock = /** @class */
    function(_super) {
      __extends26(DocParamBlock2, _super);
      function DocParamBlock2(parameters) {
        var _this = _super.call(this, parameters) || this;
        _this._parameterName = parameters.parameterName;
        if (DocNode.isParsedParameters(parameters)) {
          if (parameters.spacingBeforeParameterNameExcerpt) {
            _this._spacingBeforeParameterNameExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingBeforeParameterNameExcerpt
            });
          }
          if (parameters.unsupportedJsdocTypeBeforeParameterNameExcerpt) {
            _this._unsupportedJsdocTypeBeforeParameterNameExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.NonstandardText,
              content: parameters.unsupportedJsdocTypeBeforeParameterNameExcerpt
            });
          }
          if (parameters.unsupportedJsdocOptionalNameOpenBracketExcerpt) {
            _this._unsupportedJsdocOptionalNameOpenBracketExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.NonstandardText,
              content: parameters.unsupportedJsdocOptionalNameOpenBracketExcerpt
            });
          }
          _this._parameterNameExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.ParamBlock_ParameterName,
            content: parameters.parameterNameExcerpt
          });
          if (parameters.unsupportedJsdocOptionalNameRestExcerpt) {
            _this._unsupportedJsdocOptionalNameRestExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.NonstandardText,
              content: parameters.unsupportedJsdocOptionalNameRestExcerpt
            });
          }
          if (parameters.spacingAfterParameterNameExcerpt) {
            _this._spacingAfterParameterNameExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterParameterNameExcerpt
            });
          }
          if (parameters.unsupportedJsdocTypeAfterParameterNameExcerpt) {
            _this._unsupportedJsdocTypeAfterParameterNameExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.NonstandardText,
              content: parameters.unsupportedJsdocTypeAfterParameterNameExcerpt
            });
          }
          if (parameters.hyphenExcerpt) {
            _this._hyphenExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.ParamBlock_Hyphen,
              content: parameters.hyphenExcerpt
            });
          }
          if (parameters.spacingAfterHyphenExcerpt) {
            _this._spacingAfterHyphenExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.Spacing,
              content: parameters.spacingAfterHyphenExcerpt
            });
          }
          if (parameters.unsupportedJsdocTypeAfterHyphenExcerpt) {
            _this._unsupportedJsdocTypeAfterHyphenExcerpt = new DocExcerpt({
              configuration: _this.configuration,
              excerptKind: ExcerptKind.NonstandardText,
              content: parameters.unsupportedJsdocTypeAfterHyphenExcerpt
            });
          }
        }
        return _this;
      }
      Object.defineProperty(DocParamBlock2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.ParamBlock;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocParamBlock2.prototype, "parameterName", {
        /**
         * The name of the parameter that is being documented.
         * For example "width" in `@param width - the width of the object`.
         */
        get: function() {
          return this._parameterName;
        },
        enumerable: false,
        configurable: true
      });
      DocParamBlock2.prototype.onGetChildNodes = function() {
        return [
          this.blockTag,
          this._spacingBeforeParameterNameExcerpt,
          this._unsupportedJsdocTypeBeforeParameterNameExcerpt,
          this._unsupportedJsdocOptionalNameOpenBracketExcerpt,
          this._parameterNameExcerpt,
          this._unsupportedJsdocOptionalNameRestExcerpt,
          this._spacingAfterParameterNameExcerpt,
          this._unsupportedJsdocTypeAfterParameterNameExcerpt,
          this._hyphenExcerpt,
          this._spacingAfterHyphenExcerpt,
          this._unsupportedJsdocTypeAfterHyphenExcerpt,
          this.content
        ];
      };
      return DocParamBlock2;
    }(DocBlock);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocPlainText.js
var __extends27, DocPlainText;
var init_DocPlainText = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocPlainText.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    __extends27 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocPlainText = /** @class */
    function(_super) {
      __extends27(DocPlainText2, _super);
      function DocPlainText2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          _this._textExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.PlainText,
            content: parameters.textExcerpt
          });
        } else {
          if (DocPlainText2._newlineCharacterRegExp.test(parameters.text)) {
            throw new Error("The DocPlainText content must not contain newline characters");
          }
          _this._text = parameters.text;
        }
        return _this;
      }
      Object.defineProperty(DocPlainText2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.PlainText;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocPlainText2.prototype, "text", {
        /**
         * The text content.
         */
        get: function() {
          if (this._text === void 0) {
            this._text = this._textExcerpt.content.toString();
          }
          return this._text;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocPlainText2.prototype, "textExcerpt", {
        get: function() {
          if (this._textExcerpt) {
            return this._textExcerpt.content;
          } else {
            return void 0;
          }
        },
        enumerable: false,
        configurable: true
      });
      DocPlainText2.prototype.onGetChildNodes = function() {
        return [this._textExcerpt];
      };
      DocPlainText2._newlineCharacterRegExp = /[\n]/;
      return DocPlainText2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocSoftBreak.js
var __extends28, DocSoftBreak;
var init_DocSoftBreak = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/DocSoftBreak.js"() {
    "use strict";
    init_DocNode();
    init_DocExcerpt();
    __extends28 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DocSoftBreak = /** @class */
    function(_super) {
      __extends28(DocSoftBreak2, _super);
      function DocSoftBreak2(parameters) {
        var _this = _super.call(this, parameters) || this;
        if (DocNode.isParsedParameters(parameters)) {
          _this._softBreakExcerpt = new DocExcerpt({
            configuration: _this.configuration,
            excerptKind: ExcerptKind.SoftBreak,
            content: parameters.softBreakExcerpt
          });
        }
        return _this;
      }
      Object.defineProperty(DocSoftBreak2.prototype, "kind", {
        /** @override */
        get: function() {
          return DocNodeKind.SoftBreak;
        },
        enumerable: false,
        configurable: true
      });
      DocSoftBreak2.prototype.onGetChildNodes = function() {
        return [this._softBreakExcerpt];
      };
      return DocSoftBreak2;
    }(DocNode);
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/index.js
var init_nodes = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/nodes/index.js"() {
    "use strict";
    init_DocBlock();
    init_DocBlockTag();
    init_DocCodeSpan();
    init_DocComment();
    init_DocDeclarationReference();
    init_DocErrorText();
    init_DocEscapedText();
    init_DocExcerpt();
    init_DocFencedCode();
    init_DocHtmlAttribute();
    init_DocHtmlEndTag();
    init_DocHtmlStartTag();
    init_DocInheritDocTag();
    init_DocInlineTag();
    init_DocInlineTagBase();
    init_DocLinkTag();
    init_DocMemberIdentifier();
    init_DocMemberReference();
    init_DocMemberSelector();
    init_DocMemberSymbol();
    init_DocNode();
    init_DocNodeContainer();
    init_DocParagraph();
    init_DocParamBlock();
    init_DocParamCollection();
    init_DocPlainText();
    init_DocSection();
    init_DocSoftBreak();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/emitters/PlainTextEmitter.js
var PlainTextEmitter;
var init_PlainTextEmitter = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/emitters/PlainTextEmitter.js"() {
    "use strict";
    init_nodes();
    PlainTextEmitter = /** @class */
    function() {
      function PlainTextEmitter2() {
      }
      PlainTextEmitter2.hasAnyTextContent = function(nodeOrNodes, requiredCharacters) {
        if (requiredCharacters === void 0 || requiredCharacters < 1) {
          requiredCharacters = 1;
        }
        var nodes;
        if (nodeOrNodes instanceof DocNode) {
          nodes = [nodeOrNodes];
        } else {
          nodes = nodeOrNodes;
        }
        var foundCharacters = PlainTextEmitter2._scanTextContent(nodes, requiredCharacters, 0);
        return foundCharacters >= requiredCharacters;
      };
      PlainTextEmitter2._scanTextContent = function(nodes, requiredCharacters, foundCharacters) {
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
          var node = nodes_1[_i];
          switch (node.kind) {
            case DocNodeKind.FencedCode:
              var docFencedCode = node;
              foundCharacters += PlainTextEmitter2._countNonSpaceCharacters(docFencedCode.code);
              break;
            case DocNodeKind.CodeSpan:
              var docCodeSpan = node;
              foundCharacters += PlainTextEmitter2._countNonSpaceCharacters(docCodeSpan.code);
              break;
            case DocNodeKind.EscapedText:
              var docEscapedText = node;
              foundCharacters += PlainTextEmitter2._countNonSpaceCharacters(docEscapedText.decodedText);
              break;
            case DocNodeKind.LinkTag:
              var docLinkTag = node;
              foundCharacters += PlainTextEmitter2._countNonSpaceCharacters(docLinkTag.linkText || "");
              break;
            case DocNodeKind.PlainText:
              var docPlainText = node;
              foundCharacters += PlainTextEmitter2._countNonSpaceCharacters(docPlainText.text);
              break;
          }
          if (foundCharacters >= requiredCharacters) {
            break;
          }
          foundCharacters += PlainTextEmitter2._scanTextContent(node.getChildNodes(), requiredCharacters, foundCharacters);
          if (foundCharacters >= requiredCharacters) {
            break;
          }
        }
        return foundCharacters;
      };
      PlainTextEmitter2._countNonSpaceCharacters = function(s) {
        var count = 0;
        var length = s.length;
        var i = 0;
        while (i < length) {
          switch (s.charCodeAt(i)) {
            case 32:
            case 9:
            case 13:
            case 10:
              break;
            default:
              ++count;
          }
          ++i;
        }
        return count;
      };
      return PlainTextEmitter2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/TextRange.js
var TextRange;
var init_TextRange = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/TextRange.js"() {
    "use strict";
    TextRange = /** @class */
    function() {
      function TextRange2(buffer, pos, end) {
        this.buffer = buffer;
        this.pos = pos;
        this.end = end;
        this._validateBounds();
      }
      TextRange2.fromString = function(buffer) {
        return new TextRange2(buffer, 0, buffer.length);
      };
      TextRange2.fromStringRange = function(buffer, pos, end) {
        return new TextRange2(buffer, pos, end);
      };
      Object.defineProperty(TextRange2.prototype, "length", {
        /**
         * Returns the length of the text range.
         * @remarks
         * This value is calculated as the `end` property minus the `pos` property.
         */
        get: function() {
          return this.end - this.pos;
        },
        enumerable: false,
        configurable: true
      });
      TextRange2.prototype.getNewRange = function(pos, end) {
        return new TextRange2(this.buffer, pos, end);
      };
      TextRange2.prototype.isEmpty = function() {
        return this.pos === this.end;
      };
      TextRange2.prototype.toString = function() {
        return this.buffer.substring(this.pos, this.end);
      };
      TextRange2.prototype.getDebugDump = function(posDelimiter, endDelimiter) {
        return this.buffer.substring(0, this.pos) + posDelimiter + this.buffer.substring(this.pos, this.end) + endDelimiter + this.buffer.substring(this.end);
      };
      TextRange2.prototype.getLocation = function(index) {
        if (index < 0 || index > this.buffer.length) {
          return { line: 0, column: 0 };
        }
        var line = 1;
        var column = 1;
        var currentIndex = 0;
        while (currentIndex < index) {
          var current = this.buffer[currentIndex];
          ++currentIndex;
          if (current === "\r") {
            continue;
          }
          if (current === "\n") {
            ++line;
            column = 1;
          } else {
            ++column;
          }
        }
        return { line, column };
      };
      TextRange2.prototype._validateBounds = function() {
        if (this.pos < 0) {
          throw new Error("TextRange.pos cannot be negative");
        }
        if (this.end < 0) {
          throw new Error("TextRange.end cannot be negative");
        }
        if (this.end < this.pos) {
          throw new Error("TextRange.end cannot be smaller than TextRange.pos");
        }
        if (this.pos > this.buffer.length) {
          throw new Error("TextRange.pos cannot exceed the associated text buffer length");
        }
        if (this.end > this.buffer.length) {
          throw new Error("TextRange.end cannot exceed the associated text buffer length");
        }
      };
      TextRange2.empty = new TextRange2("", 0, 0);
      return TextRange2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/ParserMessage.js
var ParserMessage;
var init_ParserMessage = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/ParserMessage.js"() {
    "use strict";
    ParserMessage = /** @class */
    function() {
      function ParserMessage2(parameters) {
        this.messageId = parameters.messageId;
        this.unformattedText = parameters.messageText;
        this.textRange = parameters.textRange;
        this.tokenSequence = parameters.tokenSequence;
        this.docNode = parameters.docNode;
        this._text = void 0;
      }
      ParserMessage2._formatMessageText = function(message, range) {
        if (!message) {
          message = "An unknown error occurred";
        }
        if (range.pos !== 0 || range.end !== 0) {
          var location_1 = range.getLocation(range.pos);
          if (location_1.line) {
            return "(" + location_1.line + "," + location_1.column + "): " + message;
          }
        }
        return message;
      };
      Object.defineProperty(ParserMessage2.prototype, "text", {
        /**
         * The message text.
         */
        get: function() {
          if (this._text === void 0) {
            this._text = ParserMessage2._formatMessageText(this.unformattedText, this.textRange);
          }
          return this._text;
        },
        enumerable: false,
        configurable: true
      });
      ParserMessage2.prototype.toString = function() {
        return this.text;
      };
      return ParserMessage2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/ParserMessageLog.js
var ParserMessageLog;
var init_ParserMessageLog = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/ParserMessageLog.js"() {
    "use strict";
    init_ParserMessage();
    ParserMessageLog = /** @class */
    function() {
      function ParserMessageLog2() {
        this._messages = [];
      }
      Object.defineProperty(ParserMessageLog2.prototype, "messages", {
        /**
         * The unfiltered list of all messages.
         */
        get: function() {
          return this._messages;
        },
        enumerable: false,
        configurable: true
      });
      ParserMessageLog2.prototype.addMessage = function(parserMessage) {
        this._messages.push(parserMessage);
      };
      ParserMessageLog2.prototype.addMessageForTextRange = function(messageId, messageText, textRange) {
        this.addMessage(new ParserMessage({
          messageId,
          messageText,
          textRange
        }));
      };
      ParserMessageLog2.prototype.addMessageForTokenSequence = function(messageId, messageText, tokenSequence, docNode) {
        this.addMessage(new ParserMessage({
          messageId,
          messageText,
          textRange: tokenSequence.getContainingTextRange(),
          tokenSequence,
          docNode
        }));
      };
      ParserMessageLog2.prototype.addMessageForDocErrorText = function(docErrorText) {
        var tokenSequence;
        if (docErrorText.textExcerpt) {
          tokenSequence = docErrorText.textExcerpt;
        } else {
          tokenSequence = docErrorText.errorLocation;
        }
        this.addMessage(new ParserMessage({
          messageId: docErrorText.messageId,
          messageText: docErrorText.errorMessage,
          textRange: tokenSequence.getContainingTextRange(),
          tokenSequence,
          docNode: docErrorText
        }));
      };
      return ParserMessageLog2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/ParserContext.js
var ParserContext;
var init_ParserContext = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/ParserContext.js"() {
    "use strict";
    init_TextRange();
    init_nodes();
    init_ParserMessageLog();
    ParserContext = /** @class */
    /* @__PURE__ */ function() {
      function ParserContext2(configuration, sourceRange) {
        this.commentRange = TextRange.empty;
        this.lines = [];
        this.tokens = [];
        this.configuration = configuration;
        this.sourceRange = sourceRange;
        this.docComment = new DocComment({ configuration: this.configuration });
        this.log = new ParserMessageLog();
      }
      return ParserContext2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/TokenSequence.js
var TokenSequence;
var init_TokenSequence = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/TokenSequence.js"() {
    "use strict";
    init_TextRange();
    TokenSequence = /** @class */
    function() {
      function TokenSequence2(parameters) {
        this.parserContext = parameters.parserContext;
        this._startIndex = parameters.startIndex;
        this._endIndex = parameters.endIndex;
        this._validateBounds();
      }
      TokenSequence2.createEmpty = function(parserContext) {
        return new TokenSequence2({ parserContext, startIndex: 0, endIndex: 0 });
      };
      Object.defineProperty(TokenSequence2.prototype, "startIndex", {
        /**
         * The starting index into the associated `ParserContext.tokens` list.
         */
        get: function() {
          return this._startIndex;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TokenSequence2.prototype, "endIndex", {
        /**
         * The (non-inclusive) ending index into the associated `ParserContext.tokens` list.
         */
        get: function() {
          return this._endIndex;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TokenSequence2.prototype, "tokens", {
        get: function() {
          return this.parserContext.tokens.slice(this._startIndex, this._endIndex);
        },
        enumerable: false,
        configurable: true
      });
      TokenSequence2.prototype.getNewSequence = function(startIndex, endIndex) {
        return new TokenSequence2({
          parserContext: this.parserContext,
          startIndex,
          endIndex
        });
      };
      TokenSequence2.prototype.getContainingTextRange = function() {
        if (this.isEmpty()) {
          return TextRange.empty;
        }
        return this.parserContext.sourceRange.getNewRange(this.parserContext.tokens[this._startIndex].range.pos, this.parserContext.tokens[this._endIndex - 1].range.end);
      };
      TokenSequence2.prototype.isEmpty = function() {
        return this._startIndex === this._endIndex;
      };
      TokenSequence2.prototype.toString = function() {
        return this.tokens.map(function(x) {
          return x.toString();
        }).join("");
      };
      TokenSequence2.prototype._validateBounds = function() {
        if (this.startIndex < 0) {
          throw new Error("TokenSequence.startIndex cannot be negative");
        }
        if (this.endIndex < 0) {
          throw new Error("TokenSequence.endIndex cannot be negative");
        }
        if (this.endIndex < this.startIndex) {
          throw new Error("TokenSequence.endIndex cannot be smaller than TokenSequence.startIndex");
        }
        if (this.startIndex > this.parserContext.tokens.length) {
          throw new Error("TokenSequence.startIndex cannot exceed the associated token array");
        }
        if (this.endIndex > this.parserContext.tokens.length) {
          throw new Error("TokenSequence.endIndex cannot exceed the associated token array");
        }
      };
      return TokenSequence2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/LineExtractor.js
var State, LineExtractor;
var init_LineExtractor = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/LineExtractor.js"() {
    "use strict";
    init_TSDocMessageId();
    (function(State2) {
      State2[State2["BeginComment1"] = 0] = "BeginComment1";
      State2[State2["BeginComment2"] = 1] = "BeginComment2";
      State2[State2["CollectingFirstLine"] = 2] = "CollectingFirstLine";
      State2[State2["CollectingLine"] = 3] = "CollectingLine";
      State2[State2["AdvancingLine"] = 4] = "AdvancingLine";
      State2[State2["Done"] = 5] = "Done";
    })(State || (State = {}));
    LineExtractor = /** @class */
    function() {
      function LineExtractor2() {
      }
      LineExtractor2.extract = function(parserContext) {
        var range = parserContext.sourceRange;
        var buffer = range.buffer;
        var commentRangeStart = 0;
        var commentRangeEnd = 0;
        var collectingLineStart = 0;
        var collectingLineEnd = 0;
        var nextIndex = range.pos;
        var state = State.BeginComment1;
        var lines = [];
        while (state !== State.Done) {
          if (nextIndex >= range.end) {
            switch (state) {
              case State.BeginComment1:
              case State.BeginComment2:
                parserContext.log.addMessageForTextRange(TSDocMessageId.CommentNotFound, 'Expecting a "/**" comment', range);
                return false;
              default:
                parserContext.log.addMessageForTextRange(TSDocMessageId.CommentMissingClosingDelimiter, "Unexpected end of input", range);
                return false;
            }
          }
          var current = buffer[nextIndex];
          var currentIndex = nextIndex;
          ++nextIndex;
          var next = nextIndex < range.end ? buffer[nextIndex] : "";
          switch (state) {
            case State.BeginComment1:
              if (current === "/" && next === "*") {
                commentRangeStart = currentIndex;
                ++nextIndex;
                state = State.BeginComment2;
              } else if (!LineExtractor2._whitespaceCharacterRegExp.test(current)) {
                parserContext.log.addMessageForTextRange(TSDocMessageId.CommentOpeningDelimiterSyntax, 'Expecting a leading "/**"', range.getNewRange(currentIndex, currentIndex + 1));
                return false;
              }
              break;
            case State.BeginComment2:
              if (current === "*") {
                if (next === " ") {
                  ++nextIndex;
                }
                collectingLineStart = nextIndex;
                collectingLineEnd = nextIndex;
                state = State.CollectingFirstLine;
              } else {
                parserContext.log.addMessageForTextRange(TSDocMessageId.CommentOpeningDelimiterSyntax, 'Expecting a leading "/**"', range.getNewRange(currentIndex, currentIndex + 1));
                return false;
              }
              break;
            case State.CollectingFirstLine:
            case State.CollectingLine:
              if (current === "\n") {
                if (state !== State.CollectingFirstLine || collectingLineEnd > collectingLineStart) {
                  lines.push(range.getNewRange(collectingLineStart, collectingLineEnd));
                }
                collectingLineStart = nextIndex;
                collectingLineEnd = nextIndex;
                state = State.AdvancingLine;
              } else if (current === "*" && next === "/") {
                if (collectingLineEnd > collectingLineStart) {
                  lines.push(range.getNewRange(collectingLineStart, collectingLineEnd));
                }
                collectingLineStart = 0;
                collectingLineEnd = 0;
                ++nextIndex;
                commentRangeEnd = nextIndex;
                state = State.Done;
              } else if (!LineExtractor2._whitespaceCharacterRegExp.test(current)) {
                collectingLineEnd = nextIndex;
              }
              break;
            case State.AdvancingLine:
              if (current === "*") {
                if (next === "/") {
                  collectingLineStart = 0;
                  collectingLineEnd = 0;
                  ++nextIndex;
                  commentRangeEnd = nextIndex;
                  state = State.Done;
                } else {
                  if (next === " ") {
                    ++nextIndex;
                  }
                  collectingLineStart = nextIndex;
                  collectingLineEnd = nextIndex;
                  state = State.CollectingLine;
                }
              } else if (current === "\n") {
                lines.push(range.getNewRange(currentIndex, currentIndex));
                collectingLineStart = nextIndex;
              } else if (!LineExtractor2._whitespaceCharacterRegExp.test(current)) {
                collectingLineEnd = nextIndex;
                state = State.CollectingLine;
              }
              break;
          }
        }
        parserContext.commentRange = range.getNewRange(commentRangeStart, commentRangeEnd);
        parserContext.lines = lines;
        return true;
      };
      LineExtractor2._whitespaceCharacterRegExp = /^\s$/;
      return LineExtractor2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/Tokenizer.js
var Tokenizer;
var init_Tokenizer = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/Tokenizer.js"() {
    "use strict";
    init_TextRange();
    init_Token();
    Tokenizer = /** @class */
    function() {
      function Tokenizer2() {
      }
      Tokenizer2.readTokens = function(lines) {
        Tokenizer2._ensureInitialized();
        var tokens = [];
        var lastLine = void 0;
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
          var line = lines_1[_i];
          Tokenizer2._pushTokensForLine(tokens, line);
          lastLine = line;
        }
        if (lastLine) {
          tokens.push(new Token(TokenKind.EndOfInput, lastLine.getNewRange(lastLine.end, lastLine.end), lastLine));
        } else {
          tokens.push(new Token(TokenKind.EndOfInput, TextRange.empty, TextRange.empty));
        }
        return tokens;
      };
      Tokenizer2.isPunctuation = function(tokenKind) {
        Tokenizer2._ensureInitialized();
        return Tokenizer2._punctuationTokens[tokenKind] || false;
      };
      Tokenizer2._pushTokensForLine = function(tokens, line) {
        var buffer = line.buffer;
        var end = line.end;
        var bufferIndex = line.pos;
        var tokenKind = void 0;
        var tokenPos = bufferIndex;
        while (bufferIndex < end) {
          var charCode = buffer.charCodeAt(bufferIndex);
          var characterKind = Tokenizer2._charCodeMap[charCode];
          if (characterKind === void 0) {
            characterKind = TokenKind.Other;
          }
          if (tokenKind !== void 0 && characterKind === tokenKind && Tokenizer2._isMultiCharacterToken(tokenKind)) {
          } else {
            if (tokenKind !== void 0) {
              tokens.push(new Token(tokenKind, line.getNewRange(tokenPos, bufferIndex), line));
            }
            tokenPos = bufferIndex;
            tokenKind = characterKind;
          }
          ++bufferIndex;
        }
        if (tokenKind !== void 0) {
          tokens.push(new Token(tokenKind, line.getNewRange(tokenPos, bufferIndex), line));
        }
        tokens.push(new Token(TokenKind.Newline, line.getNewRange(line.end, line.end), line));
      };
      Tokenizer2._isMultiCharacterToken = function(kind) {
        switch (kind) {
          case TokenKind.Spacing:
          case TokenKind.AsciiWord:
          case TokenKind.Other:
            return true;
        }
        return false;
      };
      Tokenizer2._ensureInitialized = function() {
        if (Tokenizer2._charCodeMap) {
          return;
        }
        Tokenizer2._charCodeMap = {};
        Tokenizer2._punctuationTokens = {};
        var punctuation = Tokenizer2._commonMarkPunctuationCharacters;
        for (var i = 0; i < punctuation.length; ++i) {
          var charCode = punctuation.charCodeAt(i);
          Tokenizer2._charCodeMap[charCode] = TokenKind.OtherPunctuation;
        }
        var specialMap = {
          "\\": TokenKind.Backslash,
          "<": TokenKind.LessThan,
          ">": TokenKind.GreaterThan,
          "=": TokenKind.Equals,
          "'": TokenKind.SingleQuote,
          '"': TokenKind.DoubleQuote,
          "/": TokenKind.Slash,
          "-": TokenKind.Hyphen,
          "@": TokenKind.AtSign,
          "{": TokenKind.LeftCurlyBracket,
          "}": TokenKind.RightCurlyBracket,
          "`": TokenKind.Backtick,
          ".": TokenKind.Period,
          ":": TokenKind.Colon,
          ",": TokenKind.Comma,
          "[": TokenKind.LeftSquareBracket,
          "]": TokenKind.RightSquareBracket,
          "|": TokenKind.Pipe,
          "(": TokenKind.LeftParenthesis,
          ")": TokenKind.RightParenthesis,
          "#": TokenKind.PoundSymbol,
          "+": TokenKind.Plus,
          $: TokenKind.DollarSign
        };
        for (var _i = 0, _a = Object.getOwnPropertyNames(specialMap); _i < _a.length; _i++) {
          var key = _a[_i];
          Tokenizer2._charCodeMap[key.charCodeAt(0)] = specialMap[key];
          Tokenizer2._punctuationTokens[specialMap[key]] = true;
        }
        Tokenizer2._punctuationTokens[TokenKind.OtherPunctuation] = true;
        var word = Tokenizer2._wordCharacters;
        for (var i = 0; i < word.length; ++i) {
          var charCode = word.charCodeAt(i);
          Tokenizer2._charCodeMap[charCode] = TokenKind.AsciiWord;
        }
        Tokenizer2._charCodeMap[" ".charCodeAt(0)] = TokenKind.Spacing;
        Tokenizer2._charCodeMap["	".charCodeAt(0)] = TokenKind.Spacing;
      };
      Tokenizer2._commonMarkPunctuationCharacters = "!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~";
      Tokenizer2._wordCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";
      return Tokenizer2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/TokenReader.js
var TokenReader;
var init_TokenReader = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/TokenReader.js"() {
    "use strict";
    init_Token();
    init_TokenSequence();
    TokenReader = /** @class */
    function() {
      function TokenReader2(parserContext, embeddedTokenSequence) {
        this._parserContext = parserContext;
        this.tokens = parserContext.tokens;
        if (embeddedTokenSequence) {
          if (embeddedTokenSequence.parserContext !== this._parserContext) {
            throw new Error("The embeddedTokenSequence must use the same parser context");
          }
          this._readerStartIndex = embeddedTokenSequence.startIndex;
          this._readerEndIndex = embeddedTokenSequence.endIndex;
        } else {
          this._readerStartIndex = 0;
          this._readerEndIndex = this.tokens.length;
        }
        this._currentIndex = this._readerStartIndex;
        this._accumulatedStartIndex = this._readerStartIndex;
      }
      TokenReader2.prototype.extractAccumulatedSequence = function() {
        if (this._accumulatedStartIndex === this._currentIndex) {
          throw new Error("Parser assertion failed: The queue should not be empty when extractAccumulatedSequence() is called");
        }
        var sequence = new TokenSequence({
          parserContext: this._parserContext,
          startIndex: this._accumulatedStartIndex,
          endIndex: this._currentIndex
        });
        this._accumulatedStartIndex = this._currentIndex;
        return sequence;
      };
      TokenReader2.prototype.isAccumulatedSequenceEmpty = function() {
        return this._accumulatedStartIndex === this._currentIndex;
      };
      TokenReader2.prototype.tryExtractAccumulatedSequence = function() {
        if (this.isAccumulatedSequenceEmpty()) {
          return void 0;
        }
        return this.extractAccumulatedSequence();
      };
      TokenReader2.prototype.assertAccumulatedSequenceIsEmpty = function() {
        if (!this.isAccumulatedSequenceEmpty()) {
          var sequence = new TokenSequence({
            parserContext: this._parserContext,
            startIndex: this._accumulatedStartIndex,
            endIndex: this._currentIndex
          });
          var tokenStrings = sequence.tokens.map(function(x) {
            return x.toString();
          });
          throw new Error("Parser assertion failed: The queue should be empty, but it contains:\n" + JSON.stringify(tokenStrings));
        }
      };
      TokenReader2.prototype.peekToken = function() {
        return this.tokens[this._currentIndex];
      };
      TokenReader2.prototype.peekTokenKind = function() {
        if (this._currentIndex >= this._readerEndIndex) {
          return TokenKind.EndOfInput;
        }
        return this.tokens[this._currentIndex].kind;
      };
      TokenReader2.prototype.peekTokenAfterKind = function() {
        if (this._currentIndex + 1 >= this._readerEndIndex) {
          return TokenKind.EndOfInput;
        }
        return this.tokens[this._currentIndex + 1].kind;
      };
      TokenReader2.prototype.peekTokenAfterAfterKind = function() {
        if (this._currentIndex + 2 >= this._readerEndIndex) {
          return TokenKind.EndOfInput;
        }
        return this.tokens[this._currentIndex + 2].kind;
      };
      TokenReader2.prototype.readToken = function() {
        if (this._currentIndex >= this._readerEndIndex) {
          throw new Error("Cannot read past end of stream");
        }
        var token = this.tokens[this._currentIndex];
        if (token.kind === TokenKind.EndOfInput) {
          throw new Error("The EndOfInput token cannot be read");
        }
        this._currentIndex++;
        return token;
      };
      TokenReader2.prototype.peekPreviousTokenKind = function() {
        if (this._currentIndex === 0) {
          return TokenKind.EndOfInput;
        }
        return this.tokens[this._currentIndex - 1].kind;
      };
      TokenReader2.prototype.createMarker = function() {
        return this._currentIndex;
      };
      TokenReader2.prototype.backtrackToMarker = function(marker) {
        if (marker > this._currentIndex) {
          throw new Error("The marker has expired");
        }
        this._currentIndex = marker;
        if (marker < this._accumulatedStartIndex) {
          this._accumulatedStartIndex = marker;
        }
      };
      return TokenReader2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/NodeParser.js
function isFailure(resultOrFailure) {
  return resultOrFailure !== void 0 && Object.hasOwnProperty.call(resultOrFailure, "failureMessage");
}
var __assign, NodeParser;
var init_NodeParser = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/NodeParser.js"() {
    "use strict";
    init_Token();
    init_Tokenizer();
    init_nodes();
    init_TokenSequence();
    init_TokenReader();
    init_StringChecks();
    init_TSDocTagDefinition();
    init_StandardTags();
    init_PlainTextEmitter();
    init_TSDocMessageId();
    __assign = function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    NodeParser = /** @class */
    function() {
      function NodeParser2(parserContext) {
        this._parserContext = parserContext;
        this._configuration = parserContext.configuration;
        this._currentSection = parserContext.docComment.summarySection;
      }
      NodeParser2.prototype.parse = function() {
        var tokenReader = new TokenReader(this._parserContext);
        var done = false;
        while (!done) {
          switch (tokenReader.peekTokenKind()) {
            case TokenKind.EndOfInput:
              done = true;
              break;
            case TokenKind.Newline:
              this._pushAccumulatedPlainText(tokenReader);
              tokenReader.readToken();
              this._pushNode(new DocSoftBreak({
                parsed: true,
                configuration: this._configuration,
                softBreakExcerpt: tokenReader.extractAccumulatedSequence()
              }));
              break;
            case TokenKind.Backslash:
              this._pushAccumulatedPlainText(tokenReader);
              this._pushNode(this._parseBackslashEscape(tokenReader));
              break;
            case TokenKind.AtSign:
              this._pushAccumulatedPlainText(tokenReader);
              this._parseAndPushBlock(tokenReader);
              break;
            case TokenKind.LeftCurlyBracket: {
              this._pushAccumulatedPlainText(tokenReader);
              var marker = tokenReader.createMarker();
              var docNode = this._parseInlineTag(tokenReader);
              var docComment = this._parserContext.docComment;
              if (docNode instanceof DocInheritDocTag) {
                var tagEndMarker = tokenReader.createMarker() - 1;
                if (docComment.inheritDocTag === void 0) {
                  this._parserContext.docComment.inheritDocTag = docNode;
                } else {
                  this._pushNode(this._backtrackAndCreateErrorRange(tokenReader, marker, tagEndMarker, TSDocMessageId.ExtraInheritDocTag, "A doc comment cannot have more than one @inheritDoc tag"));
                }
              } else {
                this._pushNode(docNode);
              }
              break;
            }
            case TokenKind.RightCurlyBracket:
              this._pushAccumulatedPlainText(tokenReader);
              this._pushNode(this._createError(tokenReader, TSDocMessageId.EscapeRightBrace, 'The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag'));
              break;
            case TokenKind.LessThan:
              this._pushAccumulatedPlainText(tokenReader);
              if (tokenReader.peekTokenAfterKind() === TokenKind.Slash) {
                this._pushNode(this._parseHtmlEndTag(tokenReader));
              } else {
                this._pushNode(this._parseHtmlStartTag(tokenReader));
              }
              break;
            case TokenKind.GreaterThan:
              this._pushAccumulatedPlainText(tokenReader);
              this._pushNode(this._createError(tokenReader, TSDocMessageId.EscapeGreaterThan, 'The ">" character should be escaped using a backslash to avoid confusion with an HTML tag'));
              break;
            case TokenKind.Backtick:
              this._pushAccumulatedPlainText(tokenReader);
              if (tokenReader.peekTokenAfterKind() === TokenKind.Backtick && tokenReader.peekTokenAfterAfterKind() === TokenKind.Backtick) {
                this._pushNode(this._parseFencedCode(tokenReader));
              } else {
                this._pushNode(this._parseCodeSpan(tokenReader));
              }
              break;
            default:
              tokenReader.readToken();
              break;
          }
        }
        this._pushAccumulatedPlainText(tokenReader);
        this._performValidationChecks();
      };
      NodeParser2.prototype._performValidationChecks = function() {
        var docComment = this._parserContext.docComment;
        if (docComment.deprecatedBlock) {
          if (!PlainTextEmitter.hasAnyTextContent(docComment.deprecatedBlock)) {
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.MissingDeprecationMessage, "The " + docComment.deprecatedBlock.blockTag.tagName + " block must include a deprecation message, e.g. describing the recommended alternative", docComment.deprecatedBlock.blockTag.getTokenSequence(), docComment.deprecatedBlock);
          }
        }
        if (docComment.inheritDocTag) {
          if (docComment.remarksBlock) {
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.InheritDocIncompatibleTag, 'A "' + docComment.remarksBlock.blockTag.tagName + '" block must not be used, because that content is provided by the @inheritDoc tag', docComment.remarksBlock.blockTag.getTokenSequence(), docComment.remarksBlock.blockTag);
          }
          if (PlainTextEmitter.hasAnyTextContent(docComment.summarySection)) {
            this._parserContext.log.addMessageForTextRange(TSDocMessageId.InheritDocIncompatibleSummary, "The summary section must not have any content, because that content is provided by the @inheritDoc tag", this._parserContext.commentRange);
          }
        }
      };
      NodeParser2.prototype._validateTagDefinition = function(tagDefinition, tagName, expectingInlineTag, tokenSequenceForErrorContext, nodeForErrorContext) {
        if (tagDefinition) {
          var isInlineTag = tagDefinition.syntaxKind === TSDocTagSyntaxKind.InlineTag;
          if (isInlineTag !== expectingInlineTag) {
            if (expectingInlineTag) {
              this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.TagShouldNotHaveBraces, 'The TSDoc tag "' + tagName + '" is not an inline tag; it must not be enclosed in "{ }" braces', tokenSequenceForErrorContext, nodeForErrorContext);
            } else {
              this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.InlineTagMissingBraces, 'The TSDoc tag "' + tagName + '" is an inline tag; it must be enclosed in "{ }" braces', tokenSequenceForErrorContext, nodeForErrorContext);
            }
          } else {
            if (this._parserContext.configuration.validation.reportUnsupportedTags) {
              if (!this._parserContext.configuration.isTagSupported(tagDefinition)) {
                this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.UnsupportedTag, 'The TSDoc tag "' + tagName + '" is not supported by this tool', tokenSequenceForErrorContext, nodeForErrorContext);
              }
            }
          }
        } else {
          if (!this._parserContext.configuration.validation.ignoreUndefinedTags) {
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.UndefinedTag, 'The TSDoc tag "' + tagName + '" is not defined in this configuration', tokenSequenceForErrorContext, nodeForErrorContext);
          }
        }
      };
      NodeParser2.prototype._pushAccumulatedPlainText = function(tokenReader) {
        if (!tokenReader.isAccumulatedSequenceEmpty()) {
          this._pushNode(new DocPlainText({
            parsed: true,
            configuration: this._configuration,
            textExcerpt: tokenReader.extractAccumulatedSequence()
          }));
        }
      };
      NodeParser2.prototype._parseAndPushBlock = function(tokenReader) {
        var docComment = this._parserContext.docComment;
        var configuration = this._parserContext.configuration;
        var modifierTagSet = docComment.modifierTagSet;
        var parsedBlockTag = this._parseBlockTag(tokenReader);
        if (parsedBlockTag.kind !== DocNodeKind.BlockTag) {
          this._pushNode(parsedBlockTag);
          return;
        }
        var docBlockTag = parsedBlockTag;
        var tagDefinition = configuration.tryGetTagDefinitionWithUpperCase(docBlockTag.tagNameWithUpperCase);
        this._validateTagDefinition(
          tagDefinition,
          docBlockTag.tagName,
          /* expectingInlineTag */
          false,
          docBlockTag.getTokenSequence(),
          docBlockTag
        );
        if (tagDefinition) {
          switch (tagDefinition.syntaxKind) {
            case TSDocTagSyntaxKind.BlockTag:
              if (docBlockTag.tagNameWithUpperCase === StandardTags.param.tagNameWithUpperCase) {
                var docParamBlock = this._parseParamBlock(tokenReader, docBlockTag, StandardTags.param.tagName);
                this._parserContext.docComment.params.add(docParamBlock);
                this._currentSection = docParamBlock.content;
                return;
              } else if (docBlockTag.tagNameWithUpperCase === StandardTags.typeParam.tagNameWithUpperCase) {
                var docParamBlock = this._parseParamBlock(tokenReader, docBlockTag, StandardTags.typeParam.tagName);
                this._parserContext.docComment.typeParams.add(docParamBlock);
                this._currentSection = docParamBlock.content;
                return;
              } else {
                var newBlock = new DocBlock({
                  configuration: this._configuration,
                  blockTag: docBlockTag
                });
                this._addBlockToDocComment(newBlock);
                this._currentSection = newBlock.content;
              }
              return;
            case TSDocTagSyntaxKind.ModifierTag:
              modifierTagSet.addTag(docBlockTag);
              return;
          }
        }
        this._pushNode(docBlockTag);
      };
      NodeParser2.prototype._addBlockToDocComment = function(block) {
        var docComment = this._parserContext.docComment;
        switch (block.blockTag.tagNameWithUpperCase) {
          case StandardTags.remarks.tagNameWithUpperCase:
            docComment.remarksBlock = block;
            break;
          case StandardTags.privateRemarks.tagNameWithUpperCase:
            docComment.privateRemarks = block;
            break;
          case StandardTags.deprecated.tagNameWithUpperCase:
            docComment.deprecatedBlock = block;
            break;
          case StandardTags.returns.tagNameWithUpperCase:
            docComment.returnsBlock = block;
            break;
          case StandardTags.see.tagNameWithUpperCase:
            docComment._appendSeeBlock(block);
            break;
          default:
            docComment.appendCustomBlock(block);
        }
      };
      NodeParser2.prototype._tryParseJSDocTypeOrValueRest = function(tokenReader, openKind, closeKind, startMarker) {
        var quoteKind;
        var openCount = 1;
        while (openCount > 0) {
          var tokenKind = tokenReader.peekTokenKind();
          switch (tokenKind) {
            case openKind:
              if (quoteKind === void 0)
                openCount++;
              break;
            case closeKind:
              if (quoteKind === void 0)
                openCount--;
              break;
            case TokenKind.Backslash:
              if (quoteKind !== void 0) {
                tokenReader.readToken();
                tokenKind = tokenReader.peekTokenKind();
              }
              break;
            case TokenKind.DoubleQuote:
            case TokenKind.SingleQuote:
            case TokenKind.Backtick:
              if (quoteKind === tokenKind) {
                quoteKind = void 0;
              } else if (quoteKind === void 0) {
                quoteKind = tokenKind;
              }
              break;
          }
          if (tokenKind === TokenKind.EndOfInput) {
            tokenReader.backtrackToMarker(startMarker);
            return void 0;
          }
          tokenReader.readToken();
        }
        return tokenReader.tryExtractAccumulatedSequence();
      };
      NodeParser2.prototype._tryParseUnsupportedJSDocType = function(tokenReader, docBlockTag, tagName) {
        tokenReader.assertAccumulatedSequenceIsEmpty();
        if (tokenReader.peekTokenKind() !== TokenKind.LeftCurlyBracket || tokenReader.peekTokenAfterKind() === TokenKind.AtSign) {
          return void 0;
        }
        var startMarker = tokenReader.createMarker();
        tokenReader.readToken();
        var jsdocTypeExcerpt = this._tryParseJSDocTypeOrValueRest(tokenReader, TokenKind.LeftCurlyBracket, TokenKind.RightCurlyBracket, startMarker);
        if (jsdocTypeExcerpt) {
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ParamTagWithInvalidType, "The " + tagName + " block should not include a JSDoc-style '{type}'", jsdocTypeExcerpt, docBlockTag);
          var spacingAfterJsdocTypeExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
          if (spacingAfterJsdocTypeExcerpt) {
            jsdocTypeExcerpt = jsdocTypeExcerpt.getNewSequence(jsdocTypeExcerpt.startIndex, spacingAfterJsdocTypeExcerpt.endIndex);
          }
        }
        return jsdocTypeExcerpt;
      };
      NodeParser2.prototype._tryParseJSDocOptionalNameRest = function(tokenReader) {
        tokenReader.assertAccumulatedSequenceIsEmpty();
        if (tokenReader.peekTokenKind() !== TokenKind.EndOfInput) {
          var startMarker = tokenReader.createMarker();
          return this._tryParseJSDocTypeOrValueRest(tokenReader, TokenKind.LeftSquareBracket, TokenKind.RightSquareBracket, startMarker);
        }
        return void 0;
      };
      NodeParser2.prototype._parseParamBlock = function(tokenReader, docBlockTag, tagName) {
        var startMarker = tokenReader.createMarker();
        var spacingBeforeParameterNameExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        var unsupportedJsdocTypeBeforeParameterNameExcerpt = this._tryParseUnsupportedJSDocType(tokenReader, docBlockTag, tagName);
        var unsupportedJsdocOptionalNameOpenBracketExcerpt;
        if (tokenReader.peekTokenKind() === TokenKind.LeftSquareBracket) {
          tokenReader.readToken();
          unsupportedJsdocOptionalNameOpenBracketExcerpt = tokenReader.extractAccumulatedSequence();
        }
        var parameterName = "";
        var done = false;
        while (!done) {
          switch (tokenReader.peekTokenKind()) {
            case TokenKind.AsciiWord:
            case TokenKind.Period:
            case TokenKind.DollarSign:
              parameterName += tokenReader.readToken();
              break;
            default:
              done = true;
              break;
          }
        }
        var explanation = StringChecks.explainIfInvalidUnquotedIdentifier(parameterName);
        if (explanation !== void 0) {
          tokenReader.backtrackToMarker(startMarker);
          var errorParamBlock = new DocParamBlock({
            configuration: this._configuration,
            blockTag: docBlockTag,
            parameterName: ""
          });
          var errorMessage = parameterName.length > 0 ? "The " + tagName + " block should be followed by a valid parameter name: " + explanation : "The " + tagName + " block should be followed by a parameter name";
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ParamTagWithInvalidName, errorMessage, docBlockTag.getTokenSequence(), docBlockTag);
          return errorParamBlock;
        }
        var parameterNameExcerpt = tokenReader.extractAccumulatedSequence();
        var unsupportedJsdocOptionalNameRestExcerpt;
        if (unsupportedJsdocOptionalNameOpenBracketExcerpt) {
          unsupportedJsdocOptionalNameRestExcerpt = this._tryParseJSDocOptionalNameRest(tokenReader);
          var errorSequence = unsupportedJsdocOptionalNameOpenBracketExcerpt;
          if (unsupportedJsdocOptionalNameRestExcerpt) {
            errorSequence = docBlockTag.getTokenSequence().getNewSequence(unsupportedJsdocOptionalNameOpenBracketExcerpt.startIndex, unsupportedJsdocOptionalNameRestExcerpt.endIndex);
          }
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ParamTagWithInvalidOptionalName, "The " + tagName + " should not include a JSDoc-style optional name; it must not be enclosed in '[ ]' brackets.", errorSequence, docBlockTag);
        }
        var spacingAfterParameterNameExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        var unsupportedJsdocTypeAfterParameterNameExcerpt = this._tryParseUnsupportedJSDocType(tokenReader, docBlockTag, tagName);
        var hyphenExcerpt;
        var spacingAfterHyphenExcerpt;
        var unsupportedJsdocTypeAfterHyphenExcerpt;
        if (tokenReader.peekTokenKind() === TokenKind.Hyphen) {
          tokenReader.readToken();
          hyphenExcerpt = tokenReader.extractAccumulatedSequence();
          spacingAfterHyphenExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
          unsupportedJsdocTypeAfterHyphenExcerpt = this._tryParseUnsupportedJSDocType(tokenReader, docBlockTag, tagName);
        } else {
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ParamTagMissingHyphen, "The " + tagName + " block should be followed by a parameter name and then a hyphen", docBlockTag.getTokenSequence(), docBlockTag);
        }
        return new DocParamBlock({
          parsed: true,
          configuration: this._configuration,
          blockTag: docBlockTag,
          spacingBeforeParameterNameExcerpt,
          unsupportedJsdocTypeBeforeParameterNameExcerpt,
          unsupportedJsdocOptionalNameOpenBracketExcerpt,
          parameterNameExcerpt,
          parameterName,
          unsupportedJsdocOptionalNameRestExcerpt,
          spacingAfterParameterNameExcerpt,
          unsupportedJsdocTypeAfterParameterNameExcerpt,
          hyphenExcerpt,
          spacingAfterHyphenExcerpt,
          unsupportedJsdocTypeAfterHyphenExcerpt
        });
      };
      NodeParser2.prototype._pushNode = function(docNode) {
        if (this._configuration.docNodeManager.isAllowedChild(DocNodeKind.Paragraph, docNode.kind)) {
          this._currentSection.appendNodeInParagraph(docNode);
        } else {
          this._currentSection.appendNode(docNode);
        }
      };
      NodeParser2.prototype._parseBackslashEscape = function(tokenReader) {
        tokenReader.assertAccumulatedSequenceIsEmpty();
        var marker = tokenReader.createMarker();
        tokenReader.readToken();
        if (tokenReader.peekTokenKind() === TokenKind.EndOfInput) {
          return this._backtrackAndCreateError(tokenReader, marker, TSDocMessageId.UnnecessaryBackslash, "A backslash must precede another character that is being escaped");
        }
        var escapedToken = tokenReader.readToken();
        if (!Tokenizer.isPunctuation(escapedToken.kind)) {
          return this._backtrackAndCreateError(tokenReader, marker, TSDocMessageId.UnnecessaryBackslash, "A backslash can only be used to escape a punctuation character");
        }
        var encodedTextExcerpt = tokenReader.extractAccumulatedSequence();
        return new DocEscapedText({
          parsed: true,
          configuration: this._configuration,
          escapeStyle: EscapeStyle.CommonMarkBackslash,
          encodedTextExcerpt,
          decodedText: escapedToken.toString()
        });
      };
      NodeParser2.prototype._parseBlockTag = function(tokenReader) {
        tokenReader.assertAccumulatedSequenceIsEmpty();
        var marker = tokenReader.createMarker();
        if (tokenReader.peekTokenKind() !== TokenKind.AtSign) {
          return this._backtrackAndCreateError(tokenReader, marker, TSDocMessageId.MissingTag, 'Expecting a TSDoc tag starting with "@"');
        }
        switch (tokenReader.peekPreviousTokenKind()) {
          case TokenKind.EndOfInput:
          case TokenKind.Spacing:
          case TokenKind.Newline:
            break;
          default:
            return this._backtrackAndCreateError(tokenReader, marker, TSDocMessageId.AtSignInWord, 'The "@" character looks like part of a TSDoc tag; use a backslash to escape it');
        }
        var tagName = tokenReader.readToken().toString();
        if (tokenReader.peekTokenKind() !== TokenKind.AsciiWord) {
          return this._backtrackAndCreateError(tokenReader, marker, TSDocMessageId.AtSignWithoutTagName, 'Expecting a TSDoc tag name after "@"; if it is not a tag, use a backslash to escape this character');
        }
        var tagNameMarker = tokenReader.createMarker();
        while (tokenReader.peekTokenKind() === TokenKind.AsciiWord) {
          tagName += tokenReader.readToken().toString();
        }
        switch (tokenReader.peekTokenKind()) {
          case TokenKind.Spacing:
          case TokenKind.Newline:
          case TokenKind.EndOfInput:
            break;
          default:
            var badCharacter = tokenReader.peekToken().range.toString()[0];
            return this._backtrackAndCreateError(tokenReader, marker, TSDocMessageId.CharactersAfterBlockTag, 'The token "' + tagName + '" looks like a TSDoc tag but contains an invalid character' + (" " + JSON.stringify(badCharacter) + '; if it is not a tag, use a backslash to escape the "@"'));
        }
        if (StringChecks.explainIfInvalidTSDocTagName(tagName)) {
          var failure = this._createFailureForTokensSince(tokenReader, TSDocMessageId.MalformedTagName, "A TSDoc tag name must start with a letter and contain only letters and numbers", tagNameMarker);
          return this._backtrackAndCreateErrorForFailure(tokenReader, marker, "", failure);
        }
        return new DocBlockTag({
          parsed: true,
          configuration: this._configuration,
          tagName,
          tagNameExcerpt: tokenReader.extractAccumulatedSequence()
        });
      };
      NodeParser2.prototype._parseInlineTag = function(tokenReader) {
        tokenReader.assertAccumulatedSequenceIsEmpty();
        var marker = tokenReader.createMarker();
        if (tokenReader.peekTokenKind() !== TokenKind.LeftCurlyBracket) {
          return this._backtrackAndCreateError(tokenReader, marker, TSDocMessageId.MissingTag, 'Expecting a TSDoc tag starting with "{"');
        }
        tokenReader.readToken();
        var openingDelimiterExcerpt = tokenReader.extractAccumulatedSequence();
        var atSignMarker = tokenReader.createMarker();
        if (tokenReader.peekTokenKind() !== TokenKind.AtSign) {
          return this._backtrackAndCreateError(tokenReader, marker, TSDocMessageId.MalformedInlineTag, 'Expecting a TSDoc tag starting with "{@"');
        }
        var tagName = tokenReader.readToken().toString();
        while (tokenReader.peekTokenKind() === TokenKind.AsciiWord) {
          tagName += tokenReader.readToken().toString();
        }
        if (tagName === "@") {
          var failure = this._createFailureForTokensSince(tokenReader, TSDocMessageId.MalformedInlineTag, 'Expecting a TSDoc inline tag name after the "{@" characters', atSignMarker);
          return this._backtrackAndCreateErrorRangeForFailure(tokenReader, marker, atSignMarker, "", failure);
        }
        if (StringChecks.explainIfInvalidTSDocTagName(tagName)) {
          var failure = this._createFailureForTokensSince(tokenReader, TSDocMessageId.MalformedTagName, "A TSDoc tag name must start with a letter and contain only letters and numbers", atSignMarker);
          return this._backtrackAndCreateErrorRangeForFailure(tokenReader, marker, atSignMarker, "", failure);
        }
        var tagNameExcerpt = tokenReader.extractAccumulatedSequence();
        var spacingAfterTagNameExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        if (spacingAfterTagNameExcerpt === void 0) {
          if (tokenReader.peekTokenKind() !== TokenKind.RightCurlyBracket) {
            var badCharacter = tokenReader.peekToken().range.toString()[0];
            var failure = this._createFailureForToken(tokenReader, TSDocMessageId.CharactersAfterInlineTag, "The character " + JSON.stringify(badCharacter) + " cannot appear after the TSDoc tag name; expecting a space");
            return this._backtrackAndCreateErrorRangeForFailure(tokenReader, marker, atSignMarker, "", failure);
          }
        }
        var done = false;
        while (!done) {
          switch (tokenReader.peekTokenKind()) {
            case TokenKind.EndOfInput:
              return this._backtrackAndCreateErrorRange(tokenReader, marker, atSignMarker, TSDocMessageId.InlineTagMissingRightBrace, 'The TSDoc inline tag name is missing its closing "}"');
            case TokenKind.Backslash:
              tokenReader.readToken();
              if (!Tokenizer.isPunctuation(tokenReader.peekTokenKind())) {
                var failure = this._createFailureForToken(tokenReader, TSDocMessageId.UnnecessaryBackslash, "A backslash can only be used to escape a punctuation character");
                return this._backtrackAndCreateErrorRangeForFailure(tokenReader, marker, atSignMarker, "Error reading inline TSDoc tag: ", failure);
              }
              tokenReader.readToken();
              break;
            case TokenKind.LeftCurlyBracket: {
              var failure = this._createFailureForToken(tokenReader, TSDocMessageId.InlineTagUnescapedBrace, 'The "{" character must be escaped with a backslash when used inside a TSDoc inline tag');
              return this._backtrackAndCreateErrorRangeForFailure(tokenReader, marker, atSignMarker, "", failure);
            }
            case TokenKind.RightCurlyBracket:
              done = true;
              break;
            default:
              tokenReader.readToken();
              break;
          }
        }
        var tagContentExcerpt = tokenReader.tryExtractAccumulatedSequence();
        tokenReader.readToken();
        var closingDelimiterExcerpt = tokenReader.extractAccumulatedSequence();
        var docInlineTagParsedParameters = {
          parsed: true,
          configuration: this._configuration,
          openingDelimiterExcerpt,
          tagNameExcerpt,
          tagName,
          spacingAfterTagNameExcerpt,
          tagContentExcerpt,
          closingDelimiterExcerpt
        };
        var tagNameWithUpperCase = tagName.toUpperCase();
        var embeddedTokenReader = new TokenReader(this._parserContext, tagContentExcerpt ? tagContentExcerpt : TokenSequence.createEmpty(this._parserContext));
        var docNode;
        switch (tagNameWithUpperCase) {
          case StandardTags.inheritDoc.tagNameWithUpperCase:
            docNode = this._parseInheritDocTag(docInlineTagParsedParameters, embeddedTokenReader);
            break;
          case StandardTags.link.tagNameWithUpperCase:
            docNode = this._parseLinkTag(docInlineTagParsedParameters, embeddedTokenReader);
            break;
          default:
            docNode = new DocInlineTag(docInlineTagParsedParameters);
        }
        var tagDefinition = this._parserContext.configuration.tryGetTagDefinitionWithUpperCase(tagNameWithUpperCase);
        this._validateTagDefinition(
          tagDefinition,
          tagName,
          /* expectingInlineTag */
          true,
          tagNameExcerpt,
          docNode
        );
        return docNode;
      };
      NodeParser2.prototype._parseInheritDocTag = function(docInlineTagParsedParameters, embeddedTokenReader) {
        var errorTag = new DocInlineTag(docInlineTagParsedParameters);
        var parameters = __assign({}, docInlineTagParsedParameters);
        if (embeddedTokenReader.peekTokenKind() !== TokenKind.EndOfInput) {
          parameters.declarationReference = this._parseDeclarationReference(embeddedTokenReader, docInlineTagParsedParameters.tagNameExcerpt, errorTag);
          if (!parameters.declarationReference) {
            return errorTag;
          }
          if (embeddedTokenReader.peekTokenKind() !== TokenKind.EndOfInput) {
            embeddedTokenReader.readToken();
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.InheritDocTagSyntax, "Unexpected character after declaration reference", embeddedTokenReader.extractAccumulatedSequence(), errorTag);
            return errorTag;
          }
        }
        return new DocInheritDocTag(parameters);
      };
      NodeParser2.prototype._parseLinkTag = function(docInlineTagParsedParameters, embeddedTokenReader) {
        var errorTag = new DocInlineTag(docInlineTagParsedParameters);
        var parameters = __assign({}, docInlineTagParsedParameters);
        if (!docInlineTagParsedParameters.tagContentExcerpt) {
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.LinkTagEmpty, "The @link tag content is missing", parameters.tagNameExcerpt, errorTag);
          return errorTag;
        }
        var looksLikeUrl = embeddedTokenReader.peekTokenKind() === TokenKind.Slash && embeddedTokenReader.peekTokenAfterKind() === TokenKind.Slash;
        var marker = embeddedTokenReader.createMarker();
        var done = looksLikeUrl;
        while (!done) {
          switch (embeddedTokenReader.peekTokenKind()) {
            case TokenKind.AsciiWord:
            case TokenKind.Period:
            case TokenKind.Hyphen:
            case TokenKind.Plus:
              embeddedTokenReader.readToken();
              break;
            case TokenKind.Colon:
              embeddedTokenReader.readToken();
              looksLikeUrl = embeddedTokenReader.peekTokenKind() === TokenKind.Slash && embeddedTokenReader.peekTokenAfterKind() === TokenKind.Slash;
              done = true;
              break;
            default:
              done = true;
          }
        }
        embeddedTokenReader.backtrackToMarker(marker);
        if (looksLikeUrl) {
          if (!this._parseLinkTagUrlDestination(embeddedTokenReader, parameters, docInlineTagParsedParameters.tagNameExcerpt, errorTag)) {
            return errorTag;
          }
        } else {
          if (!this._parseLinkTagCodeDestination(embeddedTokenReader, parameters, docInlineTagParsedParameters.tagNameExcerpt, errorTag)) {
            return errorTag;
          }
        }
        if (embeddedTokenReader.peekTokenKind() === TokenKind.Spacing) {
          throw new Error("Unconsumed spacing encountered after construct");
        }
        if (embeddedTokenReader.peekTokenKind() === TokenKind.Pipe) {
          embeddedTokenReader.readToken();
          parameters.pipeExcerpt = embeddedTokenReader.extractAccumulatedSequence();
          parameters.spacingAfterPipeExcerpt = this._tryReadSpacingAndNewlines(embeddedTokenReader);
          done = false;
          var spacingAfterLinkTextMarker = void 0;
          while (!done) {
            switch (embeddedTokenReader.peekTokenKind()) {
              case TokenKind.EndOfInput:
                done = true;
                break;
              case TokenKind.Pipe:
              case TokenKind.LeftCurlyBracket:
                var badCharacter = embeddedTokenReader.readToken().toString();
                this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.LinkTagUnescapedText, 'The "' + badCharacter + '" character may not be used in the link text without escaping it', embeddedTokenReader.extractAccumulatedSequence(), errorTag);
                return errorTag;
              case TokenKind.Spacing:
              case TokenKind.Newline:
                embeddedTokenReader.readToken();
                break;
              default:
                spacingAfterLinkTextMarker = embeddedTokenReader.createMarker() + 1;
                embeddedTokenReader.readToken();
            }
          }
          var linkTextAndSpacing = embeddedTokenReader.tryExtractAccumulatedSequence();
          if (linkTextAndSpacing) {
            if (spacingAfterLinkTextMarker === void 0) {
              parameters.spacingAfterLinkTextExcerpt = linkTextAndSpacing;
            } else if (spacingAfterLinkTextMarker >= linkTextAndSpacing.endIndex) {
              parameters.linkTextExcerpt = linkTextAndSpacing;
            } else {
              parameters.linkTextExcerpt = linkTextAndSpacing.getNewSequence(linkTextAndSpacing.startIndex, spacingAfterLinkTextMarker);
              parameters.spacingAfterLinkTextExcerpt = linkTextAndSpacing.getNewSequence(spacingAfterLinkTextMarker, linkTextAndSpacing.endIndex);
            }
          }
        } else if (embeddedTokenReader.peekTokenKind() !== TokenKind.EndOfInput) {
          embeddedTokenReader.readToken();
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.LinkTagDestinationSyntax, "Unexpected character after link destination", embeddedTokenReader.extractAccumulatedSequence(), errorTag);
          return errorTag;
        }
        return new DocLinkTag(parameters);
      };
      NodeParser2.prototype._parseLinkTagUrlDestination = function(embeddedTokenReader, parameters, tokenSequenceForErrorContext, nodeForErrorContext) {
        var urlDestination = "";
        var done = false;
        while (!done) {
          switch (embeddedTokenReader.peekTokenKind()) {
            case TokenKind.Spacing:
            case TokenKind.Newline:
            case TokenKind.EndOfInput:
            case TokenKind.Pipe:
            case TokenKind.RightCurlyBracket:
              done = true;
              break;
            default:
              urlDestination += embeddedTokenReader.readToken();
              break;
          }
        }
        if (urlDestination.length === 0) {
          throw new Error("Missing URL in _parseLinkTagUrlDestination()");
        }
        var urlDestinationExcerpt = embeddedTokenReader.extractAccumulatedSequence();
        var invalidUrlExplanation = StringChecks.explainIfInvalidLinkUrl(urlDestination);
        if (invalidUrlExplanation) {
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.LinkTagInvalidUrl, invalidUrlExplanation, urlDestinationExcerpt, nodeForErrorContext);
          return false;
        }
        parameters.urlDestinationExcerpt = urlDestinationExcerpt;
        parameters.spacingAfterDestinationExcerpt = this._tryReadSpacingAndNewlines(embeddedTokenReader);
        return true;
      };
      NodeParser2.prototype._parseLinkTagCodeDestination = function(embeddedTokenReader, parameters, tokenSequenceForErrorContext, nodeForErrorContext) {
        parameters.codeDestination = this._parseDeclarationReference(embeddedTokenReader, tokenSequenceForErrorContext, nodeForErrorContext);
        return !!parameters.codeDestination;
      };
      NodeParser2.prototype._parseDeclarationReference = function(tokenReader, tokenSequenceForErrorContext, nodeForErrorContext) {
        tokenReader.assertAccumulatedSequenceIsEmpty();
        var marker = tokenReader.createMarker();
        var hasHash = false;
        var lookingForImportCharacters = true;
        var sawImportCharacters = false;
        var done = false;
        while (!done) {
          switch (tokenReader.peekTokenKind()) {
            case TokenKind.DoubleQuote:
            case TokenKind.EndOfInput:
            case TokenKind.LeftCurlyBracket:
            case TokenKind.LeftParenthesis:
            case TokenKind.LeftSquareBracket:
            case TokenKind.Newline:
            case TokenKind.Pipe:
            case TokenKind.RightCurlyBracket:
            case TokenKind.RightParenthesis:
            case TokenKind.RightSquareBracket:
            case TokenKind.SingleQuote:
            case TokenKind.Spacing:
              done = true;
              break;
            case TokenKind.PoundSymbol:
              hasHash = true;
              done = true;
              break;
            case TokenKind.Slash:
            case TokenKind.AtSign:
              if (lookingForImportCharacters) {
                sawImportCharacters = true;
              }
              tokenReader.readToken();
              break;
            case TokenKind.AsciiWord:
            case TokenKind.Period:
            case TokenKind.Hyphen:
              tokenReader.readToken();
              break;
            default:
              lookingForImportCharacters = false;
              tokenReader.readToken();
          }
        }
        if (!hasHash && sawImportCharacters) {
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceMissingHash, 'The declaration reference appears to contain a package name or import path, but it is missing the "#" delimiter', tokenReader.extractAccumulatedSequence(), nodeForErrorContext);
          return void 0;
        }
        tokenReader.backtrackToMarker(marker);
        var packageNameExcerpt;
        var importPathExcerpt;
        var importHashExcerpt;
        var spacingAfterImportHashExcerpt;
        if (hasHash) {
          if (tokenReader.peekTokenKind() !== TokenKind.Period) {
            var scopedPackageName = tokenReader.peekTokenKind() === TokenKind.AtSign;
            var finishedScope = false;
            done = false;
            while (!done) {
              switch (tokenReader.peekTokenKind()) {
                case TokenKind.EndOfInput:
                  throw new Error("Expecting pound symbol");
                case TokenKind.Slash:
                  if (scopedPackageName && !finishedScope) {
                    tokenReader.readToken();
                    finishedScope = true;
                  } else {
                    done = true;
                  }
                  break;
                case TokenKind.PoundSymbol:
                  done = true;
                  break;
                default:
                  tokenReader.readToken();
              }
            }
            if (!tokenReader.isAccumulatedSequenceEmpty()) {
              packageNameExcerpt = tokenReader.extractAccumulatedSequence();
              var explanation = StringChecks.explainIfInvalidPackageName(packageNameExcerpt.toString());
              if (explanation) {
                this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceMalformedPackageName, explanation, packageNameExcerpt, nodeForErrorContext);
                return void 0;
              }
            }
          }
          done = false;
          while (!done) {
            switch (tokenReader.peekTokenKind()) {
              case TokenKind.EndOfInput:
                throw new Error("Expecting pound symbol");
              case TokenKind.PoundSymbol:
                done = true;
                break;
              default:
                tokenReader.readToken();
            }
          }
          if (!tokenReader.isAccumulatedSequenceEmpty()) {
            importPathExcerpt = tokenReader.extractAccumulatedSequence();
            var explanation = StringChecks.explainIfInvalidImportPath(importPathExcerpt.toString(), !!packageNameExcerpt);
            if (explanation) {
              this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceMalformedImportPath, explanation, importPathExcerpt, nodeForErrorContext);
              return void 0;
            }
          }
          if (tokenReader.peekTokenKind() !== TokenKind.PoundSymbol) {
            throw new Error("Expecting pound symbol");
          }
          tokenReader.readToken();
          importHashExcerpt = tokenReader.extractAccumulatedSequence();
          spacingAfterImportHashExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
          if (packageNameExcerpt === void 0 && importPathExcerpt === void 0) {
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceHashSyntax, "The hash character must be preceded by a package name or import path", importHashExcerpt, nodeForErrorContext);
            return void 0;
          }
        }
        var memberReferences = [];
        done = false;
        while (!done) {
          switch (tokenReader.peekTokenKind()) {
            case TokenKind.Period:
            case TokenKind.LeftParenthesis:
            case TokenKind.AsciiWord:
            case TokenKind.Colon:
            case TokenKind.LeftSquareBracket:
            case TokenKind.DoubleQuote:
              var expectingDot = memberReferences.length > 0;
              var memberReference = this._parseMemberReference(tokenReader, expectingDot, tokenSequenceForErrorContext, nodeForErrorContext);
              if (!memberReference) {
                return void 0;
              }
              memberReferences.push(memberReference);
              break;
            default:
              done = true;
          }
        }
        if (packageNameExcerpt === void 0 && importPathExcerpt === void 0 && memberReferences.length === 0) {
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.MissingReference, "Expecting a declaration reference", tokenSequenceForErrorContext, nodeForErrorContext);
          return void 0;
        }
        return new DocDeclarationReference({
          parsed: true,
          configuration: this._configuration,
          packageNameExcerpt,
          importPathExcerpt,
          importHashExcerpt,
          spacingAfterImportHashExcerpt,
          memberReferences
        });
      };
      NodeParser2.prototype._parseMemberReference = function(tokenReader, expectingDot, tokenSequenceForErrorContext, nodeForErrorContext) {
        var parameters = {
          parsed: true,
          configuration: this._configuration
        };
        if (expectingDot) {
          if (tokenReader.peekTokenKind() !== TokenKind.Period) {
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceMissingDot, "Expecting a period before the next component of a declaration reference", tokenSequenceForErrorContext, nodeForErrorContext);
            return void 0;
          }
          tokenReader.readToken();
          parameters.dotExcerpt = tokenReader.extractAccumulatedSequence();
          parameters.spacingAfterDotExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        }
        if (tokenReader.peekTokenKind() === TokenKind.LeftParenthesis) {
          tokenReader.readToken();
          parameters.leftParenthesisExcerpt = tokenReader.extractAccumulatedSequence();
          parameters.spacingAfterLeftParenthesisExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        }
        if (tokenReader.peekTokenKind() === TokenKind.LeftSquareBracket) {
          parameters.memberSymbol = this._parseMemberSymbol(tokenReader, nodeForErrorContext);
          if (!parameters.memberSymbol) {
            return void 0;
          }
        } else {
          parameters.memberIdentifier = this._parseMemberIdentifier(tokenReader, tokenSequenceForErrorContext, nodeForErrorContext);
          if (!parameters.memberIdentifier) {
            return void 0;
          }
        }
        parameters.spacingAfterMemberExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        if (tokenReader.peekTokenKind() === TokenKind.Colon) {
          tokenReader.readToken();
          parameters.colonExcerpt = tokenReader.extractAccumulatedSequence();
          parameters.spacingAfterColonExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
          if (!parameters.leftParenthesisExcerpt) {
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceSelectorMissingParens, "Syntax error in declaration reference: the member selector must be enclosed in parentheses", parameters.colonExcerpt, nodeForErrorContext);
            return void 0;
          }
          parameters.selector = this._parseMemberSelector(tokenReader, parameters.colonExcerpt, nodeForErrorContext);
          if (!parameters.selector) {
            return void 0;
          }
          parameters.spacingAfterSelectorExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        } else {
          if (parameters.leftParenthesisExcerpt) {
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceMissingColon, "Expecting a colon after the identifier because the expression is in parentheses", parameters.leftParenthesisExcerpt, nodeForErrorContext);
            return void 0;
          }
        }
        if (parameters.leftParenthesisExcerpt) {
          if (tokenReader.peekTokenKind() !== TokenKind.RightParenthesis) {
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceMissingRightParen, "Expecting a matching right parenthesis", parameters.leftParenthesisExcerpt, nodeForErrorContext);
            return void 0;
          }
          tokenReader.readToken();
          parameters.rightParenthesisExcerpt = tokenReader.extractAccumulatedSequence();
          parameters.spacingAfterRightParenthesisExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        }
        return new DocMemberReference(parameters);
      };
      NodeParser2.prototype._parseMemberSymbol = function(tokenReader, nodeForErrorContext) {
        if (tokenReader.peekTokenKind() !== TokenKind.LeftSquareBracket) {
          throw new Error('Expecting "["');
        }
        tokenReader.readToken();
        var leftBracketExcerpt = tokenReader.extractAccumulatedSequence();
        var spacingAfterLeftBracketExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        var declarationReference = this._parseDeclarationReference(tokenReader, leftBracketExcerpt, nodeForErrorContext);
        if (!declarationReference) {
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceSymbolSyntax, "Missing declaration reference in symbol reference", leftBracketExcerpt, nodeForErrorContext);
          return void 0;
        }
        if (tokenReader.peekTokenKind() !== TokenKind.RightSquareBracket) {
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceMissingRightBracket, "Missing closing square bracket for symbol reference", leftBracketExcerpt, nodeForErrorContext);
          return void 0;
        }
        tokenReader.readToken();
        var rightBracketExcerpt = tokenReader.extractAccumulatedSequence();
        return new DocMemberSymbol({
          parsed: true,
          configuration: this._configuration,
          leftBracketExcerpt,
          spacingAfterLeftBracketExcerpt,
          symbolReference: declarationReference,
          rightBracketExcerpt
        });
      };
      NodeParser2.prototype._parseMemberIdentifier = function(tokenReader, tokenSequenceForErrorContext, nodeForErrorContext) {
        var leftQuoteExcerpt = void 0;
        var rightQuoteExcerpt = void 0;
        if (tokenReader.peekTokenKind() === TokenKind.DoubleQuote) {
          tokenReader.readToken();
          leftQuoteExcerpt = tokenReader.extractAccumulatedSequence();
          while (tokenReader.peekTokenKind() !== TokenKind.DoubleQuote) {
            if (tokenReader.peekTokenKind() === TokenKind.EndOfInput) {
              this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceMissingQuote, "Unexpected end of input inside quoted member identifier", leftQuoteExcerpt, nodeForErrorContext);
              return void 0;
            }
            tokenReader.readToken();
          }
          if (tokenReader.isAccumulatedSequenceEmpty()) {
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceEmptyIdentifier, "The quoted identifier cannot be empty", leftQuoteExcerpt, nodeForErrorContext);
            return void 0;
          }
          var identifierExcerpt = tokenReader.extractAccumulatedSequence();
          tokenReader.readToken();
          rightQuoteExcerpt = tokenReader.extractAccumulatedSequence();
          return new DocMemberIdentifier({
            parsed: true,
            configuration: this._configuration,
            leftQuoteExcerpt,
            identifierExcerpt,
            rightQuoteExcerpt
          });
        } else {
          var done = false;
          while (!done) {
            switch (tokenReader.peekTokenKind()) {
              case TokenKind.AsciiWord:
              case TokenKind.DollarSign:
                tokenReader.readToken();
                break;
              default:
                done = true;
                break;
            }
          }
          if (tokenReader.isAccumulatedSequenceEmpty()) {
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceMissingIdentifier, "Syntax error in declaration reference: expecting a member identifier", tokenSequenceForErrorContext, nodeForErrorContext);
            return void 0;
          }
          var identifierExcerpt = tokenReader.extractAccumulatedSequence();
          var identifier = identifierExcerpt.toString();
          var explanation = StringChecks.explainIfInvalidUnquotedMemberIdentifier(identifier);
          if (explanation) {
            this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceUnquotedIdentifier, explanation, identifierExcerpt, nodeForErrorContext);
            return void 0;
          }
          return new DocMemberIdentifier({
            parsed: true,
            configuration: this._configuration,
            leftQuoteExcerpt,
            identifierExcerpt,
            rightQuoteExcerpt
          });
        }
      };
      NodeParser2.prototype._parseMemberSelector = function(tokenReader, tokenSequenceForErrorContext, nodeForErrorContext) {
        if (tokenReader.peekTokenKind() !== TokenKind.AsciiWord) {
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceMissingLabel, "Expecting a selector label after the colon", tokenSequenceForErrorContext, nodeForErrorContext);
        }
        var selector = tokenReader.readToken().toString();
        var selectorExcerpt = tokenReader.extractAccumulatedSequence();
        var docMemberSelector = new DocMemberSelector({
          parsed: true,
          configuration: this._configuration,
          selectorExcerpt,
          selector
        });
        if (docMemberSelector.errorMessage) {
          this._parserContext.log.addMessageForTokenSequence(TSDocMessageId.ReferenceSelectorSyntax, docMemberSelector.errorMessage, selectorExcerpt, nodeForErrorContext);
          return void 0;
        }
        return docMemberSelector;
      };
      NodeParser2.prototype._parseHtmlStartTag = function(tokenReader) {
        tokenReader.assertAccumulatedSequenceIsEmpty();
        var marker = tokenReader.createMarker();
        var lessThanToken = tokenReader.readToken();
        if (lessThanToken.kind !== TokenKind.LessThan) {
          throw new Error('Expecting an HTML tag starting with "<"');
        }
        var openingDelimiterExcerpt = tokenReader.extractAccumulatedSequence();
        var nameExcerpt = this._parseHtmlName(tokenReader);
        if (isFailure(nameExcerpt)) {
          return this._backtrackAndCreateErrorForFailure(tokenReader, marker, "Invalid HTML element: ", nameExcerpt);
        }
        var spacingAfterNameExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        var htmlAttributes = [];
        while (tokenReader.peekTokenKind() === TokenKind.AsciiWord) {
          var attributeNode = this._parseHtmlAttribute(tokenReader);
          if (isFailure(attributeNode)) {
            return this._backtrackAndCreateErrorForFailure(tokenReader, marker, "The HTML element has an invalid attribute: ", attributeNode);
          }
          htmlAttributes.push(attributeNode);
        }
        tokenReader.assertAccumulatedSequenceIsEmpty();
        var endDelimiterMarker = tokenReader.createMarker();
        var selfClosingTag = false;
        if (tokenReader.peekTokenKind() === TokenKind.Slash) {
          tokenReader.readToken();
          selfClosingTag = true;
        }
        if (tokenReader.peekTokenKind() !== TokenKind.GreaterThan) {
          var failure = this._createFailureForTokensSince(tokenReader, TSDocMessageId.HtmlTagMissingGreaterThan, 'Expecting an attribute or ">" or "/>"', endDelimiterMarker);
          return this._backtrackAndCreateErrorForFailure(tokenReader, marker, "The HTML tag has invalid syntax: ", failure);
        }
        tokenReader.readToken();
        var closingDelimiterExcerpt = tokenReader.extractAccumulatedSequence();
        return new DocHtmlStartTag({
          parsed: true,
          configuration: this._configuration,
          openingDelimiterExcerpt,
          nameExcerpt,
          spacingAfterNameExcerpt,
          htmlAttributes,
          selfClosingTag,
          closingDelimiterExcerpt
        });
      };
      NodeParser2.prototype._parseHtmlAttribute = function(tokenReader) {
        tokenReader.assertAccumulatedSequenceIsEmpty();
        var nameExcerpt = this._parseHtmlName(tokenReader);
        if (isFailure(nameExcerpt)) {
          return nameExcerpt;
        }
        var spacingAfterNameExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        if (tokenReader.peekTokenKind() !== TokenKind.Equals) {
          return this._createFailureForToken(tokenReader, TSDocMessageId.HtmlTagMissingEquals, 'Expecting "=" after HTML attribute name');
        }
        tokenReader.readToken();
        var equalsExcerpt = tokenReader.extractAccumulatedSequence();
        var spacingAfterEqualsExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        var attributeValue = this._parseHtmlString(tokenReader);
        if (isFailure(attributeValue)) {
          return attributeValue;
        }
        var valueExcerpt = tokenReader.extractAccumulatedSequence();
        var spacingAfterValueExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        return new DocHtmlAttribute({
          parsed: true,
          configuration: this._configuration,
          nameExcerpt,
          spacingAfterNameExcerpt,
          equalsExcerpt,
          spacingAfterEqualsExcerpt,
          valueExcerpt,
          spacingAfterValueExcerpt
        });
      };
      NodeParser2.prototype._parseHtmlString = function(tokenReader) {
        var marker = tokenReader.createMarker();
        var quoteTokenKind = tokenReader.peekTokenKind();
        if (quoteTokenKind !== TokenKind.DoubleQuote && quoteTokenKind !== TokenKind.SingleQuote) {
          return this._createFailureForToken(tokenReader, TSDocMessageId.HtmlTagMissingString, "Expecting an HTML string starting with a single-quote or double-quote character");
        }
        tokenReader.readToken();
        var textWithoutQuotes = "";
        for (; ; ) {
          var peekedTokenKind = tokenReader.peekTokenKind();
          if (peekedTokenKind === quoteTokenKind) {
            tokenReader.readToken();
            break;
          }
          if (peekedTokenKind === TokenKind.EndOfInput || peekedTokenKind === TokenKind.Newline) {
            return this._createFailureForToken(tokenReader, TSDocMessageId.HtmlStringMissingQuote, "The HTML string is missing its closing quote", marker);
          }
          textWithoutQuotes += tokenReader.readToken().toString();
        }
        if (tokenReader.peekTokenKind() === TokenKind.AsciiWord) {
          return this._createFailureForToken(tokenReader, TSDocMessageId.TextAfterHtmlString, "The next character after a closing quote must be spacing or punctuation");
        }
        return textWithoutQuotes;
      };
      NodeParser2.prototype._parseHtmlEndTag = function(tokenReader) {
        tokenReader.assertAccumulatedSequenceIsEmpty();
        var marker = tokenReader.createMarker();
        var lessThanToken = tokenReader.peekToken();
        if (lessThanToken.kind !== TokenKind.LessThan) {
          return this._backtrackAndCreateError(tokenReader, marker, TSDocMessageId.MissingHtmlEndTag, 'Expecting an HTML tag starting with "</"');
        }
        tokenReader.readToken();
        var slashToken = tokenReader.peekToken();
        if (slashToken.kind !== TokenKind.Slash) {
          return this._backtrackAndCreateError(tokenReader, marker, TSDocMessageId.MissingHtmlEndTag, 'Expecting an HTML tag starting with "</"');
        }
        tokenReader.readToken();
        var openingDelimiterExcerpt = tokenReader.extractAccumulatedSequence();
        var nameExcerpt = this._parseHtmlName(tokenReader);
        if (isFailure(nameExcerpt)) {
          return this._backtrackAndCreateErrorForFailure(tokenReader, marker, "Expecting an HTML element name: ", nameExcerpt);
        }
        var spacingAfterNameExcerpt = this._tryReadSpacingAndNewlines(tokenReader);
        if (tokenReader.peekTokenKind() !== TokenKind.GreaterThan) {
          var failure = this._createFailureForToken(tokenReader, TSDocMessageId.HtmlTagMissingGreaterThan, 'Expecting a closing ">" for the HTML tag');
          return this._backtrackAndCreateErrorForFailure(tokenReader, marker, "", failure);
        }
        tokenReader.readToken();
        var closingDelimiterExcerpt = tokenReader.extractAccumulatedSequence();
        return new DocHtmlEndTag({
          parsed: true,
          configuration: this._configuration,
          openingDelimiterExcerpt,
          nameExcerpt,
          spacingAfterNameExcerpt,
          closingDelimiterExcerpt
        });
      };
      NodeParser2.prototype._parseHtmlName = function(tokenReader) {
        var marker = tokenReader.createMarker();
        if (tokenReader.peekTokenKind() === TokenKind.Spacing) {
          return this._createFailureForTokensSince(tokenReader, TSDocMessageId.MalformedHtmlName, "A space is not allowed here", marker);
        }
        var done = false;
        while (!done) {
          switch (tokenReader.peekTokenKind()) {
            case TokenKind.Hyphen:
            case TokenKind.Period:
            case TokenKind.AsciiWord:
              tokenReader.readToken();
              break;
            default:
              done = true;
              break;
          }
        }
        var excerpt = tokenReader.tryExtractAccumulatedSequence();
        if (!excerpt) {
          return this._createFailureForToken(tokenReader, TSDocMessageId.MalformedHtmlName, "Expecting an HTML name");
        }
        var htmlName = excerpt.toString();
        var explanation = StringChecks.explainIfInvalidHtmlName(htmlName);
        if (explanation) {
          return this._createFailureForTokensSince(tokenReader, TSDocMessageId.MalformedHtmlName, explanation, marker);
        }
        if (this._configuration.validation.reportUnsupportedHtmlElements && !this._configuration.isHtmlElementSupported(htmlName)) {
          return this._createFailureForToken(tokenReader, TSDocMessageId.UnsupportedHtmlElementName, "The HTML element name " + JSON.stringify(htmlName) + " is not defined by your TSDoc configuration", marker);
        }
        return excerpt;
      };
      NodeParser2.prototype._parseFencedCode = function(tokenReader) {
        tokenReader.assertAccumulatedSequenceIsEmpty();
        var startMarker = tokenReader.createMarker();
        var endOfOpeningDelimiterMarker = startMarker + 2;
        switch (tokenReader.peekPreviousTokenKind()) {
          case TokenKind.Newline:
          case TokenKind.EndOfInput:
            break;
          default:
            return this._backtrackAndCreateErrorRange(
              tokenReader,
              startMarker,
              // include the three backticks so they don't get reinterpreted as a code span
              endOfOpeningDelimiterMarker,
              TSDocMessageId.CodeFenceOpeningIndent,
              "The opening backtick for a code fence must appear at the start of the line"
            );
        }
        var openingDelimiter = "";
        openingDelimiter += tokenReader.readToken();
        openingDelimiter += tokenReader.readToken();
        openingDelimiter += tokenReader.readToken();
        if (openingDelimiter !== "```") {
          throw new Error("Expecting three backticks");
        }
        var openingFenceExcerpt = tokenReader.extractAccumulatedSequence();
        while (tokenReader.peekTokenKind() === TokenKind.Spacing) {
          tokenReader.readToken();
        }
        var spacingAfterOpeningFenceExcerpt = tokenReader.tryExtractAccumulatedSequence();
        var done = false;
        var startOfPaddingMarker = void 0;
        while (!done) {
          switch (tokenReader.peekTokenKind()) {
            case TokenKind.Spacing:
            case TokenKind.Newline:
              if (startOfPaddingMarker === void 0) {
                startOfPaddingMarker = tokenReader.createMarker();
              }
              if (tokenReader.peekTokenKind() === TokenKind.Newline) {
                done = true;
              }
              tokenReader.readToken();
              break;
            case TokenKind.Backtick:
              var failure = this._createFailureForToken(tokenReader, TSDocMessageId.CodeFenceSpecifierSyntax, "The language specifier cannot contain backtick characters");
              return this._backtrackAndCreateErrorRangeForFailure(tokenReader, startMarker, endOfOpeningDelimiterMarker, "Error parsing code fence: ", failure);
            case TokenKind.EndOfInput:
              var failure2 = this._createFailureForToken(tokenReader, TSDocMessageId.CodeFenceMissingDelimiter, "Missing closing delimiter");
              return this._backtrackAndCreateErrorRangeForFailure(tokenReader, startMarker, endOfOpeningDelimiterMarker, "Error parsing code fence: ", failure2);
            default:
              startOfPaddingMarker = void 0;
              tokenReader.readToken();
              break;
          }
        }
        var restOfLineExcerpt = tokenReader.extractAccumulatedSequence();
        var languageExcerpt = restOfLineExcerpt.getNewSequence(restOfLineExcerpt.startIndex, startOfPaddingMarker);
        var spacingAfterLanguageExcerpt = restOfLineExcerpt.getNewSequence(startOfPaddingMarker, restOfLineExcerpt.endIndex);
        var codeEndMarker = -1;
        var closingFenceStartMarker = -1;
        done = false;
        var tokenBeforeDelimiter;
        while (!done) {
          switch (tokenReader.peekTokenKind()) {
            case TokenKind.EndOfInput:
              var failure2 = this._createFailureForToken(tokenReader, TSDocMessageId.CodeFenceMissingDelimiter, "Missing closing delimiter");
              return this._backtrackAndCreateErrorRangeForFailure(tokenReader, startMarker, endOfOpeningDelimiterMarker, "Error parsing code fence: ", failure2);
            case TokenKind.Newline:
              tokenBeforeDelimiter = tokenReader.readToken();
              codeEndMarker = tokenReader.createMarker();
              while (tokenReader.peekTokenKind() === TokenKind.Spacing) {
                tokenBeforeDelimiter = tokenReader.readToken();
              }
              if (tokenReader.peekTokenKind() !== TokenKind.Backtick) {
                break;
              }
              closingFenceStartMarker = tokenReader.createMarker();
              tokenReader.readToken();
              if (tokenReader.peekTokenKind() !== TokenKind.Backtick) {
                break;
              }
              tokenReader.readToken();
              if (tokenReader.peekTokenKind() !== TokenKind.Backtick) {
                break;
              }
              tokenReader.readToken();
              done = true;
              break;
            default:
              tokenReader.readToken();
              break;
          }
        }
        if (tokenBeforeDelimiter.kind !== TokenKind.Newline) {
          this._parserContext.log.addMessageForTextRange(TSDocMessageId.CodeFenceClosingIndent, "The closing delimiter for a code fence must not be indented", tokenBeforeDelimiter.range);
        }
        var codeAndDelimiterExcerpt = tokenReader.extractAccumulatedSequence();
        var codeExcerpt = codeAndDelimiterExcerpt.getNewSequence(codeAndDelimiterExcerpt.startIndex, codeEndMarker);
        var spacingBeforeClosingFenceExcerpt = codeAndDelimiterExcerpt.getNewSequence(codeEndMarker, closingFenceStartMarker);
        var closingFenceExcerpt = codeAndDelimiterExcerpt.getNewSequence(closingFenceStartMarker, codeAndDelimiterExcerpt.endIndex);
        done = false;
        while (!done) {
          switch (tokenReader.peekTokenKind()) {
            case TokenKind.Spacing:
              tokenReader.readToken();
              break;
            case TokenKind.Newline:
              done = true;
              tokenReader.readToken();
              break;
            case TokenKind.EndOfInput:
              done = true;
              break;
            default:
              this._parserContext.log.addMessageForTextRange(TSDocMessageId.CodeFenceClosingSyntax, "Unexpected characters after closing delimiter for code fence", tokenReader.peekToken().range);
              done = true;
              break;
          }
        }
        var spacingAfterClosingFenceExcerpt = tokenReader.tryExtractAccumulatedSequence();
        return new DocFencedCode({
          parsed: true,
          configuration: this._configuration,
          openingFenceExcerpt,
          spacingAfterOpeningFenceExcerpt,
          languageExcerpt,
          spacingAfterLanguageExcerpt,
          codeExcerpt,
          spacingBeforeClosingFenceExcerpt,
          closingFenceExcerpt,
          spacingAfterClosingFenceExcerpt
        });
      };
      NodeParser2.prototype._parseCodeSpan = function(tokenReader) {
        tokenReader.assertAccumulatedSequenceIsEmpty();
        var marker = tokenReader.createMarker();
        if (tokenReader.peekTokenKind() !== TokenKind.Backtick) {
          throw new Error('Expecting a code span starting with a backtick character "`"');
        }
        tokenReader.readToken();
        var openingDelimiterExcerpt = tokenReader.extractAccumulatedSequence();
        var codeExcerpt = void 0;
        var closingDelimiterExcerpt = void 0;
        for (; ; ) {
          var peekedTokenKind = tokenReader.peekTokenKind();
          if (peekedTokenKind === TokenKind.Backtick) {
            if (tokenReader.isAccumulatedSequenceEmpty()) {
              return this._backtrackAndCreateErrorRange(tokenReader, marker, marker + 1, TSDocMessageId.CodeSpanEmpty, "A code span must contain at least one character between the backticks");
            }
            codeExcerpt = tokenReader.extractAccumulatedSequence();
            tokenReader.readToken();
            closingDelimiterExcerpt = tokenReader.extractAccumulatedSequence();
            break;
          }
          if (peekedTokenKind === TokenKind.EndOfInput || peekedTokenKind === TokenKind.Newline) {
            return this._backtrackAndCreateError(tokenReader, marker, TSDocMessageId.CodeSpanMissingDelimiter, "The code span is missing its closing backtick");
          }
          tokenReader.readToken();
        }
        return new DocCodeSpan({
          parsed: true,
          configuration: this._configuration,
          openingDelimiterExcerpt,
          codeExcerpt,
          closingDelimiterExcerpt
        });
      };
      NodeParser2.prototype._tryReadSpacingAndNewlines = function(tokenReader) {
        var done = false;
        do {
          switch (tokenReader.peekTokenKind()) {
            case TokenKind.Spacing:
            case TokenKind.Newline:
              tokenReader.readToken();
              break;
            default:
              done = true;
              break;
          }
        } while (!done);
        return tokenReader.tryExtractAccumulatedSequence();
      };
      NodeParser2.prototype._createError = function(tokenReader, messageId, errorMessage) {
        tokenReader.readToken();
        var textExcerpt = tokenReader.extractAccumulatedSequence();
        var docErrorText = new DocErrorText({
          parsed: true,
          configuration: this._configuration,
          textExcerpt,
          messageId,
          errorMessage,
          errorLocation: textExcerpt
        });
        this._parserContext.log.addMessageForDocErrorText(docErrorText);
        return docErrorText;
      };
      NodeParser2.prototype._backtrackAndCreateError = function(tokenReader, marker, messageId, errorMessage) {
        tokenReader.backtrackToMarker(marker);
        return this._createError(tokenReader, messageId, errorMessage);
      };
      NodeParser2.prototype._backtrackAndCreateErrorRange = function(tokenReader, errorStartMarker, errorInclusiveEndMarker, messageId, errorMessage) {
        tokenReader.backtrackToMarker(errorStartMarker);
        while (tokenReader.createMarker() !== errorInclusiveEndMarker) {
          tokenReader.readToken();
        }
        if (tokenReader.peekTokenKind() !== TokenKind.EndOfInput) {
          tokenReader.readToken();
        }
        var textExcerpt = tokenReader.extractAccumulatedSequence();
        var docErrorText = new DocErrorText({
          parsed: true,
          configuration: this._configuration,
          textExcerpt,
          messageId,
          errorMessage,
          errorLocation: textExcerpt
        });
        this._parserContext.log.addMessageForDocErrorText(docErrorText);
        return docErrorText;
      };
      NodeParser2.prototype._backtrackAndCreateErrorForFailure = function(tokenReader, marker, errorMessagePrefix, failure) {
        tokenReader.backtrackToMarker(marker);
        tokenReader.readToken();
        var textExcerpt = tokenReader.extractAccumulatedSequence();
        var docErrorText = new DocErrorText({
          parsed: true,
          configuration: this._configuration,
          textExcerpt,
          messageId: failure.failureMessageId,
          errorMessage: errorMessagePrefix + failure.failureMessage,
          errorLocation: failure.failureLocation
        });
        this._parserContext.log.addMessageForDocErrorText(docErrorText);
        return docErrorText;
      };
      NodeParser2.prototype._backtrackAndCreateErrorRangeForFailure = function(tokenReader, errorStartMarker, errorInclusiveEndMarker, errorMessagePrefix, failure) {
        tokenReader.backtrackToMarker(errorStartMarker);
        while (tokenReader.createMarker() !== errorInclusiveEndMarker) {
          tokenReader.readToken();
        }
        if (tokenReader.peekTokenKind() !== TokenKind.EndOfInput) {
          tokenReader.readToken();
        }
        var textExcerpt = tokenReader.extractAccumulatedSequence();
        var docErrorText = new DocErrorText({
          parsed: true,
          configuration: this._configuration,
          textExcerpt,
          messageId: failure.failureMessageId,
          errorMessage: errorMessagePrefix + failure.failureMessage,
          errorLocation: failure.failureLocation
        });
        this._parserContext.log.addMessageForDocErrorText(docErrorText);
        return docErrorText;
      };
      NodeParser2.prototype._createFailureForToken = function(tokenReader, failureMessageId, failureMessage, tokenMarker) {
        if (!tokenMarker) {
          tokenMarker = tokenReader.createMarker();
        }
        var tokenSequence = new TokenSequence({
          parserContext: this._parserContext,
          startIndex: tokenMarker,
          endIndex: tokenMarker + 1
        });
        return {
          failureMessageId,
          failureMessage,
          failureLocation: tokenSequence
        };
      };
      NodeParser2.prototype._createFailureForTokensSince = function(tokenReader, failureMessageId, failureMessage, startMarker) {
        var endMarker = tokenReader.createMarker();
        if (endMarker < startMarker) {
          throw new Error("Invalid startMarker");
        }
        if (endMarker === startMarker) {
          ++endMarker;
        }
        var tokenSequence = new TokenSequence({
          parserContext: this._parserContext,
          startIndex: startMarker,
          endIndex: endMarker
        });
        return {
          failureMessageId,
          failureMessage,
          failureLocation: tokenSequence
        };
      };
      return NodeParser2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/ParagraphSplitter.js
var ParagraphSplitter;
var init_ParagraphSplitter = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/ParagraphSplitter.js"() {
    "use strict";
    init_nodes();
    ParagraphSplitter = /** @class */
    function() {
      function ParagraphSplitter2() {
      }
      ParagraphSplitter2.splitParagraphs = function(node) {
        if (node instanceof DocSection) {
          ParagraphSplitter2.splitParagraphsForSection(node);
        } else {
          for (var _i = 0, _a = node.getChildNodes(); _i < _a.length; _i++) {
            var childNode = _a[_i];
            ParagraphSplitter2.splitParagraphs(childNode);
          }
        }
      };
      ParagraphSplitter2.splitParagraphsForSection = function(docSection) {
        var inputNodes = docSection.nodes;
        var outputNodes = [];
        for (var _i = 0, inputNodes_1 = inputNodes; _i < inputNodes_1.length; _i++) {
          var oldNode = inputNodes_1[_i];
          if (oldNode.kind === DocNodeKind.Paragraph) {
            ParagraphSplitter2._splitParagraph(oldNode, outputNodes);
          } else {
            outputNodes.push(oldNode);
          }
        }
        docSection.clearNodes();
        docSection.appendNodes(outputNodes);
      };
      ParagraphSplitter2._splitParagraph = function(oldParagraph, outputNodes) {
        var inputParagraphNodes = oldParagraph.nodes;
        var currentParagraph = new DocParagraph({ configuration: oldParagraph.configuration });
        outputNodes.push(currentParagraph);
        var state = 0;
        var currentIndex = 0;
        while (currentIndex < inputParagraphNodes.length) {
          var isBlankLine = true;
          var lineEndIndex = currentIndex;
          do {
            var node = inputParagraphNodes[lineEndIndex++];
            if (node.kind === DocNodeKind.SoftBreak) {
              break;
            }
            if (isBlankLine) {
              if (!this._isWhitespace(node)) {
                isBlankLine = false;
              }
            }
          } while (lineEndIndex < inputParagraphNodes.length);
          switch (state) {
            case 0:
              if (!isBlankLine) {
                state = 1;
              }
              break;
            case 1:
              if (isBlankLine) {
                state = 2;
              }
              break;
            case 2:
              if (!isBlankLine) {
                currentParagraph = new DocParagraph({ configuration: oldParagraph.configuration });
                outputNodes.push(currentParagraph);
                state = 1;
              }
              break;
          }
          for (var i = currentIndex; i < lineEndIndex; ++i) {
            currentParagraph.appendNode(inputParagraphNodes[i]);
          }
          currentIndex = lineEndIndex;
        }
      };
      ParagraphSplitter2._isWhitespace = function(node) {
        switch (node.kind) {
          case DocNodeKind.PlainText:
            var docPlainText = node;
            return ParagraphSplitter2._whitespaceRegExp.test(docPlainText.text);
          default:
            return false;
        }
      };
      ParagraphSplitter2._whitespaceRegExp = /^\s*$/;
      return ParagraphSplitter2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/TSDocParser.js
var TSDocParser;
var init_TSDocParser = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/parser/TSDocParser.js"() {
    "use strict";
    init_TextRange();
    init_ParserContext();
    init_LineExtractor();
    init_Tokenizer();
    init_NodeParser();
    init_TSDocConfiguration();
    init_ParagraphSplitter();
    TSDocParser = /** @class */
    function() {
      function TSDocParser2(configuration) {
        if (configuration) {
          this.configuration = configuration;
        } else {
          this.configuration = new TSDocConfiguration();
        }
      }
      TSDocParser2.prototype.parseString = function(text) {
        return this.parseRange(TextRange.fromString(text));
      };
      TSDocParser2.prototype.parseRange = function(range) {
        var parserContext = new ParserContext(this.configuration, range);
        if (LineExtractor.extract(parserContext)) {
          parserContext.tokens = Tokenizer.readTokens(parserContext.lines);
          var nodeParser = new NodeParser(parserContext);
          nodeParser.parse();
          ParagraphSplitter.splitParagraphs(parserContext.docComment);
        }
        return parserContext;
      };
      return TSDocParser2;
    }();
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  DocBlock: () => DocBlock,
  DocBlockTag: () => DocBlockTag,
  DocCodeSpan: () => DocCodeSpan,
  DocComment: () => DocComment,
  DocDeclarationReference: () => DocDeclarationReference,
  DocErrorText: () => DocErrorText,
  DocEscapedText: () => DocEscapedText,
  DocExcerpt: () => DocExcerpt,
  DocFencedCode: () => DocFencedCode,
  DocHtmlAttribute: () => DocHtmlAttribute,
  DocHtmlEndTag: () => DocHtmlEndTag,
  DocHtmlStartTag: () => DocHtmlStartTag,
  DocInheritDocTag: () => DocInheritDocTag,
  DocInlineTag: () => DocInlineTag,
  DocInlineTagBase: () => DocInlineTagBase,
  DocLinkTag: () => DocLinkTag,
  DocMemberIdentifier: () => DocMemberIdentifier,
  DocMemberReference: () => DocMemberReference,
  DocMemberSelector: () => DocMemberSelector,
  DocMemberSymbol: () => DocMemberSymbol,
  DocNode: () => DocNode,
  DocNodeContainer: () => DocNodeContainer,
  DocNodeKind: () => DocNodeKind,
  DocNodeManager: () => DocNodeManager,
  DocNodeTransforms: () => DocNodeTransforms,
  DocParagraph: () => DocParagraph,
  DocParamBlock: () => DocParamBlock,
  DocParamCollection: () => DocParamCollection,
  DocPlainText: () => DocPlainText,
  DocSection: () => DocSection,
  DocSoftBreak: () => DocSoftBreak,
  EscapeStyle: () => EscapeStyle,
  ExcerptKind: () => ExcerptKind,
  ModifierTagSet: () => ModifierTagSet,
  ParserContext: () => ParserContext,
  ParserMessage: () => ParserMessage,
  ParserMessageLog: () => ParserMessageLog,
  PlainTextEmitter: () => PlainTextEmitter,
  SelectorKind: () => SelectorKind,
  StandardModifierTagSet: () => StandardModifierTagSet,
  StandardTags: () => StandardTags,
  Standardization: () => Standardization,
  StringBuilder: () => StringBuilder,
  TSDocConfiguration: () => TSDocConfiguration,
  TSDocEmitter: () => TSDocEmitter,
  TSDocMessageId: () => TSDocMessageId,
  TSDocParser: () => TSDocParser,
  TSDocTagDefinition: () => TSDocTagDefinition,
  TSDocTagSyntaxKind: () => TSDocTagSyntaxKind,
  TSDocValidationConfiguration: () => TSDocValidationConfiguration,
  TextRange: () => TextRange,
  Token: () => Token,
  TokenKind: () => TokenKind,
  TokenSequence: () => TokenSequence
});
var init_lib = __esm({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib/index.js"() {
    "use strict";
    init_DocNodeManager();
    init_TSDocConfiguration();
    init_TSDocTagDefinition();
    init_TSDocValidationConfiguration();
    init_StandardTags();
    init_Standardization();
    init_StandardModifierTagSet();
    init_ModifierTagSet();
    init_PlainTextEmitter();
    init_StringBuilder();
    init_TSDocEmitter();
    init_nodes();
    init_ParserContext();
    init_ParserMessage();
    init_ParserMessageLog();
    init_TextRange();
    init_Token();
    init_TokenSequence();
    init_TSDocMessageId();
    init_TSDocParser();
    init_DocNodeTransforms();
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/aedoc/AedocDefinitions.js
var require_AedocDefinitions = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/aedoc/AedocDefinitions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AedocDefinitions = void 0;
    var tsdoc_1 = (init_lib(), __toCommonJS(lib_exports));
    var AedocDefinitions = class _AedocDefinitions {
      static get tsdocConfiguration() {
        if (!_AedocDefinitions._tsdocConfiguration) {
          const configuration = new tsdoc_1.TSDocConfiguration();
          configuration.addTagDefinitions([
            _AedocDefinitions.betaDocumentation,
            _AedocDefinitions.internalRemarks,
            _AedocDefinitions.preapprovedTag
          ], true);
          configuration.setSupportForTags([
            tsdoc_1.StandardTags.alpha,
            tsdoc_1.StandardTags.beta,
            tsdoc_1.StandardTags.decorator,
            tsdoc_1.StandardTags.defaultValue,
            tsdoc_1.StandardTags.deprecated,
            tsdoc_1.StandardTags.eventProperty,
            tsdoc_1.StandardTags.example,
            tsdoc_1.StandardTags.inheritDoc,
            tsdoc_1.StandardTags.internal,
            tsdoc_1.StandardTags.link,
            tsdoc_1.StandardTags.override,
            tsdoc_1.StandardTags.packageDocumentation,
            tsdoc_1.StandardTags.param,
            tsdoc_1.StandardTags.privateRemarks,
            tsdoc_1.StandardTags.public,
            tsdoc_1.StandardTags.readonly,
            tsdoc_1.StandardTags.remarks,
            tsdoc_1.StandardTags.returns,
            tsdoc_1.StandardTags.sealed,
            tsdoc_1.StandardTags.throws,
            tsdoc_1.StandardTags.virtual
          ], true);
          _AedocDefinitions._tsdocConfiguration = configuration;
        }
        return _AedocDefinitions._tsdocConfiguration;
      }
    };
    exports2.AedocDefinitions = AedocDefinitions;
    AedocDefinitions.betaDocumentation = new tsdoc_1.TSDocTagDefinition({
      tagName: "@betaDocumentation",
      syntaxKind: tsdoc_1.TSDocTagSyntaxKind.ModifierTag
    });
    AedocDefinitions.internalRemarks = new tsdoc_1.TSDocTagDefinition({
      tagName: "@internalRemarks",
      syntaxKind: tsdoc_1.TSDocTagSyntaxKind.BlockTag
    });
    AedocDefinitions.preapprovedTag = new tsdoc_1.TSDocTagDefinition({
      tagName: "@preapproved",
      syntaxKind: tsdoc_1.TSDocTagSyntaxKind.ModifierTag
    });
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/aedoc/ReleaseTag.js
var require_ReleaseTag = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/aedoc/ReleaseTag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReleaseTag = void 0;
    var ReleaseTag;
    (function(ReleaseTag2) {
      ReleaseTag2[ReleaseTag2["None"] = 0] = "None";
      ReleaseTag2[ReleaseTag2["Internal"] = 1] = "Internal";
      ReleaseTag2[ReleaseTag2["Alpha"] = 2] = "Alpha";
      ReleaseTag2[ReleaseTag2["Beta"] = 3] = "Beta";
      ReleaseTag2[ReleaseTag2["Public"] = 4] = "Public";
    })(ReleaseTag || (exports2.ReleaseTag = ReleaseTag = {}));
    (function(ReleaseTag2) {
      function getTagName(releaseTag) {
        switch (releaseTag) {
          case ReleaseTag2.None:
            return "(none)";
          case ReleaseTag2.Internal:
            return "@internal";
          case ReleaseTag2.Alpha:
            return "@alpha";
          case ReleaseTag2.Beta:
            return "@beta";
          case ReleaseTag2.Public:
            return "@public";
          default:
            throw new Error("Unsupported release tag");
        }
      }
      ReleaseTag2.getTagName = getTagName;
      function compare(a, b) {
        return a - b;
      }
      ReleaseTag2.compare = compare;
    })(ReleaseTag || (exports2.ReleaseTag = ReleaseTag = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib-commonjs/parser/StringChecks.js
var require_StringChecks = __commonJS({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib-commonjs/parser/StringChecks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StringChecks = void 0;
    var StringChecks2 = (
      /** @class */
      function() {
        function StringChecks3() {
        }
        StringChecks3.explainIfInvalidTSDocTagName = function(tagName) {
          if (tagName[0] !== "@") {
            return 'A TSDoc tag name must start with an "@" symbol';
          }
          if (!StringChecks3._tsdocTagNameRegExp.test(tagName)) {
            return "A TSDoc tag name must start with a letter and contain only letters and numbers";
          }
          return void 0;
        };
        StringChecks3.validateTSDocTagName = function(tagName) {
          var explanation = StringChecks3.explainIfInvalidTSDocTagName(tagName);
          if (explanation) {
            throw new Error(explanation);
          }
        };
        StringChecks3.explainIfInvalidLinkUrl = function(url) {
          if (url.length === 0) {
            return "The URL cannot be empty";
          }
          if (!StringChecks3._urlSchemeRegExp.test(url)) {
            return 'An @link URL must begin with a scheme comprised only of letters and numbers followed by "://". (For general URLs, use an HTML "<a>" tag instead.)';
          }
          if (!StringChecks3._urlSchemeAfterRegExp.test(url)) {
            return 'An @link URL must have at least one character after "://"';
          }
          return void 0;
        };
        StringChecks3.explainIfInvalidHtmlName = function(htmlName) {
          if (!StringChecks3._htmlNameRegExp.test(htmlName)) {
            return "An HTML name must be an ASCII letter followed by zero or more letters, digits, or hyphens";
          }
          return void 0;
        };
        StringChecks3.validateHtmlName = function(htmlName) {
          var explanation = StringChecks3.explainIfInvalidHtmlName(htmlName);
          if (explanation) {
            throw new Error(explanation);
          }
        };
        StringChecks3.explainIfInvalidPackageName = function(packageName) {
          if (packageName.length === 0) {
            return "The package name cannot be an empty string";
          }
          if (!StringChecks3._validPackageNameRegExp.test(packageName)) {
            return "The package name " + JSON.stringify(packageName) + " is not a valid package name";
          }
          return void 0;
        };
        StringChecks3.explainIfInvalidImportPath = function(importPath, prefixedByPackageName) {
          if (importPath.length > 0) {
            if (importPath.indexOf("//") >= 0) {
              return 'An import path must not contain "//"';
            }
            if (importPath[importPath.length - 1] === "/") {
              return 'An import path must not end with "/"';
            }
            if (!prefixedByPackageName) {
              if (importPath[0] === "/") {
                return 'An import path must not start with "/" unless prefixed by a package name';
              }
            }
          }
          return void 0;
        };
        StringChecks3.isSystemSelector = function(selector) {
          return StringChecks3._systemSelectors.has(selector);
        };
        StringChecks3.explainIfInvalidUnquotedIdentifier = function(identifier) {
          if (identifier.length === 0) {
            return "The identifier cannot be an empty string";
          }
          if (StringChecks3._identifierBadCharRegExp.test(identifier)) {
            return "The identifier cannot non-word characters";
          }
          if (StringChecks3._identifierNumberStartRegExp.test(identifier)) {
            return "The identifier must not start with a number";
          }
          return void 0;
        };
        StringChecks3.explainIfInvalidUnquotedMemberIdentifier = function(identifier) {
          var explanation = StringChecks3.explainIfInvalidUnquotedIdentifier(identifier);
          if (explanation !== void 0) {
            return explanation;
          }
          if (StringChecks3.isSystemSelector(identifier)) {
            return 'The identifier "' + identifier + '" must be quoted because it is a TSDoc system selector name';
          }
          return void 0;
        };
        StringChecks3._tsdocTagNameRegExp = /^@[a-z][a-z0-9]*$/i;
        StringChecks3._urlSchemeRegExp = /^[a-z][a-z0-9]*\:\/\//i;
        StringChecks3._urlSchemeAfterRegExp = /^[a-z][a-z0-9]*\:\/\/./i;
        StringChecks3._htmlNameRegExp = /^[a-z]+[a-z0-9\-]*$/i;
        StringChecks3._identifierBadCharRegExp = /[^a-z0-9_$]/i;
        StringChecks3._identifierNumberStartRegExp = /^[0-9]/;
        StringChecks3._validPackageNameRegExp = /^(?:@[a-z0-9\-_\.]+\/)?[a-z0-9\-_\.]+$/i;
        StringChecks3._systemSelectors = /* @__PURE__ */ new Set([
          // For classes:
          "instance",
          "static",
          "constructor",
          // For merged declarations:
          "class",
          "enum",
          "function",
          "interface",
          "namespace",
          "type",
          "variable"
        ]);
        return StringChecks3;
      }()
    );
    exports2.StringChecks = StringChecks2;
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib-commonjs/beta/DeclarationReference.js
var require_DeclarationReference = __commonJS({
  "../../node_modules/.pnpm/@microsoft+tsdoc@0.14.2/node_modules/@microsoft/tsdoc/lib-commonjs/beta/DeclarationReference.js"(exports2) {
    "use strict";
    var __extends29 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SymbolReference = exports2.ComponentNavigation = exports2.ComponentRoot = exports2.ComponentPathBase = exports2.ComponentReference = exports2.ComponentString = exports2.Component = exports2.GlobalSource = exports2.ModuleSource = exports2.DeclarationReference = void 0;
    var StringChecks_1 = require_StringChecks();
    var DeclarationReference = (
      /** @class */
      function() {
        function DeclarationReference2(source, navigation, symbol) {
          this._source = source;
          this._navigation = navigation;
          this._symbol = symbol;
        }
        Object.defineProperty(DeclarationReference2.prototype, "source", {
          get: function() {
            return this._source;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(DeclarationReference2.prototype, "navigation", {
          get: function() {
            if (!this._source || !this._symbol) {
              return void 0;
            }
            if (this._source === GlobalSource.instance) {
              return "~";
            }
            if (this._navigation === void 0) {
              return ".";
            }
            return this._navigation;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(DeclarationReference2.prototype, "symbol", {
          get: function() {
            return this._symbol;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(DeclarationReference2.prototype, "isEmpty", {
          get: function() {
            return this.source === void 0 && this.symbol === void 0;
          },
          enumerable: false,
          configurable: true
        });
        DeclarationReference2.parse = function(text) {
          var parser = new Parser(text);
          var reference = parser.parseDeclarationReference();
          if (parser.errors.length) {
            throw new SyntaxError("Invalid DeclarationReference '" + text + "':\n  " + parser.errors.join("\n  "));
          }
          if (!parser.eof) {
            throw new SyntaxError("Invalid DeclarationReference '" + text + "'");
          }
          return reference;
        };
        DeclarationReference2.parseComponent = function(text) {
          if (text[0] === "[") {
            return ComponentReference.parse(text);
          } else {
            return new ComponentString(text, true);
          }
        };
        DeclarationReference2.isWellFormedComponentString = function(text) {
          var scanner = new Scanner(text);
          return scanner.scan() === 16 ? scanner.scan() === 1 : scanner.token() === 17 ? scanner.scan() === 1 : scanner.token() === 1;
        };
        DeclarationReference2.escapeComponentString = function(text) {
          if (text.length === 0) {
            return '""';
          }
          var ch = text.charAt(0);
          if (ch === "[" || ch === '"' || !this.isWellFormedComponentString(text)) {
            return JSON.stringify(text);
          }
          return text;
        };
        DeclarationReference2.unescapeComponentString = function(text) {
          if (text.length >= 2 && text.charAt(0) === '"' && text.charAt(text.length - 1) === '"') {
            try {
              return JSON.parse(text);
            } catch (_a) {
              throw new SyntaxError("Invalid Component '" + text + "'");
            }
          }
          if (!this.isWellFormedComponentString(text)) {
            throw new SyntaxError("Invalid Component '" + text + "'");
          }
          return text;
        };
        DeclarationReference2.isWellFormedModuleSourceString = function(text) {
          var scanner = new Scanner(text + "!");
          return scanner.rescanModuleSource() === 18 && !scanner.stringIsUnterminated && scanner.scan() === 8 && scanner.scan() === 1;
        };
        DeclarationReference2.escapeModuleSourceString = function(text) {
          if (text.length === 0) {
            return '""';
          }
          var ch = text.charAt(0);
          if (ch === '"' || !this.isWellFormedModuleSourceString(text)) {
            return JSON.stringify(text);
          }
          return text;
        };
        DeclarationReference2.unescapeModuleSourceString = function(text) {
          if (text.length >= 2 && text.charAt(0) === '"' && text.charAt(text.length - 1) === '"') {
            try {
              return JSON.parse(text);
            } catch (_a) {
              throw new SyntaxError("Invalid Module source '" + text + "'");
            }
          }
          if (!this.isWellFormedModuleSourceString(text)) {
            throw new SyntaxError("Invalid Module source '" + text + "'");
          }
          return text;
        };
        DeclarationReference2.empty = function() {
          return new DeclarationReference2();
        };
        DeclarationReference2.package = function(packageName, importPath) {
          return new DeclarationReference2(ModuleSource.fromPackage(packageName, importPath));
        };
        DeclarationReference2.module = function(path, userEscaped) {
          return new DeclarationReference2(new ModuleSource(path, userEscaped));
        };
        DeclarationReference2.global = function() {
          return new DeclarationReference2(GlobalSource.instance);
        };
        DeclarationReference2.from = function(base) {
          return base || this.empty();
        };
        DeclarationReference2.prototype.withSource = function(source) {
          return this._source === source ? this : new DeclarationReference2(source, this._navigation, this._symbol);
        };
        DeclarationReference2.prototype.withNavigation = function(navigation) {
          return this._navigation === navigation ? this : new DeclarationReference2(this._source, navigation, this._symbol);
        };
        DeclarationReference2.prototype.withSymbol = function(symbol) {
          return this._symbol === symbol ? this : new DeclarationReference2(this._source, this._navigation, symbol);
        };
        DeclarationReference2.prototype.withComponentPath = function(componentPath) {
          return this.withSymbol(this.symbol ? this.symbol.withComponentPath(componentPath) : new SymbolReference(componentPath));
        };
        DeclarationReference2.prototype.withMeaning = function(meaning) {
          if (!this.symbol) {
            if (meaning === void 0) {
              return this;
            }
            return this.withSymbol(SymbolReference.empty().withMeaning(meaning));
          }
          return this.withSymbol(this.symbol.withMeaning(meaning));
        };
        DeclarationReference2.prototype.withOverloadIndex = function(overloadIndex) {
          if (!this.symbol) {
            if (overloadIndex === void 0) {
              return this;
            }
            return this.withSymbol(SymbolReference.empty().withOverloadIndex(overloadIndex));
          }
          return this.withSymbol(this.symbol.withOverloadIndex(overloadIndex));
        };
        DeclarationReference2.prototype.addNavigationStep = function(navigation, component) {
          if (this.symbol) {
            return this.withSymbol(this.symbol.addNavigationStep(navigation, component));
          }
          if (navigation === "#") {
            navigation = ".";
          }
          var symbol = new SymbolReference(new ComponentRoot(Component.from(component)));
          return new DeclarationReference2(this.source, navigation, symbol);
        };
        DeclarationReference2.prototype.toString = function() {
          var navigation = this._source instanceof ModuleSource && this._symbol && this.navigation === "~" ? "~" : "";
          return "" + (this.source || "") + navigation + (this.symbol || "");
        };
        return DeclarationReference2;
      }()
    );
    exports2.DeclarationReference = DeclarationReference;
    var ModuleSource = (
      /** @class */
      function() {
        function ModuleSource2(path, userEscaped) {
          if (userEscaped === void 0) {
            userEscaped = true;
          }
          this.escapedPath = this instanceof ParsedModuleSource ? path : escapeModuleSourceIfNeeded(path, userEscaped);
        }
        Object.defineProperty(ModuleSource2.prototype, "path", {
          get: function() {
            return this._path || (this._path = DeclarationReference.unescapeModuleSourceString(this.escapedPath));
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ModuleSource2.prototype, "packageName", {
          get: function() {
            return this._getOrParsePathComponents().packageName;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ModuleSource2.prototype, "scopeName", {
          get: function() {
            var scopeName = this._getOrParsePathComponents().scopeName;
            return scopeName ? "@" + scopeName : "";
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ModuleSource2.prototype, "unscopedPackageName", {
          get: function() {
            return this._getOrParsePathComponents().unscopedPackageName;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ModuleSource2.prototype, "importPath", {
          get: function() {
            return this._getOrParsePathComponents().importPath || "";
          },
          enumerable: false,
          configurable: true
        });
        ModuleSource2.fromScopedPackage = function(scopeName, unscopedPackageName, importPath) {
          var packageName = unscopedPackageName;
          if (scopeName) {
            if (scopeName.charAt(0) === "@") {
              scopeName = scopeName.slice(1);
            }
            packageName = "@" + scopeName + "/" + unscopedPackageName;
          }
          var parsed = { packageName, scopeName: scopeName || "", unscopedPackageName };
          return this._fromPackageName(parsed, packageName, importPath);
        };
        ModuleSource2.fromPackage = function(packageName, importPath) {
          return this._fromPackageName(parsePackageName(packageName), packageName, importPath);
        };
        ModuleSource2._fromPackageName = function(parsed, packageName, importPath) {
          if (!parsed) {
            throw new Error("Parsed package must be provided.");
          }
          var packageNameError = StringChecks_1.StringChecks.explainIfInvalidPackageName(packageName);
          if (packageNameError) {
            throw new SyntaxError("Invalid NPM package name: " + packageNameError);
          }
          var path = packageName;
          if (importPath) {
            if (invalidImportPathRegExp.test(importPath)) {
              throw new SyntaxError("Invalid import path '" + importPath);
            }
            path += "/" + importPath;
            parsed.importPath = importPath;
          }
          var source = new ModuleSource2(path);
          source._pathComponents = parsed;
          return source;
        };
        ModuleSource2.prototype.toString = function() {
          return this.escapedPath + "!";
        };
        ModuleSource2.prototype._getOrParsePathComponents = function() {
          if (!this._pathComponents) {
            var path = this.path;
            var parsed = parsePackageName(path);
            if (parsed && !StringChecks_1.StringChecks.explainIfInvalidPackageName(parsed.packageName)) {
              this._pathComponents = parsed;
            } else {
              this._pathComponents = {
                packageName: "",
                scopeName: "",
                unscopedPackageName: "",
                importPath: path
              };
            }
          }
          return this._pathComponents;
        };
        return ModuleSource2;
      }()
    );
    exports2.ModuleSource = ModuleSource;
    var ParsedModuleSource = (
      /** @class */
      function(_super) {
        __extends29(ParsedModuleSource2, _super);
        function ParsedModuleSource2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return ParsedModuleSource2;
      }(ModuleSource)
    );
    var packageNameRegExp = /^((?:@([^/]+?)\/)?([^/]+?))(?:\/(.+))?$/;
    var invalidImportPathRegExp = /^(\.\.?([\\/]|$)|[\\/])/;
    function parsePackageName(text) {
      var match = packageNameRegExp.exec(text);
      if (!match) {
        return match;
      }
      var _a = match[1], packageName = _a === void 0 ? "" : _a, _b = match[2], scopeName = _b === void 0 ? "" : _b, _c = match[3], unscopedPackageName = _c === void 0 ? "" : _c, importPath = match[4];
      return { packageName, scopeName, unscopedPackageName, importPath };
    }
    var GlobalSource = (
      /** @class */
      function() {
        function GlobalSource2() {
        }
        GlobalSource2.prototype.toString = function() {
          return "!";
        };
        GlobalSource2.instance = new GlobalSource2();
        return GlobalSource2;
      }()
    );
    exports2.GlobalSource = GlobalSource;
    var Component;
    (function(Component2) {
      function from(value) {
        if (typeof value === "string") {
          return new ComponentString(value);
        }
        if (value instanceof DeclarationReference) {
          return new ComponentReference(value);
        }
        return value;
      }
      Component2.from = from;
    })(Component = exports2.Component || (exports2.Component = {}));
    var ComponentString = (
      /** @class */
      function() {
        function ComponentString2(text, userEscaped) {
          this.text = this instanceof ParsedComponentString ? text : escapeComponentIfNeeded(text, userEscaped);
        }
        ComponentString2.prototype.toString = function() {
          return this.text;
        };
        return ComponentString2;
      }()
    );
    exports2.ComponentString = ComponentString;
    var ParsedComponentString = (
      /** @class */
      function(_super) {
        __extends29(ParsedComponentString2, _super);
        function ParsedComponentString2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return ParsedComponentString2;
      }(ComponentString)
    );
    var ComponentReference = (
      /** @class */
      function() {
        function ComponentReference2(reference) {
          this.reference = reference;
        }
        ComponentReference2.parse = function(text) {
          if (text.length > 2 && text.charAt(0) === "[" && text.charAt(text.length - 1) === "]") {
            return new ComponentReference2(DeclarationReference.parse(text.slice(1, -1)));
          }
          throw new SyntaxError("Invalid component reference: '" + text + "'");
        };
        ComponentReference2.prototype.withReference = function(reference) {
          return this.reference === reference ? this : new ComponentReference2(reference);
        };
        ComponentReference2.prototype.toString = function() {
          return "[" + this.reference + "]";
        };
        return ComponentReference2;
      }()
    );
    exports2.ComponentReference = ComponentReference;
    var ComponentPathBase = (
      /** @class */
      function() {
        function ComponentPathBase2(component) {
          this.component = component;
        }
        ComponentPathBase2.prototype.addNavigationStep = function(navigation, component) {
          return new ComponentNavigation(this, navigation, Component.from(component));
        };
        return ComponentPathBase2;
      }()
    );
    exports2.ComponentPathBase = ComponentPathBase;
    var ComponentRoot = (
      /** @class */
      function(_super) {
        __extends29(ComponentRoot2, _super);
        function ComponentRoot2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        ComponentRoot2.prototype.withComponent = function(component) {
          return this.component === component ? this : new ComponentRoot2(Component.from(component));
        };
        ComponentRoot2.prototype.toString = function() {
          return this.component.toString();
        };
        return ComponentRoot2;
      }(ComponentPathBase)
    );
    exports2.ComponentRoot = ComponentRoot;
    var ComponentNavigation = (
      /** @class */
      function(_super) {
        __extends29(ComponentNavigation2, _super);
        function ComponentNavigation2(parent, navigation, component) {
          var _this = _super.call(this, component) || this;
          _this.parent = parent;
          _this.navigation = navigation;
          return _this;
        }
        ComponentNavigation2.prototype.withParent = function(parent) {
          return this.parent === parent ? this : new ComponentNavigation2(parent, this.navigation, this.component);
        };
        ComponentNavigation2.prototype.withNavigation = function(navigation) {
          return this.navigation === navigation ? this : new ComponentNavigation2(this.parent, navigation, this.component);
        };
        ComponentNavigation2.prototype.withComponent = function(component) {
          return this.component === component ? this : new ComponentNavigation2(this.parent, this.navigation, Component.from(component));
        };
        ComponentNavigation2.prototype.toString = function() {
          return "" + this.parent + formatNavigation(this.navigation) + this.component;
        };
        return ComponentNavigation2;
      }(ComponentPathBase)
    );
    exports2.ComponentNavigation = ComponentNavigation;
    var SymbolReference = (
      /** @class */
      function() {
        function SymbolReference2(component, _a) {
          var _b = _a === void 0 ? {} : _a, meaning = _b.meaning, overloadIndex = _b.overloadIndex;
          this.componentPath = component;
          this.overloadIndex = overloadIndex;
          this.meaning = meaning;
        }
        SymbolReference2.empty = function() {
          return new SymbolReference2(
            /*component*/
            void 0
          );
        };
        SymbolReference2.prototype.withComponentPath = function(componentPath) {
          return this.componentPath === componentPath ? this : new SymbolReference2(componentPath, {
            meaning: this.meaning,
            overloadIndex: this.overloadIndex
          });
        };
        SymbolReference2.prototype.withMeaning = function(meaning) {
          return this.meaning === meaning ? this : new SymbolReference2(this.componentPath, {
            meaning,
            overloadIndex: this.overloadIndex
          });
        };
        SymbolReference2.prototype.withOverloadIndex = function(overloadIndex) {
          return this.overloadIndex === overloadIndex ? this : new SymbolReference2(this.componentPath, {
            meaning: this.meaning,
            overloadIndex
          });
        };
        SymbolReference2.prototype.addNavigationStep = function(navigation, component) {
          if (!this.componentPath) {
            throw new Error("Cannot add a navigation step to an empty symbol reference.");
          }
          return new SymbolReference2(this.componentPath.addNavigationStep(navigation, component));
        };
        SymbolReference2.prototype.toString = function() {
          var result = "" + (this.componentPath || "");
          if (this.meaning && this.overloadIndex !== void 0) {
            result += ":" + this.meaning + "(" + this.overloadIndex + ")";
          } else if (this.meaning) {
            result += ":" + this.meaning;
          } else if (this.overloadIndex !== void 0) {
            result += ":" + this.overloadIndex;
          }
          return result;
        };
        return SymbolReference2;
      }()
    );
    exports2.SymbolReference = SymbolReference;
    function tokenToString(token) {
      switch (token) {
        case 2:
          return "{";
        case 3:
          return "}";
        case 4:
          return "(";
        case 5:
          return ")";
        case 6:
          return "[";
        case 7:
          return "]";
        case 8:
          return "!";
        case 9:
          return ".";
        case 10:
          return "#";
        case 11:
          return "~";
        case 12:
          return ":";
        case 13:
          return ",";
        case 14:
          return "@";
        case 19:
          return "class";
        case 20:
          return "interface";
        case 21:
          return "type";
        case 22:
          return "enum";
        case 23:
          return "namespace";
        case 24:
          return "function";
        case 25:
          return "var";
        case 26:
          return "constructor";
        case 27:
          return "member";
        case 28:
          return "event";
        case 29:
          return "call";
        case 30:
          return "new";
        case 31:
          return "index";
        case 32:
          return "complex";
        case 0:
          return "<none>";
        case 1:
          return "<eof>";
        case 15:
          return "<decimal digits>";
        case 16:
          return "<string>";
        case 17:
          return "<text>";
        case 18:
          return "<module source>";
      }
    }
    var Scanner = (
      /** @class */
      function() {
        function Scanner2(text) {
          this._pos = 0;
          this._tokenPos = 0;
          this._stringIsUnterminated = false;
          this._token = 0;
          this._text = text;
        }
        Object.defineProperty(Scanner2.prototype, "stringIsUnterminated", {
          get: function() {
            return this._stringIsUnterminated;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Scanner2.prototype, "text", {
          get: function() {
            return this._text;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Scanner2.prototype, "tokenText", {
          get: function() {
            return this._text.slice(this._tokenPos, this._pos);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Scanner2.prototype, "eof", {
          get: function() {
            return this._pos >= this._text.length;
          },
          enumerable: false,
          configurable: true
        });
        Scanner2.prototype.token = function() {
          return this._token;
        };
        Scanner2.prototype.speculate = function(cb) {
          var tokenPos = this._tokenPos;
          var pos = this._pos;
          var text = this._text;
          var token = this._token;
          var stringIsUnterminated = this._stringIsUnterminated;
          var accepted = false;
          try {
            var accept = function() {
              accepted = true;
            };
            return cb(accept);
          } finally {
            if (!accepted) {
              this._tokenPos = tokenPos;
              this._pos = pos;
              this._text = text;
              this._token = token;
              this._stringIsUnterminated = stringIsUnterminated;
            }
          }
        };
        Scanner2.prototype.scan = function() {
          if (!this.eof) {
            this._tokenPos = this._pos;
            this._stringIsUnterminated = false;
            while (!this.eof) {
              var ch = this._text.charAt(this._pos++);
              switch (ch) {
                case "{":
                  return this._token = 2;
                case "}":
                  return this._token = 3;
                case "(":
                  return this._token = 4;
                case ")":
                  return this._token = 5;
                case "[":
                  return this._token = 6;
                case "]":
                  return this._token = 7;
                case "!":
                  return this._token = 8;
                case ".":
                  return this._token = 9;
                case "#":
                  return this._token = 10;
                case "~":
                  return this._token = 11;
                case ":":
                  return this._token = 12;
                case ",":
                  return this._token = 13;
                case "@":
                  return this._token = 14;
                case '"':
                  this.scanString();
                  return this._token = 16;
                default:
                  this.scanText();
                  return this._token = 17;
              }
            }
          }
          return this._token = 1;
        };
        Scanner2.prototype.rescanModuleSource = function() {
          var _this = this;
          switch (this._token) {
            case 18:
            case 8:
            case 1:
              return this._token;
          }
          return this.speculate(function(accept) {
            if (!_this.eof) {
              _this._pos = _this._tokenPos;
              _this._stringIsUnterminated = false;
              var scanned = "none";
              while (!_this.eof) {
                var ch = _this._text[_this._pos];
                if (ch === "!") {
                  if (scanned === "none") {
                    return _this._token;
                  }
                  accept();
                  return _this._token = 18;
                }
                _this._pos++;
                if (ch === '"') {
                  if (scanned === "other") {
                    return _this._token;
                  }
                  scanned = "string";
                  _this.scanString();
                } else {
                  if (scanned === "string") {
                    return _this._token;
                  }
                  scanned = "other";
                  if (!isPunctuator(ch)) {
                    _this.scanText();
                  }
                }
              }
            }
            return _this._token;
          });
        };
        Scanner2.prototype.rescanMeaning = function() {
          if (this._token === 17) {
            var tokenText = this.tokenText;
            switch (tokenText) {
              case "class":
                return this._token = 19;
              case "interface":
                return this._token = 20;
              case "type":
                return this._token = 21;
              case "enum":
                return this._token = 22;
              case "namespace":
                return this._token = 23;
              case "function":
                return this._token = 24;
              case "var":
                return this._token = 25;
              case "constructor":
                return this._token = 26;
              case "member":
                return this._token = 27;
              case "event":
                return this._token = 28;
              case "call":
                return this._token = 29;
              case "new":
                return this._token = 30;
              case "index":
                return this._token = 31;
              case "complex":
                return this._token = 32;
            }
          }
          return this._token;
        };
        Scanner2.prototype.rescanDecimalDigits = function() {
          if (this._token === 17) {
            var tokenText = this.tokenText;
            if (/^\d+$/.test(tokenText)) {
              return this._token = 15;
            }
          }
          return this._token;
        };
        Scanner2.prototype.scanString = function() {
          while (!this.eof) {
            var ch = this._text.charAt(this._pos++);
            switch (ch) {
              case '"':
                return;
              case "\\":
                this.scanEscapeSequence();
                break;
              default:
                if (isLineTerminator(ch)) {
                  this._stringIsUnterminated = true;
                  return;
                }
            }
          }
          this._stringIsUnterminated = true;
        };
        Scanner2.prototype.scanEscapeSequence = function() {
          if (this.eof) {
            this._stringIsUnterminated = true;
            return;
          }
          var ch = this._text.charAt(this._pos);
          if (isCharacterEscapeSequence(ch)) {
            this._pos++;
            return;
          }
          if (ch === "0" && (this._pos + 1 === this._text.length || !isDecimalDigit(this._text.charAt(this._pos + 1)))) {
            this._pos++;
            return;
          }
          if (ch === "x" && this._pos + 3 <= this._text.length && isHexDigit(this._text.charAt(this._pos + 1)) && isHexDigit(this._text.charAt(this._pos + 2))) {
            this._pos += 3;
            return;
          }
          if (ch === "u" && this._pos + 5 <= this._text.length && isHexDigit(this._text.charAt(this._pos + 1)) && isHexDigit(this._text.charAt(this._pos + 2)) && isHexDigit(this._text.charAt(this._pos + 3)) && isHexDigit(this._text.charAt(this._pos + 4))) {
            this._pos += 5;
            return;
          }
          if (ch === "u" && this._pos + 4 <= this._text.length && this._text.charAt(this._pos + 1) === "{") {
            var hexDigits = this._text.charAt(this._pos + 2);
            if (isHexDigit(hexDigits)) {
              for (var i = this._pos + 3; i < this._text.length; i++) {
                var ch2 = this._text.charAt(i);
                if (ch2 === "}") {
                  var mv = parseInt(hexDigits, 16);
                  if (mv <= 1114111) {
                    this._pos = i + 1;
                    return;
                  }
                  break;
                }
                if (!isHexDigit(ch2)) {
                  hexDigits += ch2;
                  break;
                }
              }
            }
          }
          this._stringIsUnterminated = true;
        };
        Scanner2.prototype.scanText = function() {
          while (this._pos < this._text.length) {
            var ch = this._text.charAt(this._pos);
            if (isPunctuator(ch) || ch === '"') {
              return;
            }
            this._pos++;
          }
        };
        return Scanner2;
      }()
    );
    var Parser = (
      /** @class */
      function() {
        function Parser2(text) {
          this._errors = [];
          this._scanner = new Scanner(text);
          this._scanner.scan();
        }
        Object.defineProperty(Parser2.prototype, "eof", {
          get: function() {
            return this.token() === 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Parser2.prototype, "errors", {
          get: function() {
            return this._errors;
          },
          enumerable: false,
          configurable: true
        });
        Parser2.prototype.parseDeclarationReference = function() {
          var source;
          var navigation;
          var symbol;
          if (this.optionalToken(
            8
            /* ExclamationToken */
          )) {
            source = GlobalSource.instance;
          } else if (this._scanner.rescanModuleSource() === 18) {
            source = this.parseModuleSource();
            if (this.optionalToken(
              11
              /* TildeToken */
            )) {
              navigation = "~";
            }
          }
          if (this.isStartOfComponent()) {
            symbol = this.parseSymbol();
          } else if (this.token() === 12) {
            symbol = this.parseSymbolRest(new ComponentRoot(new ComponentString(
              "",
              /*userEscaped*/
              true
            )));
          }
          return new DeclarationReference(source, navigation, symbol);
        };
        Parser2.prototype.parseModuleSourceString = function() {
          this._scanner.rescanModuleSource();
          return this.parseTokenString(18, "Module source");
        };
        Parser2.prototype.parseComponentString = function() {
          switch (this._scanner.token()) {
            case 16:
              return this.parseString();
            default:
              return this.parseComponentCharacters();
          }
        };
        Parser2.prototype.token = function() {
          return this._scanner.token();
        };
        Parser2.prototype.parseModuleSource = function() {
          var source = this.parseModuleSourceString();
          this.expectToken(
            8
            /* ExclamationToken */
          );
          return new ParsedModuleSource(
            source,
            /*userEscaped*/
            true
          );
        };
        Parser2.prototype.parseSymbol = function() {
          var component = this.parseComponentRest(this.parseRootComponent());
          return this.parseSymbolRest(component);
        };
        Parser2.prototype.parseSymbolRest = function(component) {
          var meaning;
          var overloadIndex;
          if (this.optionalToken(
            12
            /* ColonToken */
          )) {
            meaning = this.tryParseMeaning();
            overloadIndex = this.tryParseOverloadIndex(!!meaning);
          }
          return new SymbolReference(component, { meaning, overloadIndex });
        };
        Parser2.prototype.parseRootComponent = function() {
          if (!this.isStartOfComponent()) {
            return this.fail("Component expected", new ComponentRoot(new ComponentString(
              "",
              /*userEscaped*/
              true
            )));
          }
          var component = this.parseComponent();
          return new ComponentRoot(component);
        };
        Parser2.prototype.parseComponentRest = function(component) {
          for (; ; ) {
            switch (this.token()) {
              case 9:
              case 10:
              case 11:
                var navigation = this.parseNavigation();
                var right = this.parseComponent();
                component = new ComponentNavigation(component, navigation, right);
                break;
              default:
                return component;
            }
          }
        };
        Parser2.prototype.parseNavigation = function() {
          switch (this._scanner.token()) {
            case 9:
              return this._scanner.scan(), ".";
            case 10:
              return this._scanner.scan(), "#";
            case 11:
              return this._scanner.scan(), "~";
            default:
              return this.fail(
                "Expected '.', '#', or '~'",
                "."
                /* Exports */
              );
          }
        };
        Parser2.prototype.tryParseMeaning = function() {
          switch (this._scanner.rescanMeaning()) {
            case 19:
              return this._scanner.scan(), "class";
            case 20:
              return this._scanner.scan(), "interface";
            case 21:
              return this._scanner.scan(), "type";
            case 22:
              return this._scanner.scan(), "enum";
            case 23:
              return this._scanner.scan(), "namespace";
            case 24:
              return this._scanner.scan(), "function";
            case 25:
              return this._scanner.scan(), "var";
            case 26:
              return this._scanner.scan(), "constructor";
            case 27:
              return this._scanner.scan(), "member";
            case 28:
              return this._scanner.scan(), "event";
            case 29:
              return this._scanner.scan(), "call";
            case 30:
              return this._scanner.scan(), "new";
            case 31:
              return this._scanner.scan(), "index";
            case 32:
              return this._scanner.scan(), "complex";
            default:
              return void 0;
          }
        };
        Parser2.prototype.tryParseOverloadIndex = function(hasMeaning) {
          if (this.optionalToken(
            4
            /* OpenParenToken */
          )) {
            var overloadIndex = this.parseDecimalDigits();
            this.expectToken(
              5
              /* CloseParenToken */
            );
            return overloadIndex;
          } else if (!hasMeaning) {
            return this.parseDecimalDigits();
          }
          return void 0;
        };
        Parser2.prototype.parseDecimalDigits = function() {
          switch (this._scanner.rescanDecimalDigits()) {
            case 15:
              var value = +this._scanner.tokenText;
              this._scanner.scan();
              return value;
            default:
              return this.fail("Decimal digit expected", 0);
          }
        };
        Parser2.prototype.isStartOfComponent = function() {
          switch (this.token()) {
            case 17:
            case 16:
            case 6:
              return true;
            default:
              return false;
          }
        };
        Parser2.prototype.parseComponentCharacters = function() {
          var text = "";
          for (; ; ) {
            switch (this._scanner.token()) {
              case 17:
                text += this.parseText();
                break;
              default:
                return text;
            }
          }
        };
        Parser2.prototype.parseTokenString = function(token, tokenString) {
          if (this._scanner.token() === token) {
            var text = this._scanner.tokenText;
            var stringIsUnterminated = this._scanner.stringIsUnterminated;
            this._scanner.scan();
            if (stringIsUnterminated) {
              return this.fail((tokenString || tokenToString(token)) + " is unterminated", text);
            }
            return text;
          }
          return this.fail((tokenString || tokenToString(token)) + " expected", "");
        };
        Parser2.prototype.parseText = function() {
          return this.parseTokenString(17, "Text");
        };
        Parser2.prototype.parseString = function() {
          return this.parseTokenString(16, "String");
        };
        Parser2.prototype.parseComponent = function() {
          switch (this._scanner.token()) {
            case 6:
              return this.parseBracketedComponent();
            default:
              return new ParsedComponentString(
                this.parseComponentString(),
                /*userEscaped*/
                true
              );
          }
        };
        Parser2.prototype.parseBracketedComponent = function() {
          this.expectToken(
            6
            /* OpenBracketToken */
          );
          var reference = this.parseDeclarationReference();
          this.expectToken(
            7
            /* CloseBracketToken */
          );
          return new ComponentReference(reference);
        };
        Parser2.prototype.optionalToken = function(token) {
          if (this._scanner.token() === token) {
            this._scanner.scan();
            return true;
          }
          return false;
        };
        Parser2.prototype.expectToken = function(token, message) {
          if (this._scanner.token() !== token) {
            var expected = tokenToString(token);
            var actual = tokenToString(this._scanner.token());
            return this.fail(message || "Expected token '" + expected + "', received '" + actual + "' instead.", void 0);
          }
          this._scanner.scan();
        };
        Parser2.prototype.fail = function(message, fallback) {
          this._errors.push(message);
          return fallback;
        };
        return Parser2;
      }()
    );
    function formatNavigation(navigation) {
      switch (navigation) {
        case ".":
          return ".";
        case "#":
          return "#";
        case "~":
          return "~";
        default:
          return "";
      }
    }
    function isCharacterEscapeSequence(ch) {
      return isSingleEscapeCharacter(ch) || isNonEscapeCharacter(ch);
    }
    function isSingleEscapeCharacter(ch) {
      switch (ch) {
        case "'":
        case '"':
        case "\\":
        case "b":
        case "f":
        case "n":
        case "r":
        case "t":
        case "v":
          return true;
        default:
          return false;
      }
    }
    function isNonEscapeCharacter(ch) {
      return !isEscapeCharacter(ch) && !isLineTerminator(ch);
    }
    function isEscapeCharacter(ch) {
      switch (ch) {
        case "x":
        case "u":
          return true;
        default:
          return isSingleEscapeCharacter(ch) || isDecimalDigit(ch);
      }
    }
    function isLineTerminator(ch) {
      switch (ch) {
        case "\r":
        case "\n":
          return true;
        default:
          return false;
      }
    }
    function isDecimalDigit(ch) {
      switch (ch) {
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          return true;
        default:
          return false;
      }
    }
    function isHexDigit(ch) {
      switch (ch) {
        case "a":
        case "b":
        case "c":
        case "d":
        case "e":
        case "f":
        case "A":
        case "B":
        case "C":
        case "D":
        case "E":
        case "F":
          return true;
        default:
          return isDecimalDigit(ch);
      }
    }
    function isPunctuator(ch) {
      switch (ch) {
        case "{":
        case "}":
        case "(":
        case ")":
        case "[":
        case "]":
        case "!":
        case ".":
        case "#":
        case "~":
        case ":":
        case ",":
        case "@":
          return true;
        default:
          return false;
      }
    }
    function escapeComponentIfNeeded(text, userEscaped) {
      if (userEscaped) {
        if (!DeclarationReference.isWellFormedComponentString(text)) {
          throw new SyntaxError("Invalid Component '" + text + "'");
        }
        return text;
      }
      return DeclarationReference.escapeComponentString(text);
    }
    function escapeModuleSourceIfNeeded(text, userEscaped) {
      if (userEscaped) {
        if (!DeclarationReference.isWellFormedModuleSourceString(text)) {
          throw new SyntaxError("Invalid Module source '" + text + "'");
        }
        return text;
      }
      return DeclarationReference.escapeModuleSourceString(text);
    }
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/Parameter.js
var require_Parameter = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/Parameter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parameter = void 0;
    var ApiDocumentedItem_1 = require_ApiDocumentedItem();
    var Parameter = class {
      constructor(options) {
        this.name = options.name;
        this.parameterTypeExcerpt = options.parameterTypeExcerpt;
        this.isOptional = options.isOptional;
        this._parent = options.parent;
      }
      /**
       * Returns the `@param` documentation for this parameter, if present.
       */
      get tsdocParamBlock() {
        if (this._parent instanceof ApiDocumentedItem_1.ApiDocumentedItem) {
          if (this._parent.tsdocComment) {
            return this._parent.tsdocComment.params.tryGetBlockByName(this.name);
          }
        }
      }
    };
    exports2.Parameter = Parameter;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/InternalError.js
var require_InternalError = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/InternalError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InternalError = void 0;
    var InternalError = class _InternalError extends Error {
      /**
       * Constructs a new instance of the {@link InternalError} class.
       *
       * @param message - A message describing the error.  This will be assigned to
       * {@link InternalError.unformattedMessage}.  The `Error.message` field will have additional boilerplate
       * explaining that the user has encountered a software defect.
       */
      constructor(message) {
        super(_InternalError._formatMessage(message));
        this.__proto__ = _InternalError.prototype;
        this.unformattedMessage = message;
        if (_InternalError.breakInDebugger) {
          debugger;
        }
      }
      static _formatMessage(unformattedMessage) {
        return `Internal Error: ${unformattedMessage}

You have encountered a software defect. Please consider reporting the issue to the maintainers of this application.`;
      }
      /** @override */
      toString() {
        return this.message;
      }
    };
    exports2.InternalError = InternalError;
    InternalError.breakInDebugger = true;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/TypeUuid.js
var require_TypeUuid = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/TypeUuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeUuid = void 0;
    var InternalError_1 = require_InternalError();
    var classPrototypeUuidSymbol = Symbol.for("TypeUuid.classPrototypeUuid");
    var TypeUuid = class _TypeUuid {
      /**
       * Registers a JavaScript class as having a type identified by the specified UUID.
       * @privateRemarks
       * We cannot use a construct signature for `targetClass` because it may be an abstract class.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static registerClass(targetClass, typeUuid) {
        if (typeof targetClass !== "function") {
          throw new Error("The targetClass parameter must be a JavaScript class");
        }
        if (!_TypeUuid._uuidRegExp.test(typeUuid)) {
          throw new Error(`The type UUID must be specified as lowercase hexadecimal with dashes: "${typeUuid}"`);
        }
        const targetClassPrototype = targetClass.prototype;
        if (Object.hasOwnProperty.call(targetClassPrototype, classPrototypeUuidSymbol)) {
          const existingUuid = targetClassPrototype[classPrototypeUuidSymbol];
          throw new InternalError_1.InternalError(`Cannot register the target class ${targetClass.name || ""} typeUuid=${typeUuid} because it was already registered with typeUuid=${existingUuid}`);
        }
        targetClassPrototype[classPrototypeUuidSymbol] = typeUuid;
      }
      /**
       * Returns true if the `targetObject` is an instance of a JavaScript class that was previously
       * registered using the specified `typeUuid`.  Base classes are also considered.
       */
      static isInstanceOf(targetObject, typeUuid) {
        if (targetObject === void 0 || targetObject === null) {
          return false;
        }
        let objectPrototype = Object.getPrototypeOf(targetObject);
        while (objectPrototype !== void 0 && objectPrototype !== null) {
          const registeredUuid = objectPrototype[classPrototypeUuidSymbol];
          if (registeredUuid === typeUuid) {
            return true;
          }
          objectPrototype = Object.getPrototypeOf(objectPrototype);
        }
        return false;
      }
    };
    exports2.TypeUuid = TypeUuid;
    TypeUuid._uuidRegExp = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/AlreadyReportedError.js
var require_AlreadyReportedError = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/AlreadyReportedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlreadyReportedError = void 0;
    var TypeUuid_1 = require_TypeUuid();
    var uuidAlreadyReportedError = "f26b0640-a49b-49d1-9ead-1a516d5920c7";
    var AlreadyReportedError = class _AlreadyReportedError extends Error {
      constructor() {
        super("An error occurred.");
        this.__proto__ = _AlreadyReportedError.prototype;
      }
      static [Symbol.hasInstance](instance) {
        return TypeUuid_1.TypeUuid.isInstanceOf(instance, uuidAlreadyReportedError);
      }
    };
    exports2.AlreadyReportedError = AlreadyReportedError;
    TypeUuid_1.TypeUuid.registerClass(AlreadyReportedError, uuidAlreadyReportedError);
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Async.js
var require_Async = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Async.js"(exports2) {
    "use strict";
    var __await = exports2 && exports2.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports2 && exports2.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncQueue = exports2.Async = void 0;
    function toWeightedIterator(iterable, useWeights) {
      const iterator = (iterable[Symbol.iterator] || iterable[Symbol.asyncIterator]).call(iterable);
      return {
        [Symbol.asyncIterator]: () => ({
          // eslint-disable-next-line @typescript-eslint/naming-convention
          next: async () => {
            const { value, done } = await iterator.next();
            return {
              value: { element: value, weight: useWeights ? value === null || value === void 0 ? void 0 : value.weight : 1 },
              done: !!done
            };
          }
        })
      };
    }
    var Async = class _Async {
      static async mapAsync(iterable, callback, options) {
        const result = [];
        await _Async.forEachAsync(iterable, async (item, arrayIndex) => {
          result[arrayIndex] = await callback(item, arrayIndex);
        }, options);
        return result;
      }
      static async _forEachWeightedAsync(iterable, callback, options) {
        await new Promise((resolve, reject) => {
          const concurrency = (options === null || options === void 0 ? void 0 : options.concurrency) && options.concurrency > 0 ? options.concurrency : Infinity;
          let concurrentUnitsInProgress = 0;
          const iterator = iterable[Symbol.asyncIterator].call(iterable);
          let arrayIndex = 0;
          let iteratorIsComplete = false;
          let promiseHasResolvedOrRejected = false;
          async function queueOperationsAsync() {
            while (concurrentUnitsInProgress < concurrency && !iteratorIsComplete && !promiseHasResolvedOrRejected) {
              const limitedConcurrency = !Number.isFinite(concurrency) ? 1 : concurrency;
              concurrentUnitsInProgress += limitedConcurrency;
              const currentIteratorResult = await iterator.next();
              iteratorIsComplete = !!currentIteratorResult.done;
              if (!iteratorIsComplete) {
                const currentIteratorValue = currentIteratorResult.value;
                _Async.validateWeightedIterable(currentIteratorValue);
                const weight = Math.min(currentIteratorValue.weight, concurrency);
                concurrentUnitsInProgress += weight;
                concurrentUnitsInProgress -= limitedConcurrency;
                Promise.resolve(callback(currentIteratorValue.element, arrayIndex++)).then(async () => {
                  concurrentUnitsInProgress -= weight;
                  await onOperationCompletionAsync();
                }).catch((error) => {
                  promiseHasResolvedOrRejected = true;
                  reject(error);
                });
              } else {
                concurrentUnitsInProgress -= limitedConcurrency;
              }
            }
            if (iteratorIsComplete) {
              await onOperationCompletionAsync();
            }
          }
          async function onOperationCompletionAsync() {
            if (!promiseHasResolvedOrRejected) {
              if (concurrentUnitsInProgress === 0 && iteratorIsComplete) {
                promiseHasResolvedOrRejected = true;
                resolve();
              } else if (!iteratorIsComplete) {
                await queueOperationsAsync();
              }
            }
          }
          queueOperationsAsync().catch((error) => {
            promiseHasResolvedOrRejected = true;
            reject(error);
          });
        });
      }
      static async forEachAsync(iterable, callback, options) {
        await _Async._forEachWeightedAsync(toWeightedIterator(iterable, options === null || options === void 0 ? void 0 : options.weighted), callback, options);
      }
      /**
       * Return a promise that resolves after the specified number of milliseconds.
       */
      static async sleepAsync(ms) {
        await new Promise((resolve) => {
          setTimeout(resolve, ms);
        });
      }
      /**
       * @deprecated Use {@link Async.sleepAsync} instead.
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      static async sleep(ms) {
        await _Async.sleepAsync(ms);
      }
      /**
       * Executes an async function and optionally retries it if it fails.
       */
      static async runWithRetriesAsync({ action, maxRetries, retryDelayMs = 0 }) {
        let retryCounter = 0;
        while (true) {
          try {
            return await action();
          } catch (e) {
            if (++retryCounter > maxRetries) {
              throw e;
            } else if (retryDelayMs > 0) {
              await _Async.sleepAsync(retryDelayMs);
            }
          }
        }
      }
      /**
       * Ensures that the argument is a valid {@link IWeighted}, with a `weight` argument that
       * is a positive integer or 0.
       */
      static validateWeightedIterable(operation) {
        if (operation.weight < 0) {
          throw new Error("Weight must be a whole number greater than or equal to 0");
        }
        if (operation.weight % 1 !== 0) {
          throw new Error("Weight must be a whole number greater than or equal to 0");
        }
      }
      /**
       * Returns a Signal, a.k.a. a "deferred promise".
       */
      static getSignal() {
        return getSignal();
      }
    };
    exports2.Async = Async;
    function getSignal() {
      let resolver;
      let rejecter;
      const promise = new Promise((resolve, reject) => {
        resolver = resolve;
        rejecter = reject;
      });
      return [promise, resolver, rejecter];
    }
    var AsyncQueue = class {
      constructor(iterable) {
        this._queue = iterable ? Array.from(iterable) : [];
        const [promise, resolver] = getSignal();
        this._onPushSignal = promise;
        this._onPushResolve = resolver;
      }
      [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
          let activeIterations = 0;
          let [callbackSignal, callbackResolve] = getSignal();
          const callback = () => {
            if (--activeIterations === 0) {
              callbackResolve();
              const [newCallbackSignal, newCallbackResolve] = getSignal();
              callbackSignal = newCallbackSignal;
              callbackResolve = newCallbackResolve;
            }
          };
          let position = 0;
          while (this._queue.length > position || activeIterations > 0) {
            if (this._queue.length > position) {
              activeIterations++;
              yield yield __await([this._queue[position++], callback]);
            } else {
              yield __await(Promise.race([this._onPushSignal, callbackSignal]));
            }
          }
        });
      }
      /**
       * Adds an item to the queue.
       *
       * @param item - The item to push into the queue.
       */
      push(item) {
        this._queue.push(item);
        this._onPushResolve();
        const [onPushSignal, onPushResolve] = getSignal();
        this._onPushSignal = onPushSignal;
        this._onPushResolve = onPushResolve;
      }
    };
    exports2.AsyncQueue = AsyncQueue;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Constants.js
var require_Constants = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FolderConstants = exports2.FileConstants = void 0;
    var FileConstants;
    (function(FileConstants2) {
      FileConstants2["PackageJson"] = "package.json";
    })(FileConstants || (exports2.FileConstants = FileConstants = {}));
    var FolderConstants;
    (function(FolderConstants2) {
      FolderConstants2["Git"] = ".git";
      FolderConstants2["NodeModules"] = "node_modules";
    })(FolderConstants || (exports2.FolderConstants = FolderConstants = {}));
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Enum.js
var require_Enum = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Enum = void 0;
    var Enum = class {
      constructor() {
      }
      /**
       * Returns an enum value, given its key. Returns `undefined` if no matching key is found.
       *
       * @example
       *
       * Example usage:
       * ```ts
       * enum Colors {
       *   Red = 1
       * }
       *
       * // Prints "1"
       * console.log(Enum.tryGetValueByKey(Colors, "Red"));
       *
       * // Prints "undefined"
       * console.log(Enum.tryGetValueByKey(Colors, "Black"));
       * ```
       */
      static tryGetValueByKey(enumObject, key) {
        return enumObject[key];
      }
      /**
       * This API is similar to {@link Enum.tryGetValueByKey}, except that it throws an exception
       * if the key is undefined.
       */
      static getValueByKey(enumObject, key) {
        const result = enumObject[key];
        if (result === void 0) {
          throw new Error(`The lookup key ${JSON.stringify(key)} is not defined`);
        }
        return result;
      }
      /**
       * Returns an enum string key, given its numeric value.  Returns `undefined` if no matching value
       * is found.
       *
       * @remarks
       * The TypeScript compiler only creates a reverse mapping for enum members whose value is numeric.
       * For example:
       *
       * ```ts
       * enum E {
       *   A = 1,
       *   B = 'c'
       * }
       *
       * // Prints "A"
       * console.log(E[1]);
       *
       * // Prints "undefined"
       * console.log(E["c"]);
       * ```
       *
       * @example
       *
       * Example usage:
       * ```ts
       * enum Colors {
       *   Red = 1,
       *   Blue = 'blue'
       * }
       *
       * // Prints "Red"
       * console.log(Enum.tryGetKeyByNumber(Colors, 1));
       *
       * // Prints "undefined"
       * console.log(Enum.tryGetKeyByNumber(Colors, -1));
       * ```
       */
      static tryGetKeyByNumber(enumObject, value) {
        return enumObject[value];
      }
      /**
       * This API is similar to {@link Enum.tryGetKeyByNumber}, except that it throws an exception
       * if the key is undefined.
       */
      static getKeyByNumber(enumObject, value) {
        const result = enumObject[value];
        if (result === void 0) {
          throw new Error(`The value ${value} does not exist in the mapping`);
        }
        return result;
      }
    };
    exports2.Enum = Enum;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/EnvironmentMap.js
var require_EnvironmentMap = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/EnvironmentMap.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnvironmentMap = void 0;
    var process_1 = __importDefault(require("process"));
    var InternalError_1 = require_InternalError();
    var EnvironmentMap = class {
      constructor(environmentObject = {}) {
        this._map = /* @__PURE__ */ new Map();
        Object.defineProperty(this, "_sanityCheck", {
          enumerable: true,
          get: function() {
            throw new InternalError_1.InternalError("Attempt to read EnvironmentMap class as an object");
          }
        });
        this.caseSensitive = process_1.default.platform !== "win32";
        this.mergeFromObject(environmentObject);
      }
      /**
       * Clears all entries, resulting in an empty map.
       */
      clear() {
        this._map.clear();
      }
      /**
       * Assigns the variable to the specified value.  A previous value will be overwritten.
       *
       * @remarks
       * The value can be an empty string.  To completely remove the entry, use
       * {@link EnvironmentMap.unset} instead.
       */
      set(name, value) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.set(key, { name, value });
      }
      /**
       * Removes the key from the map, if present.
       */
      unset(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.delete(key);
      }
      /**
       * Returns the value of the specified variable, or `undefined` if the map does not contain that name.
       */
      get(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        const entry = this._map.get(key);
        if (entry === void 0) {
          return void 0;
        }
        return entry.value;
      }
      /**
       * Returns the map keys, which are environment variable names.
       */
      names() {
        return this._map.keys();
      }
      /**
       * Returns the map entries.
       */
      entries() {
        return this._map.values();
      }
      /**
       * Adds each entry from `environmentMap` to this map.
       */
      mergeFrom(environmentMap) {
        for (const entry of environmentMap.entries()) {
          this.set(entry.name, entry.value);
        }
      }
      /**
       * Merges entries from a plain JavaScript object, such as would be used with the `process.env` API.
       */
      mergeFromObject(environmentObject = {}) {
        for (const [name, value] of Object.entries(environmentObject)) {
          if (value !== void 0) {
            this.set(name, value);
          }
        }
      }
      /**
       * Returns the keys as a plain JavaScript object similar to the object returned by the `process.env` API.
       */
      toObject() {
        const result = {};
        for (const entry of this.entries()) {
          result[entry.name] = entry.value;
        }
        return result;
      }
    };
    exports2.EnvironmentMap = EnvironmentMap;
  }
});

// ../../node_modules/.pnpm/universalify@0.1.2/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../node_modules/.pnpm/universalify@0.1.2/node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function() {
        if (typeof arguments[arguments.length - 1] === "function")
          fn.apply(this, arguments);
        else {
          return new Promise((resolve, reject) => {
            arguments[arguments.length] = (err, res) => {
              if (err)
                return reject(err);
              resolve(res);
            };
            arguments.length++;
            fn.apply(this, arguments);
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function() {
        const cb = arguments[arguments.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, arguments);
        else
          fn.apply(this, arguments).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    "use strict";
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      fs2.stat = statFix(fs2.stat);
      fs2.fstat = statFix(fs2.fstat);
      fs2.lstat = statFix(fs2.lstat);
      fs2.statSync = statFixSync(fs2.statSync);
      fs2.fstatSync = statFixSync(fs2.fstatSync);
      fs2.lstatSync = statFixSync(fs2.lstatSync);
      if (fs2.chmod && !fs2.lchmod) {
        fs2.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchmodSync = function() {
        };
      }
      if (fs2.chown && !fs2.lchown) {
        fs2.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs2.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs2.rename);
      }
      fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs2.read);
      fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs2, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs2.readSync);
      function patchLchmod(fs3) {
        fs3.lchmod = function(path, mode, callback) {
          fs3.open(
            path,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs3.fchmod(fd, mode, function(err2) {
                fs3.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs3.lchmodSync = function(path, mode) {
          var fd = fs3.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs3.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs3) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
          fs3.lutimes = function(path, at, mt, cb) {
            fs3.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs3.futimes(fd, at, mt, function(er2) {
                fs3.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs3.lutimesSync = function(path, at, mt) {
            var fd = fs3.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs3.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs3.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs3.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs3.futimes) {
          fs3.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs3.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs2, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs2, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs2, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs2, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs2) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self2 = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs2.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs2.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs2[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs2, queue);
      fs2.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs2, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs2.close);
      fs2.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs2, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs2.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs2[gracefulQueue]);
          require("assert").equal(fs2[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs2[gracefulQueue]);
    }
    module2.exports = patch(clone(fs2));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
      module2.exports = patch(fs2);
      fs2.__patched = true;
    }
    function patch(fs3) {
      polyfills(fs3);
      fs3.gracefulify = patch;
      fs3.createReadStream = createReadStream;
      fs3.createWriteStream = createWriteStream;
      var fs$readFile = fs3.readFile;
      fs3.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs3.writeFile;
      fs3.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs3.appendFile;
      if (fs$appendFile)
        fs3.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs3.copyFile;
      if (fs$copyFile)
        fs3.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs3.readdir;
      fs3.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path2, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path2, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs3);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs3.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs3.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs3, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs3, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs3, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs3, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs3.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs3.WriteStream(path, options);
      }
      var fs$open = fs3.open;
      fs3.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs3;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs2[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs2[gracefulQueue].length; ++i) {
        if (fs2[gracefulQueue][i].length > 2) {
          fs2[gracefulQueue][i][3] = now;
          fs2[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs2[gracefulQueue].length === 0)
        return;
      var elem = fs2[gracefulQueue].shift();
      var fn = elem[0];
      var args2 = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args2);
        fn.apply(null, args2);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args2);
        var cb = args2.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args2);
          fn.apply(null, args2.concat([startTime]));
        } else {
          fs2[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs2 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchown",
      "lchmod",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "readFile",
      "readdir",
      "readlink",
      "realpath",
      "rename",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs2[key] === "function";
    });
    Object.keys(fs2).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports2[key] = fs2[key];
    });
    api.forEach((method) => {
      exports2[method] = u(fs2[method]);
    });
    exports2.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs2.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs2.exists(filename, resolve);
      });
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs2.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports2.write = function(fd, buffer, ...args2) {
      if (typeof args2[args2.length - 1] === "function") {
        return fs2.write(fd, buffer, ...args2);
      }
      return new Promise((resolve, reject) => {
        fs2.write(fd, buffer, ...args2, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/mkdirs/win32.js
var require_win32 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/mkdirs/win32.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    function getRootPath(p) {
      p = path.normalize(path.resolve(p)).split(path.sep);
      if (p.length > 0)
        return p[0];
      return null;
    }
    var INVALID_PATH_CHARS = /[<>:"|?*]/;
    function invalidWin32Path(p) {
      const rp = getRootPath(p);
      p = p.replace(rp, "");
      return INVALID_PATH_CHARS.test(p);
    }
    module2.exports = {
      getRootPath,
      invalidWin32Path
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/mkdirs/mkdirs.js
var require_mkdirs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/mkdirs/mkdirs.js"(exports2, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path = require("path");
    var invalidWin32Path = require_win32().invalidWin32Path;
    var o777 = parseInt("0777", 8);
    function mkdirs(p, opts, callback, made) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      if (process.platform === "win32" && invalidWin32Path(p)) {
        const errInval = new Error(p + " contains invalid WIN32 path characters.");
        errInval.code = "EINVAL";
        return callback(errInval);
      }
      let mode = opts.mode;
      const xfs = opts.fs || fs2;
      if (mode === void 0) {
        mode = o777 & ~process.umask();
      }
      if (!made)
        made = null;
      callback = callback || function() {
      };
      p = path.resolve(p);
      xfs.mkdir(p, mode, (er) => {
        if (!er) {
          made = made || p;
          return callback(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path.dirname(p) === p)
              return callback(er);
            mkdirs(path.dirname(p), opts, (er2, made2) => {
              if (er2)
                callback(er2, made2);
              else
                mkdirs(p, opts, callback, made2);
            });
            break;
          default:
            xfs.stat(p, (er2, stat) => {
              if (er2 || !stat.isDirectory())
                callback(er, made);
              else
                callback(null, made);
            });
            break;
        }
      });
    }
    module2.exports = mkdirs;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js
var require_mkdirs_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js"(exports2, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path = require("path");
    var invalidWin32Path = require_win32().invalidWin32Path;
    var o777 = parseInt("0777", 8);
    function mkdirsSync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      let mode = opts.mode;
      const xfs = opts.fs || fs2;
      if (process.platform === "win32" && invalidWin32Path(p)) {
        const errInval = new Error(p + " contains invalid WIN32 path characters.");
        errInval.code = "EINVAL";
        throw errInval;
      }
      if (mode === void 0) {
        mode = o777 & ~process.umask();
      }
      if (!made)
        made = null;
      p = path.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        if (err0.code === "ENOENT") {
          if (path.dirname(p) === p)
            throw err0;
          made = mkdirsSync(path.dirname(p), opts, made);
          mkdirsSync(p, opts, made);
        } else {
          let stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory())
            throw err0;
        }
      }
      return made;
    }
    module2.exports = mkdirsSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var mkdirs = u(require_mkdirs());
    var mkdirsSync = require_mkdirs_sync();
    module2.exports = {
      mkdirs,
      mkdirsSync,
      // alias
      mkdirp: mkdirs,
      mkdirpSync: mkdirsSync,
      ensureDir: mkdirs,
      ensureDirSync: mkdirsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var os = require("os");
    var path = require("path");
    function hasMillisResSync() {
      let tmpfile = path.join("millis-test-sync" + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path.join(os.tmpdir(), tmpfile);
      const d = /* @__PURE__ */ new Date(1435410243862);
      fs2.writeFileSync(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141");
      const fd = fs2.openSync(tmpfile, "r+");
      fs2.futimesSync(fd, d, d);
      fs2.closeSync(fd);
      return fs2.statSync(tmpfile).mtime > 1435410243e3;
    }
    function hasMillisRes(callback) {
      let tmpfile = path.join("millis-test" + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path.join(os.tmpdir(), tmpfile);
      const d = /* @__PURE__ */ new Date(1435410243862);
      fs2.writeFile(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141", (err) => {
        if (err)
          return callback(err);
        fs2.open(tmpfile, "r+", (err2, fd) => {
          if (err2)
            return callback(err2);
          fs2.futimes(fd, d, d, (err3) => {
            if (err3)
              return callback(err3);
            fs2.close(fd, (err4) => {
              if (err4)
                return callback(err4);
              fs2.stat(tmpfile, (err5, stats) => {
                if (err5)
                  return callback(err5);
                callback(null, stats.mtime > 1435410243e3);
              });
            });
          });
        });
      });
    }
    function timeRemoveMillis(timestamp) {
      if (typeof timestamp === "number") {
        return Math.floor(timestamp / 1e3) * 1e3;
      } else if (timestamp instanceof Date) {
        return new Date(Math.floor(timestamp.getTime() / 1e3) * 1e3);
      } else {
        throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
      }
    }
    function utimesMillis(path2, atime, mtime, callback) {
      fs2.open(path2, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs2.futimes(fd, atime, mtime, (futimesErr) => {
          fs2.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path2, atime, mtime) {
      const fd = fs2.openSync(path2, "r+");
      fs2.futimesSync(fd, atime, mtime);
      return fs2.closeSync(fd);
    }
    module2.exports = {
      hasMillisRes,
      hasMillisResSync,
      timeRemoveMillis,
      utimesMillis,
      utimesMillisSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/util/buffer.js
var require_buffer = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/util/buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = function(size) {
      if (typeof Buffer.allocUnsafe === "function") {
        try {
          return Buffer.allocUnsafe(size);
        } catch (e) {
          return new Buffer(size);
        }
      }
      return new Buffer(size);
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path = require("path");
    var mkdirpSync = require_mkdirs2().mkdirsSync;
    var utimesSync = require_utimes().utimesMillisSync;
    var notExist = Symbol("notExist");
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      const destStat = checkPaths(src, dest);
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path.dirname(dest);
      if (!fs2.existsSync(destParent))
        mkdirpSync(destParent);
      return startCopy(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs2.statSync : fs2.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (destStat === notExist)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs2.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      if (typeof fs2.copyFileSync === "function") {
        fs2.copyFileSync(src, dest);
        fs2.chmodSync(dest, srcStat.mode);
        if (opts.preserveTimestamps) {
          return utimesSync(dest, srcStat.atime, srcStat.mtime);
        }
        return;
      }
      return copyFileFallback(srcStat, src, dest, opts);
    }
    function copyFileFallback(srcStat, src, dest, opts) {
      const BUF_LENGTH = 64 * 1024;
      const _buff = require_buffer()(BUF_LENGTH);
      const fdr = fs2.openSync(src, "r");
      const fdw = fs2.openSync(dest, "w", srcStat.mode);
      let pos = 0;
      while (pos < srcStat.size) {
        const bytesRead = fs2.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        fs2.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
      }
      if (opts.preserveTimestamps)
        fs2.futimesSync(fdw, srcStat.atime, srcStat.mtime);
      fs2.closeSync(fdr);
      fs2.closeSync(fdw);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (destStat === notExist)
        return mkDirAndCopy(srcStat, src, dest, opts);
      if (destStat && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcStat, src, dest, opts) {
      fs2.mkdirSync(dest);
      copyDir(src, dest, opts);
      return fs2.chmodSync(dest, srcStat.mode);
    }
    function copyDir(src, dest, opts) {
      fs2.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      const destStat = checkPaths(srcItem, destItem);
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs2.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
      }
      if (destStat === notExist) {
        return fs2.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs2.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs2.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path.resolve(process.cwd(), resolvedDest);
        }
        if (isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs2.statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs2.unlinkSync(dest);
      return fs2.symlinkSync(resolvedSrc, dest);
    }
    function isSrcSubdir(src, dest) {
      const srcArray = path.resolve(src).split(path.sep);
      const destArray = path.resolve(dest).split(path.sep);
      return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true);
    }
    function checkStats(src, dest) {
      const srcStat = fs2.statSync(src);
      let destStat;
      try {
        destStat = fs2.statSync(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: notExist };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest) {
      const { srcStat, destStat } = checkStats(src, dest);
      if (destStat.ino && destStat.ino === srcStat.ino) {
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
      }
      return destStat;
    }
    module2.exports = copySync;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/copy-sync/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      copySync: require_copy_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs2 = require_fs();
    function pathExists(path) {
      return fs2.access(path).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs2.existsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path = require("path");
    var mkdirp = require_mkdirs2().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimes = require_utimes().utimesMillis;
    var notExist = Symbol("notExist");
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      checkPaths(src, dest, (err, destStat) => {
        if (err)
          return cb(err);
        if (opts.filter)
          return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
        return checkParentDir(destStat, src, dest, opts, cb);
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return startCopy(destStat, src, dest, opts, cb);
        mkdirp(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return startCopy(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include) {
          if (destStat)
            return onInclude(destStat, src, dest, opts, cb);
          return onInclude(src, dest, opts, cb);
        }
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat = opts.dereference ? fs2.stat : fs2.lstat;
      stat(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (destStat === notExist)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs2.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      if (typeof fs2.copyFile === "function") {
        return fs2.copyFile(src, dest, (err) => {
          if (err)
            return cb(err);
          return setDestModeAndTimestamps(srcStat, dest, opts, cb);
        });
      }
      return copyFileFallback(srcStat, src, dest, opts, cb);
    }
    function copyFileFallback(srcStat, src, dest, opts, cb) {
      const rs = fs2.createReadStream(src);
      rs.on("error", (err) => cb(err)).once("open", () => {
        const ws = fs2.createWriteStream(dest, { mode: srcStat.mode });
        ws.on("error", (err) => cb(err)).on("open", () => rs.pipe(ws)).once("close", () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
      });
    }
    function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
      fs2.chmod(dest, srcStat.mode, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps) {
          return utimes(dest, srcStat.atime, srcStat.mtime, cb);
        }
        return cb();
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (destStat === notExist)
        return mkDirAndCopy(srcStat, src, dest, opts, cb);
      if (destStat && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcStat, src, dest, opts, cb) {
      fs2.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return fs2.chmod(dest, srcStat.mode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs2.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      checkPaths(srcItem, destItem, (err, destStat) => {
        if (err)
          return cb(err);
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs2.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
        }
        if (destStat === notExist) {
          return fs2.symlink(resolvedSrc, dest, cb);
        } else {
          fs2.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs2.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path.resolve(process.cwd(), resolvedDest);
            }
            if (isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs2.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs2.symlink(resolvedSrc, dest, cb);
      });
    }
    function isSrcSubdir(src, dest) {
      const srcArray = path.resolve(src).split(path.sep);
      const destArray = path.resolve(dest).split(path.sep);
      return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true);
    }
    function checkStats(src, dest, cb) {
      fs2.stat(src, (err, srcStat) => {
        if (err)
          return cb(err);
        fs2.stat(dest, (err2, destStat) => {
          if (err2) {
            if (err2.code === "ENOENT")
              return cb(null, { srcStat, destStat: notExist });
            return cb(err2);
          }
          return cb(null, { srcStat, destStat });
        });
      });
    }
    function checkPaths(src, dest, cb) {
      checkStats(src, dest, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat.ino && destStat.ino === srcStat.ino) {
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));
        }
        return cb(null, destStat);
      });
    }
    module2.exports = copy;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      copy: u(require_copy())
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/remove/rimraf.js"(exports2, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path = require("path");
    var assert = require("assert");
    var isWindows = process.platform === "win32";
    function defaults(options) {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs2[m];
        m = m + "Sync";
        options[m] = options[m] || fs2[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf(p, options, cb) {
      let busyTries = 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      rimraf_(p, options, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p, options, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows) {
          return fixWinEPERM(p, options, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir(p, options, er, cb);
        }
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir(p, options, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      if (er) {
        assert(er instanceof Error);
      }
      options.chmod(p, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options, er, cb);
            } else {
              options.unlink(p, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p, options, er) {
      let stats;
      assert(p);
      assert(options);
      if (er) {
        assert(er instanceof Error);
      }
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync(p, options, er);
      } else {
        options.unlinkSync(p);
      }
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p, options, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options.rmdir(p, cb);
        files.forEach((f) => {
          rimraf(path.join(p, f), options, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options.rmdir(p, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p, options) {
      let st;
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows) {
          fixWinEPERMSync(p, options, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync(p, options, null);
        } else {
          options.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync(p, options, er);
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p, options);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));
      if (isWindows) {
        const startTime = Date.now();
        do {
          try {
            const ret = options.rmdirSync(p, options);
            return ret;
          } catch (er) {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options.rmdirSync(p, options);
        return ret;
      }
    }
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var rimraf = require_rimraf();
    module2.exports = {
      remove: u(rimraf),
      removeSync: rimraf.sync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs2 = require("fs");
    var path = require("path");
    var mkdir = require_mkdirs2();
    var remove = require_remove();
    var emptyDir = u(function emptyDir2(dir, callback) {
      callback = callback || function() {
      };
      fs2.readdir(dir, (err, items) => {
        if (err)
          return mkdir.mkdirs(dir, callback);
        items = items.map((item) => path.join(dir, item));
        deleteItem();
        function deleteItem() {
          const item = items.pop();
          if (!item)
            return callback();
          remove.remove(item, (err2) => {
            if (err2)
              return callback(err2);
            deleteItem();
          });
        }
      });
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs2.readdirSync(dir);
      } catch (err) {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path = require("path");
    var fs2 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function createFile(file, callback) {
      function makeFile() {
        fs2.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs2.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path.dirname(file);
        pathExists(dir, (err2, dirExists) => {
          if (err2)
            return callback(err2);
          if (dirExists)
            return makeFile();
          mkdir.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeFile();
          });
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs2.statSync(file);
      } catch (e) {
      }
      if (stats && stats.isFile())
        return;
      const dir = path.dirname(file);
      if (!fs2.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs2.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path = require("path");
    var fs2 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs2.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        fs2.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureLink");
            return callback(err2);
          }
          const dir = path.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      const destinationExists = fs2.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      try {
        fs2.lstatSync(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path.dirname(dstpath);
      const dirExists = fs2.existsSync(dir);
      if (dirExists)
        return fs2.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs2.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fs2 = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path.isAbsolute(srcpath)) {
        return fs2.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            "toCwd": srcpath,
            "toDst": srcpath
          });
        });
      } else {
        const dstdir = path.dirname(dstpath);
        const relativeToDst = path.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              "toCwd": relativeToDst,
              "toDst": srcpath
            });
          } else {
            return fs2.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                "toCwd": srcpath,
                "toDst": path.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path.isAbsolute(srcpath)) {
        exists = fs2.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          "toCwd": srcpath,
          "toDst": srcpath
        };
      } else {
        const dstdir = path.dirname(dstpath);
        const relativeToDst = path.join(dstdir, srcpath);
        exists = fs2.existsSync(relativeToDst);
        if (exists) {
          return {
            "toCwd": relativeToDst,
            "toDst": srcpath
          };
        } else {
          exists = fs2.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            "toCwd": srcpath,
            "toDst": path.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs2.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs2.lstatSync(srcpath);
      } catch (e) {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path = require("path");
    var fs2 = require_graceful_fs();
    var _mkdirs = require_mkdirs2();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        symlinkPaths(srcpath, dstpath, (err2, relative) => {
          if (err2)
            return callback(err2);
          srcpath = relative.toDst;
          symlinkType(relative.toCwd, type, (err3, type2) => {
            if (err3)
              return callback(err3);
            const dir = path.dirname(dstpath);
            pathExists(dir, (err4, dirExists) => {
              if (err4)
                return callback(err4);
              if (dirExists)
                return fs2.symlink(srcpath, dstpath, type2, callback);
              mkdirs(dir, (err5) => {
                if (err5)
                  return callback(err5);
                fs2.symlink(srcpath, dstpath, type2, callback);
              });
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      const destinationExists = fs2.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path.dirname(dstpath);
      const exists = fs2.existsSync(dir);
      if (exists)
        return fs2.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs2.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var file = require_file();
    var link = require_link();
    var symlink = require_symlink();
    module2.exports = {
      // file
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      // link
      createLink: link.createLink,
      createLinkSync: link.createLinkSync,
      ensureLink: link.createLink,
      ensureLinkSync: link.createLinkSync,
      // symlink
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/jsonfile@4.0.0/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../../node_modules/.pnpm/jsonfile@4.0.0/node_modules/jsonfile/index.js"(exports2, module2) {
    "use strict";
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    function readFile(file, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      if (typeof options === "string") {
        options = { encoding: options };
      }
      options = options || {};
      var fs2 = options.fs || _fs;
      var shouldThrow = true;
      if ("throws" in options) {
        shouldThrow = options.throws;
      }
      fs2.readFile(file, options, function(err, data) {
        if (err)
          return callback(err);
        data = stripBom(data);
        var obj;
        try {
          obj = JSON.parse(data, options ? options.reviver : null);
        } catch (err2) {
          if (shouldThrow) {
            err2.message = file + ": " + err2.message;
            return callback(err2);
          } else {
            return callback(null, null);
          }
        }
        callback(null, obj);
      });
    }
    function readFileSync(file, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { encoding: options };
      }
      var fs2 = options.fs || _fs;
      var shouldThrow = true;
      if ("throws" in options) {
        shouldThrow = options.throws;
      }
      try {
        var content = fs2.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = file + ": " + err.message;
          throw err;
        } else {
          return null;
        }
      }
    }
    function stringify(obj, options) {
      var spaces;
      var EOL = "\n";
      if (typeof options === "object" && options !== null) {
        if (options.spaces) {
          spaces = options.spaces;
        }
        if (options.EOL) {
          EOL = options.EOL;
        }
      }
      var str = JSON.stringify(obj, options ? options.replacer : null, spaces);
      return str.replace(/\n/g, EOL) + EOL;
    }
    function writeFile(file, obj, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      options = options || {};
      var fs2 = options.fs || _fs;
      var str = "";
      try {
        str = stringify(obj, options);
      } catch (err) {
        if (callback)
          callback(err, null);
        return;
      }
      fs2.writeFile(file, str, options, callback);
    }
    function writeFileSync2(file, obj, options) {
      options = options || {};
      var fs2 = options.fs || _fs;
      var str = stringify(obj, options);
      return fs2.writeFileSync(file, str, options);
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      content = content.replace(/^\uFEFF/, "");
      return content;
    }
    var jsonfile = {
      readFile,
      readFileSync,
      writeFile,
      writeFileSync: writeFileSync2
    };
    module2.exports = jsonfile;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: u(jsonFile.readFile),
      readJsonSync: jsonFile.readFileSync,
      writeJson: u(jsonFile.writeFile),
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    var jsonFile = require_jsonfile2();
    function outputJson(file, data, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      const dir = path.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return jsonFile.writeJson(file, data, options, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          jsonFile.writeJson(file, data, options, callback);
        });
      });
    }
    module2.exports = outputJson;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path = require("path");
    var mkdir = require_mkdirs2();
    var jsonFile = require_jsonfile2();
    function outputJsonSync(file, data, options) {
      const dir = path.dirname(file);
      if (!fs2.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      jsonFile.writeJsonSync(file, data, options);
    }
    module2.exports = outputJsonSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/move-sync/index.js"(exports2, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path = require("path");
    var copySync = require_copy_sync2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs2().mkdirsSync;
    var buffer = require_buffer();
    function moveSync(src, dest, options) {
      options = options || {};
      const overwrite = options.overwrite || options.clobber || false;
      src = path.resolve(src);
      dest = path.resolve(dest);
      if (src === dest)
        return fs2.accessSync(src);
      if (isSrcSubdir(src, dest))
        throw new Error(`Cannot move '${src}' into itself '${dest}'.`);
      mkdirpSync(path.dirname(dest));
      tryRenameSync();
      function tryRenameSync() {
        if (overwrite) {
          try {
            return fs2.renameSync(src, dest);
          } catch (err) {
            if (err.code === "ENOTEMPTY" || err.code === "EEXIST" || err.code === "EPERM") {
              removeSync(dest);
              options.overwrite = false;
              return moveSync(src, dest, options);
            }
            if (err.code !== "EXDEV")
              throw err;
            return moveSyncAcrossDevice(src, dest, overwrite);
          }
        } else {
          try {
            fs2.linkSync(src, dest);
            return fs2.unlinkSync(src);
          } catch (err) {
            if (err.code === "EXDEV" || err.code === "EISDIR" || err.code === "EPERM" || err.code === "ENOTSUP") {
              return moveSyncAcrossDevice(src, dest, overwrite);
            }
            throw err;
          }
        }
      }
    }
    function moveSyncAcrossDevice(src, dest, overwrite) {
      const stat = fs2.statSync(src);
      if (stat.isDirectory()) {
        return moveDirSyncAcrossDevice(src, dest, overwrite);
      } else {
        return moveFileSyncAcrossDevice(src, dest, overwrite);
      }
    }
    function moveFileSyncAcrossDevice(src, dest, overwrite) {
      const BUF_LENGTH = 64 * 1024;
      const _buff = buffer(BUF_LENGTH);
      const flags = overwrite ? "w" : "wx";
      const fdr = fs2.openSync(src, "r");
      const stat = fs2.fstatSync(fdr);
      const fdw = fs2.openSync(dest, flags, stat.mode);
      let pos = 0;
      while (pos < stat.size) {
        const bytesRead = fs2.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        fs2.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
      }
      fs2.closeSync(fdr);
      fs2.closeSync(fdw);
      return fs2.unlinkSync(src);
    }
    function moveDirSyncAcrossDevice(src, dest, overwrite) {
      const options = {
        overwrite: false
      };
      if (overwrite) {
        removeSync(dest);
        tryCopySync();
      } else {
        tryCopySync();
      }
      function tryCopySync() {
        copySync(src, dest, options);
        return removeSync(src);
      }
    }
    function isSrcSubdir(src, dest) {
      try {
        return fs2.statSync(src).isDirectory() && src !== dest && dest.indexOf(src) > -1 && dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] === path.basename(src);
      } catch (e) {
        return false;
      }
    }
    module2.exports = {
      moveSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/move/index.js
var require_move = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs2 = require_graceful_fs();
    var path = require("path");
    var copy = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp = require_mkdirs2().mkdirp;
    var pathExists = require_path_exists().pathExists;
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const overwrite = opts.overwrite || opts.clobber || false;
      src = path.resolve(src);
      dest = path.resolve(dest);
      if (src === dest)
        return fs2.access(src, cb);
      fs2.stat(src, (err, st) => {
        if (err)
          return cb(err);
        if (st.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`));
        }
        mkdirp(path.dirname(dest), (err2) => {
          if (err2)
            return cb(err2);
          return doRename(src, dest, overwrite, cb);
        });
      });
    }
    function doRename(src, dest, overwrite, cb) {
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs2.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    function isSrcSubdir(src, dest) {
      const srcArray = src.split(path.sep);
      const destArray = dest.split(path.sep);
      return srcArray.reduce((acc, current, i) => {
        return acc && destArray[i] === current;
      }, true);
    }
    module2.exports = {
      move: u(move)
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/output/index.js
var require_output = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/output/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs2 = require_graceful_fs();
    var path = require("path");
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs2.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs2.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args2) {
      const dir = path.dirname(file);
      if (fs2.existsSync(dir)) {
        return fs2.writeFileSync(file, ...args2);
      }
      mkdir.mkdirsSync(dir);
      fs2.writeFileSync(file, ...args2);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.1/node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.assign(
      {},
      // Export promiseified graceful-fs:
      require_fs(),
      // Export extra methods:
      require_copy_sync2(),
      require_copy2(),
      require_empty(),
      require_ensure(),
      require_json(),
      require_mkdirs2(),
      require_move_sync(),
      require_move(),
      require_output(),
      require_path_exists(),
      require_remove()
    );
    var fs2 = require("fs");
    if (Object.getOwnPropertyDescriptor(fs2, "promises")) {
      Object.defineProperty(module2.exports, "promises", {
        get() {
          return fs2.promises;
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Text.js
var require_Text = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Text.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __asyncValues = exports2 && exports2.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __await = exports2 && exports2.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncDelegator = exports2 && exports2.__asyncDelegator || function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    var __asyncGenerator = exports2 && exports2.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Text = exports2.NewlineKind = exports2.Encoding = void 0;
    var os = __importStar(require("os"));
    var Encoding;
    (function(Encoding2) {
      Encoding2["Utf8"] = "utf8";
    })(Encoding || (exports2.Encoding = Encoding = {}));
    var NewlineKind;
    (function(NewlineKind2) {
      NewlineKind2["CrLf"] = "\r\n";
      NewlineKind2["Lf"] = "\n";
      NewlineKind2["OsDefault"] = "os";
    })(NewlineKind || (exports2.NewlineKind = NewlineKind = {}));
    var NEWLINE_REGEX = /\r\n|\n\r|\r|\n/g;
    var NEWLINE_AT_END_REGEX = /(\r\n|\n\r|\r|\n)$/;
    function* readLinesFromChunk(chunk, encoding, ignoreEmptyLines, state) {
      if (!chunk) {
        return;
      }
      const remaining = state.remaining + (typeof chunk === "string" ? chunk : chunk.toString(encoding));
      let startIndex = 0;
      const matches = remaining.matchAll(NEWLINE_REGEX);
      for (const match of matches) {
        const endIndex = match.index;
        if (startIndex !== endIndex || !ignoreEmptyLines) {
          yield remaining.substring(startIndex, endIndex);
        }
        startIndex = endIndex + match[0].length;
      }
      state.remaining = remaining.substring(startIndex);
    }
    var Text = class _Text {
      /**
       * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
       * all matches are replaced, rather than just the first match.
       * @param input         - The string to be modified
       * @param searchValue   - The value to search for
       * @param replaceValue  - The replacement text
       */
      static replaceAll(input, searchValue, replaceValue) {
        return input.split(searchValue).join(replaceValue);
      }
      /**
       * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.
       */
      static convertToCrLf(input) {
        return input.replace(_Text._newLineRegEx, "\r\n");
      }
      /**
       * Converts all newlines in the provided string to use POSIX-style LF end of line characters.
       *
       * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
       */
      static convertToLf(input) {
        return input.replace(_Text._newLineRegEx, "\n");
      }
      /**
       * Converts all newlines in the provided string to use the specified newline type.
       */
      static convertTo(input, newlineKind) {
        return input.replace(_Text._newLineRegEx, _Text.getNewline(newlineKind));
      }
      /**
       * Returns the newline character sequence for the specified `NewlineKind`.
       */
      static getNewline(newlineKind) {
        switch (newlineKind) {
          case NewlineKind.CrLf:
            return "\r\n";
          case NewlineKind.Lf:
            return "\n";
          case NewlineKind.OsDefault:
            return os.EOL;
          default:
            throw new Error("Unsupported newline kind");
        }
      }
      /**
       * Append characters to the end of a string to ensure the result has a minimum length.
       * @remarks
       * If the string length already exceeds the minimum length, then the string is unchanged.
       * The string is not truncated.
       */
      static padEnd(s, minimumLength, paddingCharacter = " ") {
        if (paddingCharacter.length !== 1) {
          throw new Error("The paddingCharacter parameter must be a single character.");
        }
        if (s.length < minimumLength) {
          const paddingArray = new Array(minimumLength - s.length);
          paddingArray.unshift(s);
          return paddingArray.join(paddingCharacter);
        } else {
          return s;
        }
      }
      /**
       * Append characters to the start of a string to ensure the result has a minimum length.
       * @remarks
       * If the string length already exceeds the minimum length, then the string is unchanged.
       * The string is not truncated.
       */
      static padStart(s, minimumLength, paddingCharacter = " ") {
        if (paddingCharacter.length !== 1) {
          throw new Error("The paddingCharacter parameter must be a single character.");
        }
        if (s.length < minimumLength) {
          const paddingArray = new Array(minimumLength - s.length);
          paddingArray.push(s);
          return paddingArray.join(paddingCharacter);
        } else {
          return s;
        }
      }
      /**
       * If the string is longer than maximumLength characters, truncate it to that length
       * using "..." to indicate the truncation.
       *
       * @remarks
       * For example truncateWithEllipsis('1234578', 5) would produce '12...'.
       */
      static truncateWithEllipsis(s, maximumLength) {
        if (maximumLength < 0) {
          throw new Error("The maximumLength cannot be a negative number");
        }
        if (s.length <= maximumLength) {
          return s;
        }
        if (s.length <= 3) {
          return s.substring(0, maximumLength);
        }
        return s.substring(0, maximumLength - 3) + "...";
      }
      /**
       * Returns the input string with a trailing `\n` character appended, if not already present.
       */
      static ensureTrailingNewline(s, newlineKind = NewlineKind.Lf) {
        if (_Text._newLineAtEndRegEx.test(s)) {
          return s;
        }
        return s + newlineKind;
      }
      /**
       * Escapes a string so that it can be treated as a literal string when used in a regular expression.
       */
      static escapeRegExp(literal) {
        return literal.replace(/[^A-Za-z0-9_]/g, "\\$&");
      }
      /**
       * Read lines from an iterable object that returns strings or buffers, and return a generator that
       * produces the lines as strings. The lines will not include the newline characters.
       *
       * @param iterable - An iterable object that returns strings or buffers
       * @param options - Options used when reading the lines from the provided iterable
       */
      static readLinesFromIterableAsync(iterable, options = {}) {
        return __asyncGenerator(this, arguments, function* readLinesFromIterableAsync_1() {
          var _a, e_1, _b, _c;
          const { encoding = Encoding.Utf8, ignoreEmptyLines = false } = options;
          const state = { remaining: "" };
          try {
            for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), _a = iterable_1_1.done, !_a; _d = true) {
              _c = iterable_1_1.value;
              _d = false;
              const chunk = _c;
              yield __await(yield* __asyncDelegator(__asyncValues(readLinesFromChunk(chunk, encoding, ignoreEmptyLines, state))));
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = iterable_1.return))
                yield __await(_b.call(iterable_1));
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          const remaining = state.remaining;
          if (remaining.length) {
            yield yield __await(remaining);
          }
        });
      }
      /**
       * Read lines from an iterable object that returns strings or buffers, and return a generator that
       * produces the lines as strings. The lines will not include the newline characters.
       *
       * @param iterable - An iterable object that returns strings or buffers
       * @param options - Options used when reading the lines from the provided iterable
       */
      static *readLinesFromIterable(iterable, options = {}) {
        const { encoding = Encoding.Utf8, ignoreEmptyLines = false } = options;
        const state = { remaining: "" };
        for (const chunk of iterable) {
          yield* readLinesFromChunk(chunk, encoding, ignoreEmptyLines, state);
        }
        const remaining = state.remaining;
        if (remaining.length) {
          yield remaining;
        }
      }
      /**
       * Returns a new string that is the input string with the order of characters reversed.
       */
      static reverse(s) {
        return s.split("").reduce((newString, char) => char + newString, "");
      }
    };
    exports2.Text = Text;
    Text._newLineRegEx = NEWLINE_REGEX;
    Text._newLineAtEndRegEx = NEWLINE_AT_END_REGEX;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/PosixModeBits.js
var require_PosixModeBits = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/PosixModeBits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PosixModeBits = void 0;
    var PosixModeBits;
    (function(PosixModeBits2) {
      PosixModeBits2[PosixModeBits2["UserRead"] = 256] = "UserRead";
      PosixModeBits2[PosixModeBits2["UserWrite"] = 128] = "UserWrite";
      PosixModeBits2[PosixModeBits2["UserExecute"] = 64] = "UserExecute";
      PosixModeBits2[PosixModeBits2["GroupRead"] = 32] = "GroupRead";
      PosixModeBits2[PosixModeBits2["GroupWrite"] = 16] = "GroupWrite";
      PosixModeBits2[PosixModeBits2["GroupExecute"] = 8] = "GroupExecute";
      PosixModeBits2[PosixModeBits2["OthersRead"] = 4] = "OthersRead";
      PosixModeBits2[PosixModeBits2["OthersWrite"] = 2] = "OthersWrite";
      PosixModeBits2[PosixModeBits2["OthersExecute"] = 1] = "OthersExecute";
      PosixModeBits2[PosixModeBits2["None"] = 0] = "None";
      PosixModeBits2[PosixModeBits2["AllRead"] = 292] = "AllRead";
      PosixModeBits2[PosixModeBits2["AllWrite"] = 146] = "AllWrite";
      PosixModeBits2[PosixModeBits2["AllExecute"] = 73] = "AllExecute";
    })(PosixModeBits || (exports2.PosixModeBits = PosixModeBits = {}));
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/LegacyAdapters.js
var require_LegacyAdapters = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/LegacyAdapters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LegacyAdapters = void 0;
    var LegacyAdapters = class _LegacyAdapters {
      static convertCallbackToPromise(fn, arg1, arg2, arg3, arg4) {
        return new Promise((resolve, reject) => {
          const cb = (error, result) => {
            if (error) {
              reject(_LegacyAdapters.scrubError(error));
            } else {
              resolve(result);
            }
          };
          try {
            if (arg1 !== void 0 && arg2 !== void 0 && arg3 !== void 0 && arg4 !== void 0) {
              fn(arg1, arg2, arg3, arg4, cb);
            } else if (arg1 !== void 0 && arg2 !== void 0 && arg3 !== void 0) {
              fn(arg1, arg2, arg3, cb);
            } else if (arg1 !== void 0 && arg2 !== void 0) {
              fn(arg1, arg2, cb);
            } else if (arg1 !== void 0) {
              fn(arg1, cb);
            } else {
              fn(cb);
            }
          } catch (e) {
            reject(e);
          }
        });
      }
      /**
       * Normalizes an object into an `Error` object.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static scrubError(error) {
        if (error instanceof Error) {
          return error;
        } else if (typeof error === "string") {
          return new Error(error);
        } else {
          const errorObject = new Error("An error occurred.");
          errorObject.errorData = error;
          return errorObject;
        }
      }
    };
    exports2.LegacyAdapters = LegacyAdapters;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/FileSystem.js
var require_FileSystem = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/FileSystem.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileSystem = exports2.AlreadyExistsBehavior = void 0;
    var nodeJsPath = __importStar(require("path"));
    var fs2 = __importStar(require("fs"));
    var fsx = __importStar(require_lib());
    var Text_1 = require_Text();
    var PosixModeBits_1 = require_PosixModeBits();
    var LegacyAdapters_1 = require_LegacyAdapters();
    var AlreadyExistsBehavior;
    (function(AlreadyExistsBehavior2) {
      AlreadyExistsBehavior2["Overwrite"] = "overwrite";
      AlreadyExistsBehavior2["Error"] = "error";
      AlreadyExistsBehavior2["Ignore"] = "ignore";
    })(AlreadyExistsBehavior || (exports2.AlreadyExistsBehavior = AlreadyExistsBehavior = {}));
    var MOVE_DEFAULT_OPTIONS = {
      overwrite: true,
      ensureFolderExists: false
    };
    var READ_FOLDER_DEFAULT_OPTIONS = {
      absolutePaths: false
    };
    var WRITE_FILE_DEFAULT_OPTIONS = {
      ensureFolderExists: false,
      convertLineEndings: void 0,
      encoding: Text_1.Encoding.Utf8
    };
    var APPEND_TO_FILE_DEFAULT_OPTIONS = Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS);
    var READ_FILE_DEFAULT_OPTIONS = {
      encoding: Text_1.Encoding.Utf8,
      convertLineEndings: void 0
    };
    var COPY_FILE_DEFAULT_OPTIONS = {
      alreadyExistsBehavior: AlreadyExistsBehavior.Overwrite
    };
    var COPY_FILES_DEFAULT_OPTIONS = {
      alreadyExistsBehavior: AlreadyExistsBehavior.Overwrite
    };
    var DELETE_FILE_DEFAULT_OPTIONS = {
      throwIfNotExists: false
    };
    var FileSystem = class _FileSystem {
      // ===============
      // COMMON OPERATIONS
      // ===============
      /**
       * Returns true if the path exists on disk.
       * Behind the scenes it uses `fs.existsSync()`.
       * @remarks
       * There is a debate about the fact that after `fs.existsSync()` returns true,
       * the file might be deleted before fs.readSync() is called, which would imply that everybody
       * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.
       * We find this to be unpersuasive, since "unexceptional exceptions" really hinder the
       * break-on-exception debugging experience. Also, throwing/catching is generally slow.
       * @param path - The absolute or relative path to the filesystem object.
       */
      static exists(path) {
        return _FileSystem._wrapException(() => {
          return fsx.existsSync(path);
        });
      }
      /**
       * An async version of {@link FileSystem.exists}.
       */
      static async existsAsync(path) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return new Promise((resolve) => {
            fsx.exists(path, resolve);
          });
        });
      }
      /**
       * Gets the statistics for a particular filesystem object.
       * If the path is a link, this function follows the link and returns statistics about the link target.
       * Behind the scenes it uses `fs.statSync()`.
       * @param path - The absolute or relative path to the filesystem object.
       */
      static getStatistics(path) {
        return _FileSystem._wrapException(() => {
          return fsx.statSync(path);
        });
      }
      /**
       * An async version of {@link FileSystem.getStatistics}.
       */
      static async getStatisticsAsync(path) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return fsx.stat(path);
        });
      }
      /**
       * Updates the accessed and modified timestamps of the filesystem object referenced by path.
       * Behind the scenes it uses `fs.utimesSync()`.
       * The caller should specify both times in the `times` parameter.
       * @param path - The path of the file that should be modified.
       * @param times - The times that the object should be updated to reflect.
       */
      static updateTimes(path, times) {
        return _FileSystem._wrapException(() => {
          fsx.utimesSync(path, times.accessedTime, times.modifiedTime);
        });
      }
      /**
       * An async version of {@link FileSystem.updateTimes}.
       */
      static async updateTimesAsync(path, times) {
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.utimes(path, times.accessedTime, times.modifiedTime);
        });
      }
      /**
       * Changes the permissions (i.e. file mode bits) for a filesystem object.
       * Behind the scenes it uses `fs.chmodSync()`.
       * @param path - The absolute or relative path to the object that should be updated.
       * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
       */
      static changePosixModeBits(path, modeBits) {
        _FileSystem._wrapException(() => {
          fs2.chmodSync(path, modeBits);
        });
      }
      /**
       * An async version of {@link FileSystem.changePosixModeBits}.
       */
      static async changePosixModeBitsAsync(path, mode) {
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.chmod(path, mode);
        });
      }
      /**
       * Retrieves the permissions (i.e. file mode bits) for a filesystem object.
       * Behind the scenes it uses `fs.chmodSync()`.
       * @param path - The absolute or relative path to the object that should be updated.
       *
       * @remarks
       * This calls {@link FileSystem.getStatistics} to get the POSIX mode bits.
       * If statistics in addition to the mode bits are needed, it is more efficient
       * to call {@link FileSystem.getStatistics} directly instead.
       */
      static getPosixModeBits(path) {
        return _FileSystem._wrapException(() => {
          return _FileSystem.getStatistics(path).mode;
        });
      }
      /**
       * An async version of {@link FileSystem.getPosixModeBits}.
       */
      static async getPosixModeBitsAsync(path) {
        return await _FileSystem._wrapExceptionAsync(async () => {
          return (await _FileSystem.getStatisticsAsync(path)).mode;
        });
      }
      /**
       * Returns a 10-character string representation of a PosixModeBits value similar to what
       * would be displayed by a command such as "ls -l" on a POSIX-like operating system.
       * @remarks
       * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as "-rw-rw-rw-".
       * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
       */
      static formatPosixModeBits(modeBits) {
        let result = "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.UserRead ? "r" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.UserWrite ? "w" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.UserExecute ? "x" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.GroupRead ? "r" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.GroupWrite ? "w" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.GroupExecute ? "x" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.OthersRead ? "r" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.OthersWrite ? "w" : "-";
        result += modeBits & PosixModeBits_1.PosixModeBits.OthersExecute ? "x" : "-";
        return result;
      }
      /**
       * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.
       * Behind the scenes it uses `fs-extra.moveSync()`
       */
      static move(options) {
        _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
          try {
            fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(options.destinationPath);
              _FileSystem.ensureFolder(folderPath);
              fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            } else {
              throw error;
            }
          }
        });
      }
      /**
       * An async version of {@link FileSystem.move}.
       */
      static async moveAsync(options) {
        await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
          try {
            await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(options.destinationPath);
              await _FileSystem.ensureFolderAsync(nodeJsPath.dirname(folderPath));
              await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            } else {
              throw error;
            }
          }
        });
      }
      // ===============
      // FOLDER OPERATIONS
      // ===============
      /**
       * Recursively creates a folder at a given path.
       * Behind the scenes is uses `fs-extra.ensureDirSync()`.
       * @remarks
       * Throws an exception if anything in the folderPath is not a folder.
       * @param folderPath - The absolute or relative path of the folder which should be created.
       */
      static ensureFolder(folderPath) {
        _FileSystem._wrapException(() => {
          fsx.ensureDirSync(folderPath);
        });
      }
      /**
       * An async version of {@link FileSystem.ensureFolder}.
       */
      static async ensureFolderAsync(folderPath) {
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.ensureDir(folderPath);
        });
      }
      /**
       * Reads the names of folder entries, not including "." or "..".
       * Behind the scenes it uses `fs.readdirSync()`.
       * @param folderPath - The absolute or relative path to the folder which should be read.
       * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`
       */
      static readFolderItemNames(folderPath, options) {
        return _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
          const fileNames = fsx.readdirSync(folderPath);
          if (options.absolutePaths) {
            return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
          } else {
            return fileNames;
          }
        });
      }
      /**
       * An async version of {@link FileSystem.readFolderItemNames}.
       */
      static async readFolderItemNamesAsync(folderPath, options) {
        return await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
          const fileNames = await fsx.readdir(folderPath);
          if (options.absolutePaths) {
            return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
          } else {
            return fileNames;
          }
        });
      }
      /**
       * Reads the contents of the folder, not including "." or "..", returning objects including the
       * entry names and types.
       * Behind the scenes it uses `fs.readdirSync()`.
       * @param folderPath - The absolute or relative path to the folder which should be read.
       * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`
       */
      static readFolderItems(folderPath, options) {
        return _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
          const folderEntries = fsx.readdirSync(folderPath, { withFileTypes: true });
          if (options.absolutePaths) {
            return folderEntries.map((folderEntry) => {
              folderEntry.name = nodeJsPath.resolve(folderPath, folderEntry.name);
              return folderEntry;
            });
          } else {
            return folderEntries;
          }
        });
      }
      /**
       * An async version of {@link FileSystem.readFolderItems}.
       */
      static async readFolderItemsAsync(folderPath, options) {
        return await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
          const folderEntries = await LegacyAdapters_1.LegacyAdapters.convertCallbackToPromise(fs2.readdir, folderPath, { withFileTypes: true });
          if (options.absolutePaths) {
            return folderEntries.map((folderEntry) => {
              folderEntry.name = nodeJsPath.resolve(folderPath, folderEntry.name);
              return folderEntry;
            });
          } else {
            return folderEntries;
          }
        });
      }
      /**
       * Deletes a folder, including all of its contents.
       * Behind the scenes is uses `fs-extra.removeSync()`.
       * @remarks
       * Does not throw if the folderPath does not exist.
       * @param folderPath - The absolute or relative path to the folder which should be deleted.
       */
      static deleteFolder(folderPath) {
        _FileSystem._wrapException(() => {
          fsx.removeSync(folderPath);
        });
      }
      /**
       * An async version of {@link FileSystem.deleteFolder}.
       */
      static async deleteFolderAsync(folderPath) {
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.remove(folderPath);
        });
      }
      /**
       * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.
       * Behind the scenes it uses `fs-extra.emptyDirSync()`.
       * @remarks
       * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder
       * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.
       * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.
       */
      static ensureEmptyFolder(folderPath) {
        _FileSystem._wrapException(() => {
          fsx.emptyDirSync(folderPath);
        });
      }
      /**
       * An async version of {@link FileSystem.ensureEmptyFolder}.
       */
      static async ensureEmptyFolderAsync(folderPath) {
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.emptyDir(folderPath);
        });
      }
      // ===============
      // FILE OPERATIONS
      // ===============
      /**
       * Writes a text string to a file on disk, overwriting the file if it already exists.
       * Behind the scenes it uses `fs.writeFileSync()`.
       * @remarks
       * Throws an error if the folder doesn't exist, unless ensureFolder=true.
       * @param filePath - The absolute or relative path of the file.
       * @param contents - The text that should be written to the file.
       * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
       */
      static writeFile(filePath, contents, options) {
        _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
          }
          try {
            fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(filePath);
              _FileSystem.ensureFolder(folderPath);
              fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
            } else {
              throw error;
            }
          }
        });
      }
      /**
       * Writes the contents of multiple Uint8Arrays to a file on disk, overwriting the file if it already exists.
       * Behind the scenes it uses `fs.writevSync()`.
       *
       * This API is useful for writing large files efficiently, especially if the input is being concatenated from
       * multiple sources.
       *
       * @remarks
       * Throws an error if the folder doesn't exist, unless ensureFolder=true.
       * @param filePath - The absolute or relative path of the file.
       * @param contents - The content that should be written to the file.
       * @param options - Optional settings that can change the behavior.
       */
      static writeBuffersToFile(filePath, contents, options) {
        _FileSystem._wrapException(() => {
          const toCopy = [...contents];
          let fd;
          try {
            fd = fsx.openSync(filePath, "w");
          } catch (error) {
            if (!(options === null || options === void 0 ? void 0 : options.ensureFolderExists) || !_FileSystem.isNotExistError(error)) {
              throw error;
            }
            const folderPath = nodeJsPath.dirname(filePath);
            _FileSystem.ensureFolder(folderPath);
            fd = fsx.openSync(filePath, "w");
          }
          try {
            while (toCopy.length) {
              let bytesWritten = fsx.writevSync(fd, toCopy);
              let buffersWritten = 0;
              while (buffersWritten < toCopy.length) {
                const bytesInCurrentBuffer = toCopy[buffersWritten].byteLength;
                if (bytesWritten < bytesInCurrentBuffer) {
                  toCopy[buffersWritten] = toCopy[buffersWritten].subarray(bytesWritten);
                  break;
                }
                bytesWritten -= bytesInCurrentBuffer;
                buffersWritten++;
              }
              if (buffersWritten > 0) {
                toCopy.splice(0, buffersWritten);
              }
            }
          } finally {
            fsx.closeSync(fd);
          }
        });
      }
      /**
       * An async version of {@link FileSystem.writeFile}.
       */
      static async writeFileAsync(filePath, contents, options) {
        await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
          }
          try {
            await fsx.writeFile(filePath, contents, { encoding: options.encoding });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(filePath);
              await _FileSystem.ensureFolderAsync(folderPath);
              await fsx.writeFile(filePath, contents, { encoding: options.encoding });
            } else {
              throw error;
            }
          }
        });
      }
      /**
       * An async version of {@link FileSystem.writeBuffersToFile}.
       */
      static async writeBuffersToFileAsync(filePath, contents, options) {
        await _FileSystem._wrapExceptionAsync(async () => {
          const toCopy = [...contents];
          let handle;
          try {
            handle = await fs2.promises.open(filePath, "w");
          } catch (error) {
            if (!(options === null || options === void 0 ? void 0 : options.ensureFolderExists) || !_FileSystem.isNotExistError(error)) {
              throw error;
            }
            const folderPath = nodeJsPath.dirname(filePath);
            await _FileSystem.ensureFolderAsync(folderPath);
            handle = await fs2.promises.open(filePath, "w");
          }
          try {
            while (toCopy.length) {
              let bytesWritten = (await handle.writev(toCopy)).bytesWritten;
              let buffersWritten = 0;
              while (buffersWritten < toCopy.length) {
                const bytesInCurrentBuffer = toCopy[buffersWritten].byteLength;
                if (bytesWritten < bytesInCurrentBuffer) {
                  toCopy[buffersWritten] = toCopy[buffersWritten].subarray(bytesWritten);
                  break;
                }
                bytesWritten -= bytesInCurrentBuffer;
                buffersWritten++;
              }
              if (buffersWritten > 0) {
                toCopy.splice(0, buffersWritten);
              }
            }
          } finally {
            await handle.close();
          }
        });
      }
      /**
       * Writes a text string to a file on disk, appending to the file if it already exists.
       * Behind the scenes it uses `fs.appendFileSync()`.
       * @remarks
       * Throws an error if the folder doesn't exist, unless ensureFolder=true.
       * @param filePath - The absolute or relative path of the file.
       * @param contents - The text that should be written to the file.
       * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
       */
      static appendToFile(filePath, contents, options) {
        _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
          }
          try {
            fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(filePath);
              _FileSystem.ensureFolder(folderPath);
              fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
            } else {
              throw error;
            }
          }
        });
      }
      /**
       * An async version of {@link FileSystem.appendToFile}.
       */
      static async appendToFileAsync(filePath, contents, options) {
        await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
          }
          try {
            await fsx.appendFile(filePath, contents, { encoding: options.encoding });
          } catch (error) {
            if (options.ensureFolderExists) {
              if (!_FileSystem.isNotExistError(error)) {
                throw error;
              }
              const folderPath = nodeJsPath.dirname(filePath);
              await _FileSystem.ensureFolderAsync(folderPath);
              await fsx.appendFile(filePath, contents, { encoding: options.encoding });
            } else {
              throw error;
            }
          }
        });
      }
      /**
       * Reads the contents of a file into a string.
       * Behind the scenes it uses `fs.readFileSync()`.
       * @param filePath - The relative or absolute path to the file whose contents should be read.
       * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`
       */
      static readFile(filePath, options) {
        return _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
          let contents = _FileSystem.readFileToBuffer(filePath).toString(options.encoding);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
          }
          return contents;
        });
      }
      /**
       * An async version of {@link FileSystem.readFile}.
       */
      static async readFileAsync(filePath, options) {
        return await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
          let contents = (await _FileSystem.readFileToBufferAsync(filePath)).toString(options.encoding);
          if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
          }
          return contents;
        });
      }
      /**
       * Reads the contents of a file into a buffer.
       * Behind the scenes is uses `fs.readFileSync()`.
       * @param filePath - The relative or absolute path to the file whose contents should be read.
       */
      static readFileToBuffer(filePath) {
        return _FileSystem._wrapException(() => {
          return fsx.readFileSync(filePath);
        });
      }
      /**
       * An async version of {@link FileSystem.readFileToBuffer}.
       */
      static async readFileToBufferAsync(filePath) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return fsx.readFile(filePath);
        });
      }
      /**
       * Copies a single file from one location to another.
       * By default, destinationPath is overwritten if it already exists.
       *
       * @remarks
       * The `copyFile()` API cannot be used to copy folders.  It copies at most one file.
       * Use {@link FileSystem.copyFiles} if you need to recursively copy a tree of folders.
       *
       * The implementation is based on `copySync()` from the `fs-extra` package.
       */
      static copyFile(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (_FileSystem.getStatistics(options.sourcePath).isDirectory()) {
          throw new Error("The specified path refers to a folder; this operation expects a file object:\n" + options.sourcePath);
        }
        _FileSystem._wrapException(() => {
          fsx.copySync(options.sourcePath, options.destinationPath, {
            errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,
            overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite
          });
        });
      }
      /**
       * An async version of {@link FileSystem.copyFile}.
       */
      static async copyFileAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if ((await _FileSystem.getStatisticsAsync(options.sourcePath)).isDirectory()) {
          throw new Error("The specified path refers to a folder; this operation expects a file object:\n" + options.sourcePath);
        }
        await _FileSystem._wrapExceptionAsync(() => {
          return fsx.copy(options.sourcePath, options.destinationPath, {
            errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,
            overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite
          });
        });
      }
      /**
       * Copies a file or folder from one location to another, recursively copying any folder contents.
       * By default, destinationPath is overwritten if it already exists.
       *
       * @remarks
       * If you only intend to copy a single file, it is recommended to use {@link FileSystem.copyFile}
       * instead to more clearly communicate the intended operation.
       *
       * The implementation is based on `copySync()` from the `fs-extra` package.
       */
      static copyFiles(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        _FileSystem._wrapException(() => {
          fsx.copySync(options.sourcePath, options.destinationPath, {
            dereference: !!options.dereferenceSymlinks,
            errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,
            overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite,
            preserveTimestamps: !!options.preserveTimestamps,
            filter: options.filter
          });
        });
      }
      /**
       * An async version of {@link FileSystem.copyFiles}.
       */
      static async copyFilesAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        await _FileSystem._wrapExceptionAsync(async () => {
          await fsx.copy(options.sourcePath, options.destinationPath, {
            dereference: !!options.dereferenceSymlinks,
            errorOnExist: options.alreadyExistsBehavior === AlreadyExistsBehavior.Error,
            overwrite: options.alreadyExistsBehavior === AlreadyExistsBehavior.Overwrite,
            preserveTimestamps: !!options.preserveTimestamps,
            filter: options.filter
          });
        });
      }
      /**
       * Deletes a file. Can optionally throw if the file doesn't exist.
       * Behind the scenes it uses `fs.unlinkSync()`.
       * @param filePath - The absolute or relative path to the file that should be deleted.
       * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`
       */
      static deleteFile(filePath, options) {
        _FileSystem._wrapException(() => {
          options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
          try {
            fsx.unlinkSync(filePath);
          } catch (error) {
            if (options.throwIfNotExists || !_FileSystem.isNotExistError(error)) {
              throw error;
            }
          }
        });
      }
      /**
       * An async version of {@link FileSystem.deleteFile}.
       */
      static async deleteFileAsync(filePath, options) {
        await _FileSystem._wrapExceptionAsync(async () => {
          options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
          try {
            await fsx.unlink(filePath);
          } catch (error) {
            if (options.throwIfNotExists || !_FileSystem.isNotExistError(error)) {
              throw error;
            }
          }
        });
      }
      // ===============
      // LINK OPERATIONS
      // ===============
      /**
       * Gets the statistics of a filesystem object. Does NOT follow the link to its target.
       * Behind the scenes it uses `fs.lstatSync()`.
       * @param path - The absolute or relative path to the filesystem object.
       */
      static getLinkStatistics(path) {
        return _FileSystem._wrapException(() => {
          return fsx.lstatSync(path);
        });
      }
      /**
       * An async version of {@link FileSystem.getLinkStatistics}.
       */
      static async getLinkStatisticsAsync(path) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return fsx.lstat(path);
        });
      }
      /**
       * If `path` refers to a symbolic link, this returns the path of the link target, which may be
       * an absolute or relative path.
       *
       * @remarks
       * If `path` refers to a filesystem object that is not a symbolic link, then an `ErrnoException` is thrown
       * with code 'UNKNOWN'.  If `path` does not exist, then an `ErrnoException` is thrown with code `ENOENT`.
       *
       * @param path - The absolute or relative path to the symbolic link.
       * @returns the path of the link target
       */
      static readLink(path) {
        return _FileSystem._wrapException(() => {
          return fsx.readlinkSync(path);
        });
      }
      /**
       * An async version of {@link FileSystem.readLink}.
       */
      static async readLinkAsync(path) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return fsx.readlink(path);
        });
      }
      /**
       * Creates an NTFS "directory junction" on Windows operating systems; for other operating systems, it
       * creates a regular symbolic link.  The link target must be a folder, not a file.
       * Behind the scenes it uses `fs.symlinkSync()`.
       *
       * @remarks
       * For security reasons, Windows operating systems by default require administrator elevation to create
       * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
       * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
       * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
       * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
       * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
       * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
       *
       * A directory junction requires the link source and target to both be located on local disk volumes;
       * if not, use a symbolic link instead.
       */
      static createSymbolicLinkJunction(options) {
        _FileSystem._wrapException(() => {
          return _FileSystem._handleLink(() => {
            return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, "junction");
          }, options);
        });
      }
      /**
       * An async version of {@link FileSystem.createSymbolicLinkJunction}.
       */
      static async createSymbolicLinkJunctionAsync(options) {
        await _FileSystem._wrapExceptionAsync(() => {
          return _FileSystem._handleLinkAsync(() => {
            return fsx.symlink(options.linkTargetPath, options.newLinkPath, "junction");
          }, options);
        });
      }
      /**
       * Creates a symbolic link to a file.  On Windows operating systems, this may require administrator elevation.
       * Behind the scenes it uses `fs.symlinkSync()`.
       *
       * @remarks
       * To avoid administrator elevation on Windows, use {@link FileSystem.createHardLink} instead.
       *
       * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
       * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
       * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
       * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
       * tool incompatible with Windows.
       */
      static createSymbolicLinkFile(options) {
        _FileSystem._wrapException(() => {
          return _FileSystem._handleLink(() => {
            return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, "file");
          }, options);
        });
      }
      /**
       * An async version of {@link FileSystem.createSymbolicLinkFile}.
       */
      static async createSymbolicLinkFileAsync(options) {
        await _FileSystem._wrapExceptionAsync(() => {
          return _FileSystem._handleLinkAsync(() => {
            return fsx.symlink(options.linkTargetPath, options.newLinkPath, "file");
          }, options);
        });
      }
      /**
       * Creates a symbolic link to a folder.  On Windows operating systems, this may require administrator elevation.
       * Behind the scenes it uses `fs.symlinkSync()`.
       *
       * @remarks
       * To avoid administrator elevation on Windows, use {@link FileSystem.createSymbolicLinkJunction} instead.
       *
       * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
       * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
       * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
       * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
       * tool incompatible with Windows.
       */
      static createSymbolicLinkFolder(options) {
        _FileSystem._wrapException(() => {
          return _FileSystem._handleLink(() => {
            return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, "dir");
          }, options);
        });
      }
      /**
       * An async version of {@link FileSystem.createSymbolicLinkFolder}.
       */
      static async createSymbolicLinkFolderAsync(options) {
        await _FileSystem._wrapExceptionAsync(() => {
          return _FileSystem._handleLinkAsync(() => {
            return fsx.symlink(options.linkTargetPath, options.newLinkPath, "dir");
          }, options);
        });
      }
      /**
       * Creates a hard link.  The link target must be a file, not a folder.
       * Behind the scenes it uses `fs.linkSync()`.
       *
       * @remarks
       * For security reasons, Windows operating systems by default require administrator elevation to create
       * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
       * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
       * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
       * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
       * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
       * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
       *
       * A hard link requires the link source and target to both be located on same disk volume;
       * if not, use a symbolic link instead.
       */
      static createHardLink(options) {
        _FileSystem._wrapException(() => {
          return _FileSystem._handleLink(() => {
            return fsx.linkSync(options.linkTargetPath, options.newLinkPath);
          }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
      }
      /**
       * An async version of {@link FileSystem.createHardLink}.
       */
      static async createHardLinkAsync(options) {
        await _FileSystem._wrapExceptionAsync(() => {
          return _FileSystem._handleLinkAsync(() => {
            return fsx.link(options.linkTargetPath, options.newLinkPath);
          }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
      }
      /**
       * Follows a link to its destination and returns the absolute path to the final target of the link.
       * Behind the scenes it uses `fs.realpathSync()`.
       * @param linkPath - The path to the link.
       */
      static getRealPath(linkPath) {
        return _FileSystem._wrapException(() => {
          return fsx.realpathSync(linkPath);
        });
      }
      /**
       * An async version of {@link FileSystem.getRealPath}.
       */
      static async getRealPathAsync(linkPath) {
        return await _FileSystem._wrapExceptionAsync(() => {
          return fsx.realpath(linkPath);
        });
      }
      // ===============
      // UTILITY FUNCTIONS
      // ===============
      /**
       * Returns true if the error object indicates the file or folder already exists (`EEXIST`).
       */
      static isExistError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "EEXIST";
      }
      /**
       * Returns true if the error object indicates the file or folder does not exist (`ENOENT` or `ENOTDIR`)
       */
      static isNotExistError(error) {
        return _FileSystem.isFileDoesNotExistError(error) || _FileSystem.isFolderDoesNotExistError(error);
      }
      /**
       * Returns true if the error object indicates the file does not exist (`ENOENT`).
       */
      static isFileDoesNotExistError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "ENOENT";
      }
      /**
       * Returns true if the error object indicates the folder does not exist (`ENOTDIR`).
       */
      static isFolderDoesNotExistError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "ENOTDIR";
      }
      /**
       * Returns true if the error object indicates the target is a directory (`EISDIR`).
       */
      static isDirectoryError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "EISDIR";
      }
      /**
       * Returns true if the error object indicates the target is not a directory (`ENOTDIR`).
       */
      static isNotDirectoryError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "ENOTDIR";
      }
      /**
       * Returns true if the error object indicates that the `unlink` system call failed
       * due to a permissions issue (`EPERM`).
       */
      static isUnlinkNotPermittedError(error) {
        return _FileSystem.isErrnoException(error) && error.code === "EPERM" && error.syscall === "unlink";
      }
      /**
       * Detects if the provided error object is a `NodeJS.ErrnoException`
       */
      static isErrnoException(error) {
        const typedError = error;
        return typeof typedError.code === "string" && typeof typedError.errno === "number" && typeof typedError.path === "string" && typeof typedError.syscall === "string";
      }
      static _handleLink(linkFn, options) {
        try {
          linkFn();
        } catch (error) {
          if (_FileSystem.isExistError(error)) {
            switch (options.alreadyExistsBehavior) {
              case AlreadyExistsBehavior.Ignore:
                break;
              case AlreadyExistsBehavior.Overwrite:
                this.deleteFile(options.newLinkPath);
                linkFn();
                break;
              case AlreadyExistsBehavior.Error:
              default:
                throw error;
            }
          } else {
            if (_FileSystem.isNotExistError(error) && (!options.linkTargetMustExist || _FileSystem.exists(options.linkTargetPath))) {
              this.ensureFolder(nodeJsPath.dirname(options.newLinkPath));
              linkFn();
            } else {
              throw error;
            }
          }
        }
      }
      static async _handleLinkAsync(linkFn, options) {
        try {
          await linkFn();
        } catch (error) {
          if (_FileSystem.isExistError(error)) {
            switch (options.alreadyExistsBehavior) {
              case AlreadyExistsBehavior.Ignore:
                break;
              case AlreadyExistsBehavior.Overwrite:
                await this.deleteFileAsync(options.newLinkPath);
                await linkFn();
                break;
              case AlreadyExistsBehavior.Error:
              default:
                throw error;
            }
          } else {
            if (_FileSystem.isNotExistError(error) && (!options.linkTargetMustExist || await _FileSystem.existsAsync(options.linkTargetPath))) {
              await this.ensureFolderAsync(nodeJsPath.dirname(options.newLinkPath));
              await linkFn();
            } else {
              throw error;
            }
          }
        }
      }
      static _wrapException(fn) {
        try {
          return fn();
        } catch (error) {
          _FileSystem._updateErrorMessage(error);
          throw error;
        }
      }
      static async _wrapExceptionAsync(fn) {
        try {
          return await fn();
        } catch (error) {
          _FileSystem._updateErrorMessage(error);
          throw error;
        }
      }
      static _updateErrorMessage(error) {
        if (_FileSystem.isErrnoException(error)) {
          if (_FileSystem.isFileDoesNotExistError(error)) {
            error.message = `File does not exist: ${error.path}
${error.message}`;
          } else if (_FileSystem.isFolderDoesNotExistError(error)) {
            error.message = `Folder does not exist: ${error.path}
${error.message}`;
          } else if (_FileSystem.isExistError(error)) {
            const extendedError = error;
            error.message = `File or folder already exists: ${extendedError.dest}
${error.message}`;
          } else if (_FileSystem.isUnlinkNotPermittedError(error)) {
            error.message = `File or folder could not be deleted: ${error.path}
${error.message}`;
          } else if (_FileSystem.isDirectoryError(error)) {
            error.message = `Target is a folder, not a file: ${error.path}
${error.message}`;
          } else if (_FileSystem.isNotDirectoryError(error)) {
            error.message = `Target is not a folder: ${error.path}
${error.message}`;
          }
        }
      }
    };
    exports2.FileSystem = FileSystem;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Executable.js
var require_Executable = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Executable.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __asyncValues = exports2 && exports2.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Executable = exports2.parseProcessListOutput = exports2.parseProcessListOutputAsync = void 0;
    var os = __importStar(require("os"));
    var child_process = __importStar(require("child_process"));
    var path = __importStar(require("path"));
    var EnvironmentMap_1 = require_EnvironmentMap();
    var FileSystem_1 = require_FileSystem();
    var PosixModeBits_1 = require_PosixModeBits();
    var Text_1 = require_Text();
    var InternalError_1 = require_InternalError();
    var OS_PLATFORM = os.platform();
    async function parseProcessListOutputAsync(stream, platform = OS_PLATFORM) {
      var _a, e_1, _b, _c;
      const processInfoById = /* @__PURE__ */ new Map();
      let seenHeaders = false;
      try {
        for (var _d = true, _e = __asyncValues(Text_1.Text.readLinesFromIterableAsync(stream, { ignoreEmptyLines: true })), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
          _c = _f.value;
          _d = false;
          const line = _c;
          if (!seenHeaders) {
            seenHeaders = true;
          } else {
            parseProcessInfoEntry(line, processInfoById, platform);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d && !_a && (_b = _e.return))
            await _b.call(_e);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return processInfoById;
    }
    exports2.parseProcessListOutputAsync = parseProcessListOutputAsync;
    function parseProcessListOutput(output, platform = OS_PLATFORM) {
      const processInfoById = /* @__PURE__ */ new Map();
      let seenHeaders = false;
      for (const line of Text_1.Text.readLinesFromIterable(output, { ignoreEmptyLines: true })) {
        if (!seenHeaders) {
          seenHeaders = true;
        } else {
          parseProcessInfoEntry(line, processInfoById, platform);
        }
      }
      return processInfoById;
    }
    exports2.parseProcessListOutput = parseProcessListOutput;
    var NAME_GROUP = "name";
    var PROCESS_ID_GROUP = "pid";
    var PARENT_PROCESS_ID_GROUP = "ppid";
    var PROCESS_LIST_ENTRY_REGEX_WIN32 = new RegExp(`^(?<${NAME_GROUP}>.+?)\\s+(?<${PARENT_PROCESS_ID_GROUP}>\\d+)\\s+(?<${PROCESS_ID_GROUP}>\\d+)\\s*$`);
    var PROCESS_LIST_ENTRY_REGEX_UNIX = new RegExp(`^\\s*(?<${PARENT_PROCESS_ID_GROUP}>\\d+)\\s+(?<${PROCESS_ID_GROUP}>\\d+)\\s+(?<${NAME_GROUP}>.+?)\\s*$`);
    function parseProcessInfoEntry(line, existingProcessInfoById, platform) {
      const processListEntryRegex = platform === "win32" ? PROCESS_LIST_ENTRY_REGEX_WIN32 : PROCESS_LIST_ENTRY_REGEX_UNIX;
      const match = line.match(processListEntryRegex);
      if (!(match === null || match === void 0 ? void 0 : match.groups)) {
        throw new InternalError_1.InternalError(`Invalid process list entry: ${line}`);
      }
      const processName = match.groups[NAME_GROUP];
      const processId = parseInt(match.groups[PROCESS_ID_GROUP], 10);
      const parentProcessId = parseInt(match.groups[PARENT_PROCESS_ID_GROUP], 10);
      let parentProcessInfo;
      if (parentProcessId !== processId) {
        parentProcessInfo = existingProcessInfoById.get(parentProcessId);
        if (!parentProcessInfo) {
          parentProcessInfo = {
            processName: "",
            processId: parentProcessId,
            parentProcessInfo: void 0,
            childProcessInfos: []
          };
          existingProcessInfoById.set(parentProcessId, parentProcessInfo);
        }
      }
      let processInfo = existingProcessInfoById.get(processId);
      if (!processInfo) {
        processInfo = {
          processName,
          processId,
          parentProcessInfo,
          childProcessInfos: []
        };
        existingProcessInfoById.set(processId, processInfo);
      } else {
        processInfo.processName = processName;
        processInfo.parentProcessInfo = parentProcessInfo;
      }
      parentProcessInfo === null || parentProcessInfo === void 0 ? void 0 : parentProcessInfo.childProcessInfos.push(processInfo);
    }
    function convertToProcessInfoByNameMap(processInfoById) {
      const processInfoByNameMap = /* @__PURE__ */ new Map();
      for (const processInfo of processInfoById.values()) {
        let processInfoNameEntries = processInfoByNameMap.get(processInfo.processName);
        if (!processInfoNameEntries) {
          processInfoNameEntries = [];
          processInfoByNameMap.set(processInfo.processName, processInfoNameEntries);
        }
        processInfoNameEntries.push(processInfo);
      }
      return processInfoByNameMap;
    }
    function getProcessListProcessOptions() {
      let command;
      let args2;
      if (OS_PLATFORM === "win32") {
        command = "wmic.exe";
        args2 = ["process", "get", "Name,ParentProcessId,ProcessId"];
      } else {
        command = "ps";
        args2 = ["-Awo", "ppid,pid,comm"];
      }
      return { path: command, args: args2 };
    }
    var Executable = class _Executable {
      /**
       * Synchronously create a child process and optionally capture its output.
       *
       * @remarks
       * This function is similar to child_process.spawnSync().  The main differences are:
       *
       * - It does not invoke the OS shell unless the executable file is a shell script.
       * - Command-line arguments containing special characters are more accurately passed
       *   through to the child process.
       * - If the filename is missing a path, then the shell's default PATH will be searched.
       * - If the filename is missing a file extension, then Windows default file extensions
       *   will be searched.
       *
       * @param filename - The name of the executable file.  This string must not contain any
       * command-line arguments.  If the name contains any path delimiters, then the shell's
       * default PATH will not be searched.
       * @param args - The command-line arguments to be passed to the process.
       * @param options - Additional options
       * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
       *
       * @privateRemarks
       *
       * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>
       * polymorphically based on the options.encoding parameter value.  This is a fairly confusing
       * design.  In most cases, developers want string with the default encoding.  If/when someone
       * wants binary output or a non-default text encoding, we will introduce a separate API function
       * with a name like "spawnWithBufferSync".
       */
      static spawnSync(filename, args2, options) {
        if (!options) {
          options = {};
        }
        const context = _Executable._getExecutableContext(options);
        const resolvedPath = _Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
          throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
          cwd: context.currentWorkingDirectory,
          env: context.environmentMap.toObject(),
          input: options.input,
          stdio: options.stdio,
          timeout: options.timeoutMs,
          maxBuffer: options.maxBuffer,
          // Contrary to what the NodeJS typings imply, we must explicitly specify "utf8" here
          // if we want the result to be SpawnSyncReturns<string> instead of SpawnSyncReturns<Buffer>.
          encoding: "utf8",
          // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
          shell: false
        };
        const normalizedCommandLine = _Executable._buildCommandLineFixup(resolvedPath, args2, context);
        return child_process.spawnSync(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
      }
      /**
       * Start a child process.
       *
       * @remarks
       * This function is similar to child_process.spawn().  The main differences are:
       *
       * - It does not invoke the OS shell unless the executable file is a shell script.
       * - Command-line arguments containing special characters are more accurately passed
       *   through to the child process.
       * - If the filename is missing a path, then the shell's default PATH will be searched.
       * - If the filename is missing a file extension, then Windows default file extensions
       *   will be searched.
       *
       * This command is asynchronous, but it does not return a `Promise`.  Instead it returns
       * a Node.js `ChildProcess` supporting event notifications.
       *
       * @param filename - The name of the executable file.  This string must not contain any
       * command-line arguments.  If the name contains any path delimiters, then the shell's
       * default PATH will not be searched.
       * @param args - The command-line arguments to be passed to the process.
       * @param options - Additional options
       * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
       */
      static spawn(filename, args2, options) {
        if (!options) {
          options = {};
        }
        const context = _Executable._getExecutableContext(options);
        const resolvedPath = _Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
          throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
          cwd: context.currentWorkingDirectory,
          env: context.environmentMap.toObject(),
          stdio: options.stdio,
          // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
          shell: false
        };
        const normalizedCommandLine = _Executable._buildCommandLineFixup(resolvedPath, args2, context);
        return child_process.spawn(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
      }
      static async waitForExitAsync(childProcess, options = {}) {
        const { throwOnNonZeroExitCode = false, encoding } = options;
        if (encoding && (!childProcess.stdout || !childProcess.stderr)) {
          throw new Error("An encoding was specified, but stdout and/or stderr on the child process are not defined");
        }
        const collectedStdout = [];
        const collectedStderr = [];
        const useBufferEncoding = encoding === "buffer";
        function normalizeChunk(chunk) {
          if (typeof chunk === "string") {
            return useBufferEncoding ? Buffer.from(chunk) : chunk;
          } else {
            return useBufferEncoding ? chunk : chunk.toString(encoding);
          }
        }
        let errorThrown = false;
        const exitCode = await new Promise((resolve, reject) => {
          if (encoding) {
            childProcess.stdout.on("data", (chunk) => {
              collectedStdout.push(normalizeChunk(chunk));
            });
            childProcess.stderr.on("data", (chunk) => {
              collectedStderr.push(normalizeChunk(chunk));
            });
          }
          childProcess.on("error", (error) => {
            errorThrown = true;
            reject(error);
          });
          childProcess.on("exit", (code) => {
            if (errorThrown) {
              return;
            }
            if (code !== 0 && throwOnNonZeroExitCode) {
              reject(new Error(`Process exited with code ${code}`));
            } else {
              resolve(code);
            }
          });
        });
        const result = {
          exitCode
        };
        if (encoding === "buffer") {
          result.stdout = Buffer.concat(collectedStdout);
          result.stderr = Buffer.concat(collectedStderr);
        } else if (encoding) {
          result.stdout = collectedStdout.join("");
          result.stderr = collectedStderr.join("");
        }
        return result;
      }
      /* eslint-enable @rushstack/no-new-null */
      /**
       * Get the list of processes currently running on the system, keyed by the process ID.
       *
       * @remarks The underlying implementation depends on the operating system:
       * - On Windows, this uses the `wmic.exe` utility.
       * - On Unix, this uses the `ps` utility.
       */
      static async getProcessInfoByIdAsync() {
        const { path: command, args: args2 } = getProcessListProcessOptions();
        const process3 = _Executable.spawn(command, args2, {
          stdio: ["ignore", "pipe", "ignore"]
        });
        if (process3.stdout === null) {
          throw new InternalError_1.InternalError("Child process did not provide stdout");
        }
        const [processInfoByIdMap] = await Promise.all([
          parseProcessListOutputAsync(process3.stdout),
          // Don't collect output in the result since we process it directly
          _Executable.waitForExitAsync(process3, { throwOnNonZeroExitCode: true })
        ]);
        return processInfoByIdMap;
      }
      /**
       * {@inheritDoc Executable.getProcessInfoByIdAsync}
       */
      static getProcessInfoById() {
        const { path: command, args: args2 } = getProcessListProcessOptions();
        const processOutput = _Executable.spawnSync(command, args2);
        if (processOutput.error) {
          throw new Error(`Unable to list processes: ${command} failed with error ${processOutput.error}`);
        }
        if (processOutput.status !== 0) {
          throw new Error(`Unable to list processes: ${command} exited with code ${processOutput.status}`);
        }
        return parseProcessListOutput(processOutput.output);
      }
      /**
       * Get the list of processes currently running on the system, keyed by the process name. All processes
       * with the same name will be grouped.
       *
       * @remarks The underlying implementation depends on the operating system:
       * - On Windows, this uses the `wmic.exe` utility.
       * - On Unix, this uses the `ps` utility.
       */
      static async getProcessInfoByNameAsync() {
        const processInfoById = await _Executable.getProcessInfoByIdAsync();
        return convertToProcessInfoByNameMap(processInfoById);
      }
      /**
       * {@inheritDoc Executable.getProcessInfoByNameAsync}
       */
      static getProcessInfoByName() {
        const processInfoByIdMap = _Executable.getProcessInfoById();
        return convertToProcessInfoByNameMap(processInfoByIdMap);
      }
      // PROBLEM: Given an "args" array of strings that may contain special characters (e.g. spaces,
      // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array
      // without anything getting corrupted along the way.
      //
      // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:
      // - The Win32 CreateProcess() API expects the args to be encoded as a single text string
      // - The decoding of this string is up to the application (not the OS), and there are 3 different
      //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and
      //   the Win32 CommandLineToArgvW()
      // - The encodings are counterintuitive and have lots of special cases
      // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used
      //
      // See these articles for a full analysis:
      // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/
      // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/
      static _buildCommandLineFixup(resolvedPath, args2, context) {
        const fileExtension = path.extname(resolvedPath);
        if (OS_PLATFORM === "win32") {
          switch (fileExtension.toUpperCase()) {
            case ".EXE":
            case ".COM":
              break;
            case ".BAT":
            case ".CMD": {
              _Executable._validateArgsForWindowsShell(args2);
              let shellPath = context.environmentMap.get("COMSPEC");
              if (!shellPath || !_Executable._canExecute(shellPath, context)) {
                shellPath = _Executable.tryResolve("cmd.exe");
              }
              if (!shellPath) {
                throw new Error(`Unable to execute "${path.basename(resolvedPath)}" because CMD.exe was not found in the PATH`);
              }
              const shellArgs = [];
              shellArgs.push("/d");
              shellArgs.push("/s");
              shellArgs.push("/c");
              shellArgs.push(_Executable._getEscapedForWindowsShell(resolvedPath));
              shellArgs.push(...args2);
              return { path: shellPath, args: shellArgs };
            }
            default:
              throw new Error(`Cannot execute "${path.basename(resolvedPath)}" because the file type is not supported`);
          }
        }
        return {
          path: resolvedPath,
          args: args2
        };
      }
      /**
       * Given a filename, this determines the absolute path of the executable file that would
       * be executed by a shell:
       *
       * - If the filename is missing a path, then the shell's default PATH will be searched.
       * - If the filename is missing a file extension, then Windows default file extensions
       *   will be searched.
       *
       * @remarks
       *
       * @param filename - The name of the executable file.  This string must not contain any
       * command-line arguments.  If the name contains any path delimiters, then the shell's
       * default PATH will not be searched.
       * @param options - optional other parameters
       * @returns the absolute path of the executable, or undefined if it was not found
       */
      static tryResolve(filename, options) {
        return _Executable._tryResolve(filename, options || {}, _Executable._getExecutableContext(options));
      }
      static _tryResolve(filename, options, context) {
        const hasPathSeparators = filename.indexOf("/") >= 0 || OS_PLATFORM === "win32" && filename.indexOf("\\") >= 0;
        if (hasPathSeparators) {
          const resolvedPath = path.resolve(context.currentWorkingDirectory, filename);
          return _Executable._tryResolveFileExtension(resolvedPath, context);
        } else {
          const pathsToSearch = _Executable._getSearchFolders(context);
          for (const pathToSearch of pathsToSearch) {
            const resolvedPath = path.join(pathToSearch, filename);
            const result = _Executable._tryResolveFileExtension(resolvedPath, context);
            if (result) {
              return result;
            }
          }
          return void 0;
        }
      }
      static _tryResolveFileExtension(resolvedPath, context) {
        if (_Executable._canExecute(resolvedPath, context)) {
          return resolvedPath;
        }
        for (const shellExtension of context.windowsExecutableExtensions) {
          const resolvedNameWithExtension = resolvedPath + shellExtension;
          if (_Executable._canExecute(resolvedNameWithExtension, context)) {
            return resolvedNameWithExtension;
          }
        }
        return void 0;
      }
      static _buildEnvironmentMap(options) {
        const environmentMap = new EnvironmentMap_1.EnvironmentMap();
        if (options.environment !== void 0 && options.environmentMap !== void 0) {
          throw new Error("IExecutableResolveOptions.environment and IExecutableResolveOptions.environmentMap cannot both be specified");
        }
        if (options.environment !== void 0) {
          environmentMap.mergeFromObject(options.environment);
        } else if (options.environmentMap !== void 0) {
          environmentMap.mergeFrom(options.environmentMap);
        } else {
          environmentMap.mergeFromObject(process.env);
        }
        return environmentMap;
      }
      /**
       * This is used when searching the shell PATH for an executable, to determine
       * whether a match should be skipped or not.  If it returns true, this does not
       * guarantee that the file can be successfully executed.
       */
      static _canExecute(filePath, context) {
        if (!FileSystem_1.FileSystem.exists(filePath)) {
          return false;
        }
        if (OS_PLATFORM === "win32") {
          if (path.extname(filePath) === "") {
            return false;
          }
        } else {
          try {
            if ((FileSystem_1.FileSystem.getPosixModeBits(filePath) & PosixModeBits_1.PosixModeBits.AllExecute) === 0) {
              return false;
            }
          } catch (error) {
          }
        }
        return true;
      }
      /**
       * Returns the list of folders where we will search for an executable,
       * based on the PATH environment variable.
       */
      static _getSearchFolders(context) {
        const pathList = context.environmentMap.get("PATH") || "";
        const folders = [];
        const seenPaths = /* @__PURE__ */ new Set();
        for (const splitPath of pathList.split(path.delimiter)) {
          const trimmedPath = splitPath.trim();
          if (trimmedPath !== "") {
            if (!seenPaths.has(trimmedPath)) {
              const resolvedPath = path.resolve(context.currentWorkingDirectory, trimmedPath);
              if (!seenPaths.has(resolvedPath)) {
                if (FileSystem_1.FileSystem.exists(resolvedPath)) {
                  folders.push(resolvedPath);
                }
                seenPaths.add(resolvedPath);
              }
              seenPaths.add(trimmedPath);
            }
          }
        }
        return folders;
      }
      static _getExecutableContext(options) {
        if (!options) {
          options = {};
        }
        const environment = _Executable._buildEnvironmentMap(options);
        let currentWorkingDirectory;
        if (options.currentWorkingDirectory) {
          currentWorkingDirectory = path.resolve(options.currentWorkingDirectory);
        } else {
          currentWorkingDirectory = process.cwd();
        }
        const windowsExecutableExtensions = [];
        if (OS_PLATFORM === "win32") {
          const pathExtVariable = environment.get("PATHEXT") || "";
          for (const splitValue of pathExtVariable.split(";")) {
            const trimmed = splitValue.trim().toLowerCase();
            if (/^\.[a-z0-9\.]*[a-z0-9]$/i.test(trimmed)) {
              if (windowsExecutableExtensions.indexOf(trimmed) < 0) {
                windowsExecutableExtensions.push(trimmed);
              }
            }
          }
        }
        return {
          environmentMap: environment,
          currentWorkingDirectory,
          windowsExecutableExtensions
        };
      }
      /**
       * Given an input string containing special symbol characters, this inserts the "^" escape
       * character to ensure the symbols are interpreted literally by the Windows shell.
       */
      static _getEscapedForWindowsShell(text) {
        const escapableCharRegExp = /[%\^&|<> ]/g;
        return text.replace(escapableCharRegExp, (value) => "^" + value);
      }
      /**
       * Checks for characters that are unsafe to pass to a Windows batch file
       * due to the way that cmd.exe implements escaping.
       */
      static _validateArgsForWindowsShell(args2) {
        const specialCharRegExp = /[%\^&|<>\r\n]/g;
        for (const arg of args2) {
          const match = arg.match(specialCharRegExp);
          if (match) {
            throw new Error(`The command line argument ${JSON.stringify(arg)} contains a special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`);
          }
        }
      }
    };
    exports2.Executable = Executable;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Path.js
var require_Path = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Path.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Path = void 0;
    var path = __importStar(require("path"));
    var Path = class _Path {
      /**
       * Returns true if "childPath" is located inside the "parentFolderPath" folder
       * or one of its child folders.  Note that "parentFolderPath" is not considered to be
       * under itself.  The "childPath" can refer to any type of file system object.
       *
       * @remarks
       * The indicated file/folder objects are not required to actually exist on disk.
       * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
       * If the paths are relative, they will first be resolved using path.resolve().
       */
      static isUnder(childPath, parentFolderPath) {
        const relativePath = path.relative(childPath, parentFolderPath);
        return _Path._relativePathRegex.test(relativePath);
      }
      /**
       * Returns true if "childPath" is equal to "parentFolderPath", or if it is inside that folder
       * or one of its children.  The "childPath" can refer to any type of file system object.
       *
       * @remarks
       * The indicated file/folder objects are not required to actually exist on disk.
       * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
       * If the paths are relative, they will first be resolved using path.resolve().
       */
      static isUnderOrEqual(childPath, parentFolderPath) {
        const relativePath = path.relative(childPath, parentFolderPath);
        return relativePath === "" || _Path._relativePathRegex.test(relativePath);
      }
      /**
       * Returns true if `path1` and `path2` refer to the same underlying path.
       *
       * @remarks
       *
       * The comparison is performed using `path.relative()`.
       */
      static isEqual(path1, path2) {
        return path.relative(path1, path2) === "";
      }
      /**
       * Formats a path to look nice for reporting purposes.
       * @remarks
       * If `pathToConvert` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix
       * unless the {@link IPathFormatConciselyOptions.trimLeadingDotSlash} option is set to `true`.
       * Otherwise, it will be converted to an absolute path.
       *
       * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\`.
       */
      static formatConcisely(options) {
        const relativePath = path.relative(options.pathToConvert, options.baseFolder);
        const isUnderOrEqual = relativePath === "" || _Path._relativePathRegex.test(relativePath);
        if (isUnderOrEqual) {
          const convertedPath = _Path.convertToSlashes(path.relative(options.baseFolder, options.pathToConvert));
          if (options.trimLeadingDotSlash) {
            return convertedPath;
          } else {
            return `./${convertedPath}`;
          }
        }
        const absolutePath = path.resolve(options.pathToConvert);
        return absolutePath;
      }
      /**
       * Formats a file location to look nice for reporting purposes.
       * @remarks
       * If `pathToFormat` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix.
       * Otherwise, it will be converted to an absolute path.
       *
       * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\`.
       */
      static formatFileLocation(options) {
        const { message, format, pathToFormat, baseFolder, line, column } = options;
        const filePath = baseFolder ? _Path.formatConcisely({
          pathToConvert: pathToFormat,
          baseFolder,
          trimLeadingDotSlash: true
        }) : path.resolve(pathToFormat);
        let formattedFileLocation;
        switch (format) {
          case "Unix": {
            if (line !== void 0 && column !== void 0) {
              formattedFileLocation = `:${line}:${column}`;
            } else if (line !== void 0) {
              formattedFileLocation = `:${line}`;
            } else {
              formattedFileLocation = "";
            }
            break;
          }
          case "VisualStudio": {
            if (line !== void 0 && column !== void 0) {
              formattedFileLocation = `(${line},${column})`;
            } else if (line !== void 0) {
              formattedFileLocation = `(${line})`;
            } else {
              formattedFileLocation = "";
            }
            break;
          }
          default: {
            throw new Error(`Unknown format: ${format}`);
          }
        }
        return `${filePath}${formattedFileLocation} - ${message}`;
      }
      /**
       * Replaces Windows-style backslashes with POSIX-style slashes.
       *
       * @remarks
       * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
       */
      static convertToSlashes(inputPath) {
        return inputPath.replace(/\\/g, "/");
      }
      /**
       * Replaces POSIX-style slashes with Windows-style backslashes
       *
       * @remarks
       * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
       */
      static convertToBackslashes(inputPath) {
        return inputPath.replace(/\//g, "\\");
      }
      /**
       * Replaces slashes or backslashes with the appropriate slash for the current operating system.
       */
      static convertToPlatformDefault(inputPath) {
        return path.sep === "/" ? _Path.convertToSlashes(inputPath) : _Path.convertToBackslashes(inputPath);
      }
      /**
       * Returns true if the specified path is a relative path and does not use `..` to walk upwards.
       *
       * @example
       * ```ts
       * // These evaluate to true
       * isDownwardRelative('folder');
       * isDownwardRelative('file');
       * isDownwardRelative('folder/');
       * isDownwardRelative('./folder/');
       * isDownwardRelative('./folder/file');
       *
       * // These evaluate to false
       * isDownwardRelative('../folder');
       * isDownwardRelative('folder/../file');
       * isDownwardRelative('/folder/file');
       * ```
       */
      static isDownwardRelative(inputPath) {
        if (path.isAbsolute(inputPath)) {
          return false;
        }
        if (_Path._upwardPathSegmentRegex.test(inputPath)) {
          return false;
        }
        return true;
      }
    };
    exports2.Path = Path;
    Path._relativePathRegex = /^[.\/\\]+$/;
    Path._upwardPathSegmentRegex = /([\/\\]|^)\.\.([\/\\]|$)/;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/FileError.js
var require_FileError = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/FileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileError = void 0;
    var Path_1 = require_Path();
    var TypeUuid_1 = require_TypeUuid();
    var uuidFileError = "37a4c772-2dc8-4c66-89ae-262f8cc1f0c1";
    var baseFolderEnvVar = "RUSHSTACK_FILE_ERROR_BASE_FOLDER";
    var FileError = class _FileError extends Error {
      /**
       * Constructs a new instance of the {@link FileError} class.
       *
       * @param message - A message describing the error.
       * @param options - Options for the error.
       */
      constructor(message, options) {
        super(message);
        this.absolutePath = options.absolutePath;
        this.projectFolder = options.projectFolder;
        this.line = options.line;
        this.column = options.column;
        this.__proto__ = _FileError.prototype;
      }
      /**
       * Get the Unix-formatted the error message.
       *
       * @override
       */
      toString() {
        return this.getFormattedErrorMessage();
      }
      /**
       * Get the formatted error message.
       *
       * @param options - Options for the error message format.
       */
      getFormattedErrorMessage(options) {
        return Path_1.Path.formatFileLocation({
          format: (options === null || options === void 0 ? void 0 : options.format) || "Unix",
          baseFolder: this._evaluateBaseFolder(),
          pathToFormat: this.absolutePath,
          message: this.message,
          line: this.line,
          column: this.column
        });
      }
      _evaluateBaseFolder() {
        if (!_FileError._sanitizedEnvironmentVariable && process.env[baseFolderEnvVar]) {
          _FileError._sanitizedEnvironmentVariable = process.env[baseFolderEnvVar].replace(/^("|')|("|')$/g, "");
        }
        if (_FileError._environmentVariableIsAbsolutePath) {
          return _FileError._sanitizedEnvironmentVariable;
        }
        const baseFolderFn = _FileError._environmentVariableBasePathFnMap.get(_FileError._sanitizedEnvironmentVariable);
        if (baseFolderFn) {
          return baseFolderFn(this);
        }
        const baseFolderTokenRegex = /{([^}]+)}/g;
        const result = baseFolderTokenRegex.exec(_FileError._sanitizedEnvironmentVariable);
        if (!result) {
          _FileError._environmentVariableIsAbsolutePath = true;
          return _FileError._sanitizedEnvironmentVariable;
        } else if (result.index !== 0) {
          throw new Error(`The ${baseFolderEnvVar} environment variable contains text before the token "${result[0]}".`);
        } else if (result[0].length !== _FileError._sanitizedEnvironmentVariable.length) {
          throw new Error(`The ${baseFolderEnvVar} environment variable contains text after the token "${result[0]}".`);
        } else {
          throw new Error(`The ${baseFolderEnvVar} environment variable contains a token "${result[0]}", which is not supported.`);
        }
      }
      static [Symbol.hasInstance](instance) {
        return TypeUuid_1.TypeUuid.isInstanceOf(instance, uuidFileError);
      }
    };
    exports2.FileError = FileError;
    FileError._environmentVariableIsAbsolutePath = false;
    FileError._environmentVariableBasePathFnMap = /* @__PURE__ */ new Map([
      [void 0, (fileError) => fileError.projectFolder],
      ["{PROJECT_FOLDER}", (fileError) => fileError.projectFolder],
      ["{ABSOLUTE_PATH}", (fileError) => void 0]
    ]);
    TypeUuid_1.TypeUuid.registerClass(FileError, uuidFileError);
  }
});

// ../../node_modules/.pnpm/import-lazy@4.0.0/node_modules/import-lazy/index.js
var require_import_lazy = __commonJS({
  "../../node_modules/.pnpm/import-lazy@4.0.0/node_modules/import-lazy/index.js"(exports2, module2) {
    "use strict";
    var lazy = (importedModule, importFn, moduleId) => importedModule === void 0 ? importFn(moduleId) : importedModule;
    module2.exports = (importFn) => {
      return (moduleId) => {
        let importedModule;
        const handler = {
          get: (target, property) => {
            importedModule = lazy(importedModule, importFn, moduleId);
            return Reflect.get(importedModule, property);
          },
          apply: (target, thisArgument, argumentsList) => {
            importedModule = lazy(importedModule, importFn, moduleId);
            return Reflect.apply(importedModule, thisArgument, argumentsList);
          },
          construct: (target, argumentsList) => {
            importedModule = lazy(importedModule, importFn, moduleId);
            return Reflect.construct(importedModule, argumentsList);
          }
        };
        return new Proxy(function() {
        }, handler);
      };
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/homedir.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    module2.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/caller.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// ../../node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "../../node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module2.exports = win32.parse;
    else
      module2.exports = posix.parse;
    module2.exports.posix = posix.parse;
    module2.exports.win32 = win32.parse;
  }
});

// ../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var parse = path.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/normalize-options.js"(exports2, module2) {
    "use strict";
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args2 = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args2, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args2, arguments)
        );
      };
      var boundLength = max(0, target.length - args2.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/core.json
var require_core = __commonJS({
  "../../node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// ../../node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "../../node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/index.js"(exports2, module2) {
    "use strict";
    var hasOwn = require_hasown();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module2.exports = function isCore(x, nodeVersion) {
      return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/async.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var getHomedir = require_homedir();
    var path = require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs2.realpath && typeof fs2.realpath.native === "function" ? fs2.realpath.native : fs2.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs2.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs2.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
      readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolve(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs2.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2)
            cb(err2);
          else
            init(realStart);
        }
      );
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n, pkg) {
            if (err2)
              cb(err2);
            else if (n) {
              return maybeRealpath(realpath, n, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load(
                  [""].concat(extensions.slice()),
                  path.resolve(dir, r),
                  pkg
                );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path.dirname(dir), cb2);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path.dirname(dir), cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path.join(x2, "index"), fpkg, cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                  var dir = path.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n)
                      return cb2(null, n, pkg3);
                    loadAsFile(path.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2)
            return cb2(err2);
          if (n)
            return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/core.js"(exports2, module2) {
    "use strict";
    var isCoreModule = require_is_core_module();
    var data = require_core2();
    var core = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = isCoreModule(mod);
      }
    }
    var mod;
    module2.exports = core;
  }
});

// ../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/is-core.js"(exports2, module2) {
    "use strict";
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/sync.js"(exports2, module2) {
    "use strict";
    var isCore = require_is_core_module();
    var fs2 = require("fs");
    var path = require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs2.realpathSync && typeof fs2.realpathSync.native === "function" ? fs2.realpathSync.native : fs2.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs2.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs2.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs2.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n)
          return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir
          );
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x2
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
              if (m2)
                return m2;
              var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
              if (n2)
                return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2)
              return n2;
          }
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/index.js
var require_resolve = __commonJS({
  "../../node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/index.js"(exports2, module2) {
    "use strict";
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module2.exports = async;
  }
});

// ../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/unicode.js
var require_unicode = __commonJS({
  "../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/unicode.js"(exports2, module2) {
    "use strict";
    var Uni = module2.exports;
    module2.exports.isWhiteSpace = function isWhiteSpace(x) {
      return x === " " || x === "\xA0" || x === "\uFEFF" || x >= "	" && x <= "\r" || x === "\u1680" || x >= "\u2000" && x <= "\u200A" || x === "\u2028" || x === "\u2029" || x === "\u202F" || x === "\u205F" || x === "\u3000";
    };
    module2.exports.isWhiteSpaceJSON = function isWhiteSpaceJSON(x) {
      return x === " " || x === "	" || x === "\n" || x === "\r";
    };
    module2.exports.isLineTerminator = function isLineTerminator(x) {
      return x === "\n" || x === "\r" || x === "\u2028" || x === "\u2029";
    };
    module2.exports.isLineTerminatorJSON = function isLineTerminatorJSON(x) {
      return x === "\n" || x === "\r";
    };
    module2.exports.isIdentifierStart = function isIdentifierStart(x) {
      return x === "$" || x === "_" || x >= "A" && x <= "Z" || x >= "a" && x <= "z" || x >= "\x80" && Uni.NonAsciiIdentifierStart.test(x);
    };
    module2.exports.isIdentifierPart = function isIdentifierPart(x) {
      return x === "$" || x === "_" || x >= "A" && x <= "Z" || x >= "a" && x <= "z" || x >= "0" && x <= "9" || x >= "\x80" && Uni.NonAsciiIdentifierPart.test(x);
    };
    module2.exports.NonAsciiIdentifierStart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
    module2.exports.NonAsciiIdentifierPart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
  }
});

// ../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/parse.js"(exports2, module2) {
    "use strict";
    var Uni = require_unicode();
    function isHexDigit(x) {
      return x >= "0" && x <= "9" || x >= "A" && x <= "F" || x >= "a" && x <= "f";
    }
    function isOctDigit(x) {
      return x >= "0" && x <= "7";
    }
    function isDecDigit(x) {
      return x >= "0" && x <= "9";
    }
    var unescapeMap = {
      "'": "'",
      '"': '"',
      "\\": "\\",
      "b": "\b",
      "f": "\f",
      "n": "\n",
      "r": "\r",
      "t": "	",
      "v": "\v",
      "/": "/"
    };
    function formatError(input, msg, position, lineno, column, json5) {
      var result = msg + " at " + (lineno + 1) + ":" + (column + 1), tmppos = position - column - 1, srcline = "", underline = "";
      var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;
      if (tmppos < position - 70) {
        tmppos = position - 70;
      }
      while (1) {
        var chr = input[++tmppos];
        if (isLineTerminator(chr) || tmppos === input.length) {
          if (position >= tmppos) {
            underline += "^";
          }
          break;
        }
        srcline += chr;
        if (position === tmppos) {
          underline += "^";
        } else if (position > tmppos) {
          underline += input[tmppos] === "	" ? "	" : " ";
        }
        if (srcline.length > 78)
          break;
      }
      return result + "\n" + srcline + "\n" + underline;
    }
    function parse(input, options) {
      var json5 = false;
      var cjson = false;
      if (options.legacy || options.mode === "json") {
      } else if (options.mode === "cjson") {
        cjson = true;
      } else if (options.mode === "json5") {
        json5 = true;
      } else {
        json5 = true;
      }
      var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;
      var isWhiteSpace = json5 ? Uni.isWhiteSpace : Uni.isWhiteSpaceJSON;
      var length = input.length, lineno = 0, linestart = 0, position = 0, stack = [];
      var tokenStart = function() {
      };
      var tokenEnd = function(v) {
        return v;
      };
      if (options._tokenize) {
        ;
        (function() {
          var start = null;
          tokenStart = function() {
            if (start !== null)
              throw Error("internal error, token overlap");
            start = position;
          };
          tokenEnd = function(v, type) {
            if (start != position) {
              var hash = {
                raw: input.substr(start, position - start),
                type,
                stack: stack.slice(0)
              };
              if (v !== void 0)
                hash.value = v;
              options._tokenize.call(null, hash);
            }
            start = null;
            return v;
          };
        })();
      }
      function fail(msg) {
        var column = position - linestart;
        if (!msg) {
          if (position < length) {
            var token = "'" + JSON.stringify(input[position]).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            if (!msg)
              msg = "Unexpected token " + token;
          } else {
            if (!msg)
              msg = "Unexpected end of input";
          }
        }
        var error = SyntaxError(formatError(input, msg, position, lineno, column, json5));
        error.row = lineno + 1;
        error.column = column + 1;
        throw error;
      }
      function newline(chr) {
        if (chr === "\r" && input[position] === "\n")
          position++;
        linestart = position;
        lineno++;
      }
      function parseGeneric() {
        var result;
        while (position < length) {
          tokenStart();
          var chr = input[position++];
          if (chr === '"' || chr === "'" && json5) {
            return tokenEnd(parseString(chr), "literal");
          } else if (chr === "{") {
            tokenEnd(void 0, "separator");
            return parseObject();
          } else if (chr === "[") {
            tokenEnd(void 0, "separator");
            return parseArray();
          } else if (chr === "-" || chr === "." || isDecDigit(chr) || json5 && (chr === "+" || chr === "I" || chr === "N")) {
            return tokenEnd(parseNumber(), "literal");
          } else if (chr === "n") {
            parseKeyword("null");
            return tokenEnd(null, "literal");
          } else if (chr === "t") {
            parseKeyword("true");
            return tokenEnd(true, "literal");
          } else if (chr === "f") {
            parseKeyword("false");
            return tokenEnd(false, "literal");
          } else {
            position--;
            return tokenEnd(void 0);
          }
        }
      }
      function parseKey() {
        var result;
        while (position < length) {
          tokenStart();
          var chr = input[position++];
          if (chr === '"' || chr === "'" && json5) {
            return tokenEnd(parseString(chr), "key");
          } else if (chr === "{") {
            tokenEnd(void 0, "separator");
            return parseObject();
          } else if (chr === "[") {
            tokenEnd(void 0, "separator");
            return parseArray();
          } else if (chr === "." || isDecDigit(chr)) {
            return tokenEnd(parseNumber(true), "key");
          } else if (json5 && Uni.isIdentifierStart(chr) || chr === "\\" && input[position] === "u") {
            var rollback = position - 1;
            var result = parseIdentifier();
            if (result === void 0) {
              position = rollback;
              return tokenEnd(void 0);
            } else {
              return tokenEnd(result, "key");
            }
          } else {
            position--;
            return tokenEnd(void 0);
          }
        }
      }
      function skipWhiteSpace() {
        tokenStart();
        while (position < length) {
          var chr = input[position++];
          if (isLineTerminator(chr)) {
            position--;
            tokenEnd(void 0, "whitespace");
            tokenStart();
            position++;
            newline(chr);
            tokenEnd(void 0, "newline");
            tokenStart();
          } else if (isWhiteSpace(chr)) {
          } else if (chr === "/" && (json5 || cjson) && (input[position] === "/" || input[position] === "*")) {
            position--;
            tokenEnd(void 0, "whitespace");
            tokenStart();
            position++;
            skipComment(input[position++] === "*");
            tokenEnd(void 0, "comment");
            tokenStart();
          } else {
            position--;
            break;
          }
        }
        return tokenEnd(void 0, "whitespace");
      }
      function skipComment(multi) {
        while (position < length) {
          var chr = input[position++];
          if (isLineTerminator(chr)) {
            if (!multi) {
              position--;
              return;
            }
            newline(chr);
          } else if (chr === "*" && multi) {
            if (input[position] === "/") {
              position++;
              return;
            }
          } else {
          }
        }
        if (multi) {
          fail("Unclosed multiline comment");
        }
      }
      function parseKeyword(keyword) {
        var _pos = position;
        var len = keyword.length;
        for (var i = 1; i < len; i++) {
          if (position >= length || keyword[i] != input[position]) {
            position = _pos - 1;
            fail();
          }
          position++;
        }
      }
      function parseObject() {
        var result = options.null_prototype ? /* @__PURE__ */ Object.create(null) : {}, empty_object = {}, is_non_empty = false;
        while (position < length) {
          skipWhiteSpace();
          var item1 = parseKey();
          skipWhiteSpace();
          tokenStart();
          var chr = input[position++];
          tokenEnd(void 0, "separator");
          if (chr === "}" && item1 === void 0) {
            if (!json5 && is_non_empty) {
              position--;
              fail("Trailing comma in object");
            }
            return result;
          } else if (chr === ":" && item1 !== void 0) {
            skipWhiteSpace();
            stack.push(item1);
            var item2 = parseGeneric();
            stack.pop();
            if (item2 === void 0)
              fail("No value found for key " + item1);
            if (typeof item1 !== "string") {
              if (!json5 || typeof item1 !== "number") {
                fail("Wrong key type: " + item1);
              }
            }
            if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== "replace") {
              if (options.reserved_keys === "throw") {
                fail("Reserved key: " + item1);
              } else {
              }
            } else {
              if (typeof options.reviver === "function") {
                item2 = options.reviver.call(null, item1, item2);
              }
              if (item2 !== void 0) {
                is_non_empty = true;
                Object.defineProperty(result, item1, {
                  value: item2,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              }
            }
            skipWhiteSpace();
            tokenStart();
            var chr = input[position++];
            tokenEnd(void 0, "separator");
            if (chr === ",") {
              continue;
            } else if (chr === "}") {
              return result;
            } else {
              fail();
            }
          } else {
            position--;
            fail();
          }
        }
        fail();
      }
      function parseArray() {
        var result = [];
        while (position < length) {
          skipWhiteSpace();
          stack.push(result.length);
          var item = parseGeneric();
          stack.pop();
          skipWhiteSpace();
          tokenStart();
          var chr = input[position++];
          tokenEnd(void 0, "separator");
          if (item !== void 0) {
            if (typeof options.reviver === "function") {
              item = options.reviver.call(null, String(result.length), item);
            }
            if (item === void 0) {
              result.length++;
              item = true;
            } else {
              result.push(item);
            }
          }
          if (chr === ",") {
            if (item === void 0) {
              fail("Elisions are not supported");
            }
          } else if (chr === "]") {
            if (!json5 && item === void 0 && result.length) {
              position--;
              fail("Trailing comma in array");
            }
            return result;
          } else {
            position--;
            fail();
          }
        }
      }
      function parseNumber() {
        position--;
        var start = position, chr = input[position++], t;
        var to_num = function(is_octal2) {
          var str = input.substr(start, position - start);
          if (is_octal2) {
            var result = parseInt(str.replace(/^0o?/, ""), 8);
          } else {
            var result = Number(str);
          }
          if (Number.isNaN(result)) {
            position--;
            fail('Bad numeric literal - "' + input.substr(start, position - start + 1) + '"');
          } else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) {
            position--;
            fail('Non-json numeric literal - "' + input.substr(start, position - start + 1) + '"');
          } else {
            return result;
          }
        };
        if (chr === "-" || chr === "+" && json5)
          chr = input[position++];
        if (chr === "N" && json5) {
          parseKeyword("NaN");
          return NaN;
        }
        if (chr === "I" && json5) {
          parseKeyword("Infinity");
          return to_num();
        }
        if (chr >= "1" && chr <= "9") {
          while (position < length && isDecDigit(input[position]))
            position++;
          chr = input[position++];
        }
        if (chr === "0") {
          chr = input[position++];
          var is_octal = chr === "o" || chr === "O" || isOctDigit(chr);
          var is_hex = chr === "x" || chr === "X";
          if (json5 && (is_octal || is_hex)) {
            while (position < length && (is_hex ? isHexDigit : isOctDigit)(input[position]))
              position++;
            var sign = 1;
            if (input[start] === "-") {
              sign = -1;
              start++;
            } else if (input[start] === "+") {
              start++;
            }
            return sign * to_num(is_octal);
          }
        }
        if (chr === ".") {
          while (position < length && isDecDigit(input[position]))
            position++;
          chr = input[position++];
        }
        if (chr === "e" || chr === "E") {
          chr = input[position++];
          if (chr === "-" || chr === "+")
            position++;
          while (position < length && isDecDigit(input[position]))
            position++;
          chr = input[position++];
        }
        position--;
        return to_num();
      }
      function parseIdentifier() {
        position--;
        var result = "";
        while (position < length) {
          var chr = input[position++];
          if (chr === "\\" && input[position] === "u" && isHexDigit(input[position + 1]) && isHexDigit(input[position + 2]) && isHexDigit(input[position + 3]) && isHexDigit(input[position + 4])) {
            chr = String.fromCharCode(parseInt(input.substr(position + 1, 4), 16));
            position += 5;
          }
          if (result.length) {
            if (Uni.isIdentifierPart(chr)) {
              result += chr;
            } else {
              position--;
              return result;
            }
          } else {
            if (Uni.isIdentifierStart(chr)) {
              result += chr;
            } else {
              return void 0;
            }
          }
        }
        fail();
      }
      function parseString(endChar) {
        var result = "";
        while (position < length) {
          var chr = input[position++];
          if (chr === endChar) {
            return result;
          } else if (chr === "\\") {
            if (position >= length)
              fail();
            chr = input[position++];
            if (unescapeMap[chr] && (json5 || chr != "v" && chr != "'")) {
              result += unescapeMap[chr];
            } else if (json5 && isLineTerminator(chr)) {
              newline(chr);
            } else if (chr === "u" || chr === "x" && json5) {
              var off = chr === "u" ? 4 : 2;
              for (var i = 0; i < off; i++) {
                if (position >= length)
                  fail();
                if (!isHexDigit(input[position]))
                  fail("Bad escape sequence");
                position++;
              }
              result += String.fromCharCode(parseInt(input.substr(position - off, off), 16));
            } else if (json5 && isOctDigit(chr)) {
              if (chr < "4" && isOctDigit(input[position]) && isOctDigit(input[position + 1])) {
                var digits = 3;
              } else if (isOctDigit(input[position])) {
                var digits = 2;
              } else {
                var digits = 1;
              }
              position += digits - 1;
              result += String.fromCharCode(parseInt(input.substr(position - digits, digits), 8));
            } else if (json5) {
              result += chr;
            } else {
              position--;
              fail();
            }
          } else if (isLineTerminator(chr)) {
            fail();
          } else {
            if (!json5 && chr.charCodeAt(0) < 32) {
              position--;
              fail("Unexpected control character");
            }
            result += chr;
          }
        }
        fail();
      }
      skipWhiteSpace();
      var return_value = parseGeneric();
      if (return_value !== void 0 || position < length) {
        skipWhiteSpace();
        if (position >= length) {
          if (typeof options.reviver === "function") {
            return_value = options.reviver.call(null, "", return_value);
          }
          return return_value;
        } else {
          fail();
        }
      } else {
        if (position) {
          fail("No data, only a whitespace");
        } else {
          fail("No data, empty input");
        }
      }
    }
    module2.exports.parse = function parseJSON(input, options) {
      if (typeof options === "function") {
        options = {
          reviver: options
        };
      }
      if (input === void 0) {
        return void 0;
      }
      if (typeof input !== "string")
        input = String(input);
      if (options == null)
        options = {};
      if (options.reserved_keys == null)
        options.reserved_keys = "ignore";
      if (options.reserved_keys === "throw" || options.reserved_keys === "ignore") {
        if (options.null_prototype == null) {
          options.null_prototype = true;
        }
      }
      try {
        return parse(input, options);
      } catch (err) {
        if (err instanceof SyntaxError && err.row != null && err.column != null) {
          var old_err = err;
          err = SyntaxError(old_err.message);
          err.column = old_err.column;
          err.row = old_err.row;
        }
        throw err;
      }
    };
    module2.exports.tokenize = function tokenizeJSON(input, options) {
      if (options == null)
        options = {};
      options._tokenize = function(smth) {
        if (options._addstack)
          smth.stack.unshift.apply(smth.stack, options._addstack);
        tokens.push(smth);
      };
      var tokens = [];
      tokens.data = module2.exports.parse(input, options);
      return tokens;
    };
  }
});

// ../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/stringify.js"(exports2, module2) {
    "use strict";
    var Uni = require_unicode();
    if (!function f() {
    }.name) {
      Object.defineProperty(function() {
      }.constructor.prototype, "name", {
        get: function() {
          var name = this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
          Object.defineProperty(this, "name", { value: name });
          return name;
        }
      });
    }
    var special_chars = {
      0: "\\0",
      // this is not an octal literal
      8: "\\b",
      9: "\\t",
      10: "\\n",
      11: "\\v",
      12: "\\f",
      13: "\\r",
      92: "\\\\"
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var escapable = /[\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;
    function _stringify(object, options, recursiveLvl, currentKey) {
      var json5 = options.mode === "json5" || !options.mode;
      function indent(str2, add) {
        var prefix = options._prefix ? options._prefix : "";
        if (!options.indent)
          return prefix + str2;
        var result = "";
        var count = recursiveLvl + (add || 0);
        for (var i = 0; i < count; i++)
          result += options.indent;
        return prefix + result + str2 + (add ? "\n" : "");
      }
      function _stringify_key(key) {
        if (options.quote_keys)
          return _stringify_str(key);
        if (String(Number(key)) == key && key[0] != "-")
          return key;
        if (key == "")
          return _stringify_str(key);
        var result = "";
        for (var i = 0; i < key.length; i++) {
          if (i > 0) {
            if (!Uni.isIdentifierPart(key[i]))
              return _stringify_str(key);
          } else {
            if (!Uni.isIdentifierStart(key[i]))
              return _stringify_str(key);
          }
          var chr = key.charCodeAt(i);
          if (options.ascii) {
            if (chr < 128) {
              result += key[i];
            } else {
              result += "\\u" + ("0000" + chr.toString(16)).slice(-4);
            }
          } else {
            if (escapable.exec(key[i])) {
              result += "\\u" + ("0000" + chr.toString(16)).slice(-4);
            } else {
              result += key[i];
            }
          }
        }
        return result;
      }
      function _stringify_str(key) {
        var quote = options.quote;
        var quoteChr = quote.charCodeAt(0);
        var result = "";
        for (var i = 0; i < key.length; i++) {
          var chr = key.charCodeAt(i);
          if (chr < 16) {
            if (chr === 0 && json5) {
              result += "\\0";
            } else if (chr >= 8 && chr <= 13 && (json5 || chr !== 11)) {
              result += special_chars[chr];
            } else if (json5) {
              result += "\\x0" + chr.toString(16);
            } else {
              result += "\\u000" + chr.toString(16);
            }
          } else if (chr < 32) {
            if (json5) {
              result += "\\x" + chr.toString(16);
            } else {
              result += "\\u00" + chr.toString(16);
            }
          } else if (chr >= 32 && chr < 128) {
            if (chr === 47 && i && key[i - 1] === "<") {
              result += "\\" + key[i];
            } else if (chr === 92) {
              result += "\\\\";
            } else if (chr === quoteChr) {
              result += "\\" + quote;
            } else {
              result += key[i];
            }
          } else if (options.ascii || Uni.isLineTerminator(key[i]) || escapable.exec(key[i])) {
            if (chr < 256) {
              if (json5) {
                result += "\\x" + chr.toString(16);
              } else {
                result += "\\u00" + chr.toString(16);
              }
            } else if (chr < 4096) {
              result += "\\u0" + chr.toString(16);
            } else if (chr < 65536) {
              result += "\\u" + chr.toString(16);
            } else {
              throw Error("weird codepoint");
            }
          } else {
            result += key[i];
          }
        }
        return quote + result + quote;
      }
      function _stringify_object() {
        if (object === null)
          return "null";
        var result = [], len = 0, braces;
        if (Array.isArray(object)) {
          braces = "[]";
          for (var i = 0; i < object.length; i++) {
            var s = _stringify(object[i], options, recursiveLvl + 1, String(i));
            if (s === void 0)
              s = "null";
            len += s.length + 2;
            result.push(s + ",");
          }
        } else {
          braces = "{}";
          var fn = function(key) {
            var t = _stringify(object[key], options, recursiveLvl + 1, key);
            if (t !== void 0) {
              t = _stringify_key(key) + ":" + (options.indent ? " " : "") + t + ",";
              len += t.length + 1;
              result.push(t);
            }
          };
          if (Array.isArray(options.replacer)) {
            for (var i = 0; i < options.replacer.length; i++)
              if (hasOwnProperty.call(object, options.replacer[i]))
                fn(options.replacer[i]);
          } else {
            var keys = Object.keys(object);
            if (options.sort_keys)
              keys = keys.sort(typeof options.sort_keys === "function" ? options.sort_keys : void 0);
            keys.forEach(fn);
          }
        }
        len -= 2;
        if (options.indent && (len > options._splitMax - recursiveLvl * options.indent.length || len > options._splitMin)) {
          if (options.no_trailing_comma && result.length) {
            result[result.length - 1] = result[result.length - 1].substring(0, result[result.length - 1].length - 1);
          }
          var innerStuff = result.map(function(x) {
            return indent(x, 1);
          }).join("");
          return braces[0] + (options.indent ? "\n" : "") + innerStuff + indent(braces[1]);
        } else {
          if (result.length) {
            result[result.length - 1] = result[result.length - 1].substring(0, result[result.length - 1].length - 1);
          }
          var innerStuff = result.join(options.indent ? " " : "");
          return braces[0] + innerStuff + braces[1];
        }
      }
      function _stringify_nonobject(object2) {
        if (typeof options.replacer === "function") {
          object2 = options.replacer.call(null, currentKey, object2);
        }
        switch (typeof object2) {
          case "string":
            return _stringify_str(object2);
          case "number":
            if (object2 === 0 && 1 / object2 < 0) {
              return "-0";
            }
            if (!json5 && !Number.isFinite(object2)) {
              return "null";
            }
            return object2.toString();
          case "boolean":
            return object2.toString();
          case "undefined":
            return void 0;
          case "function":
          default:
            return JSON.stringify(object2);
        }
      }
      if (options._stringify_key) {
        return _stringify_key(object);
      }
      if (typeof object === "object") {
        if (object === null)
          return "null";
        var str;
        if (typeof (str = object.toJSON5) === "function" && options.mode !== "json") {
          object = str.call(object, currentKey);
        } else if (typeof (str = object.toJSON) === "function") {
          object = str.call(object, currentKey);
        }
        if (object === null)
          return "null";
        if (typeof object !== "object")
          return _stringify_nonobject(object);
        if (object.constructor === Number || object.constructor === Boolean || object.constructor === String) {
          object = object.valueOf();
          return _stringify_nonobject(object);
        } else if (object.constructor === Date) {
          return _stringify_nonobject(object.toISOString());
        } else {
          if (typeof options.replacer === "function") {
            object = options.replacer.call(null, currentKey, object);
            if (typeof object !== "object")
              return _stringify_nonobject(object);
          }
          return _stringify_object(object);
        }
      } else {
        return _stringify_nonobject(object);
      }
    }
    module2.exports.stringify = function stringifyJSON(object, options, _space) {
      if (typeof options === "function" || Array.isArray(options)) {
        options = {
          replacer: options
        };
      } else if (typeof options === "object" && options !== null) {
      } else {
        options = {};
      }
      if (_space != null)
        options.indent = _space;
      if (options.indent == null)
        options.indent = "	";
      if (options.quote == null)
        options.quote = "'";
      if (options.ascii == null)
        options.ascii = false;
      if (options.mode == null)
        options.mode = "json5";
      if (options.mode === "json" || options.mode === "cjson") {
        options.quote = '"';
        options.no_trailing_comma = true;
        options.quote_keys = true;
      }
      if (typeof options.indent === "object") {
        if (options.indent.constructor === Number || options.indent.constructor === Boolean || options.indent.constructor === String)
          options.indent = options.indent.valueOf();
      }
      if (typeof options.indent === "number") {
        if (options.indent >= 0) {
          options.indent = Array(Math.min(~~options.indent, 10) + 1).join(" ");
        } else {
          options.indent = false;
        }
      } else if (typeof options.indent === "string") {
        options.indent = options.indent.substr(0, 10);
      }
      if (options._splitMin == null)
        options._splitMin = 50;
      if (options._splitMax == null)
        options._splitMax = 70;
      return _stringify(object, options, 0, "");
    };
  }
});

// ../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/analyze.js
var require_analyze = __commonJS({
  "../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/analyze.js"(exports2, module2) {
    "use strict";
    var tokenize = require_parse().tokenize;
    module2.exports.analyze = function analyzeJSON(input, options) {
      if (options == null)
        options = {};
      if (!Array.isArray(input)) {
        input = tokenize(input, options);
      }
      var result = {
        has_whitespace: false,
        has_comments: false,
        has_newlines: false,
        has_trailing_comma: false,
        indent: "",
        newline: "\n",
        quote: '"',
        quote_keys: true
      };
      var stats = {
        indent: {},
        newline: {},
        quote: {}
      };
      for (var i = 0; i < input.length; i++) {
        if (input[i].type === "newline") {
          if (input[i + 1] && input[i + 1].type === "whitespace") {
            if (input[i + 1].raw[0] === "	") {
              stats.indent["	"] = (stats.indent["	"] || 0) + 1;
            }
            if (input[i + 1].raw.match(/^\x20+$/)) {
              var ws_len = input[i + 1].raw.length;
              var indent_len = input[i + 1].stack.length + 1;
              if (ws_len % indent_len === 0) {
                var t = Array(ws_len / indent_len + 1).join(" ");
                stats.indent[t] = (stats.indent[t] || 0) + 1;
              }
            }
          }
          stats.newline[input[i].raw] = (stats.newline[input[i].raw] || 0) + 1;
        }
        if (input[i].type === "newline") {
          result.has_newlines = true;
        }
        if (input[i].type === "whitespace") {
          result.has_whitespace = true;
        }
        if (input[i].type === "comment") {
          result.has_comments = true;
        }
        if (input[i].type === "key") {
          if (input[i].raw[0] !== '"' && input[i].raw[0] !== "'")
            result.quote_keys = false;
        }
        if (input[i].type === "key" || input[i].type === "literal") {
          if (input[i].raw[0] === '"' || input[i].raw[0] === "'") {
            stats.quote[input[i].raw[0]] = (stats.quote[input[i].raw[0]] || 0) + 1;
          }
        }
        if (input[i].type === "separator" && input[i].raw === ",") {
          for (var j = i + 1; j < input.length; j++) {
            if (input[j].type === "literal" || input[j].type === "key")
              break;
            if (input[j].type === "separator")
              result.has_trailing_comma = true;
          }
        }
      }
      for (var k in stats) {
        if (Object.keys(stats[k]).length) {
          result[k] = Object.keys(stats[k]).reduce(function(a, b) {
            return stats[k][a] > stats[k][b] ? a : b;
          });
        }
      }
      return result;
    };
  }
});

// ../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/document.js
var require_document = __commonJS({
  "../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/document.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var tokenize = require_parse().tokenize;
    var stringify = require_stringify().stringify;
    var analyze = require_analyze().analyze;
    function isObject(x) {
      return typeof x === "object" && x !== null;
    }
    function value_to_tokenlist(value, stack, options, is_key, indent) {
      options = Object.create(options);
      options._stringify_key = !!is_key;
      if (indent) {
        options._prefix = indent.prefix.map(function(x) {
          return x.raw;
        }).join("");
      }
      if (options._splitMin == null)
        options._splitMin = 0;
      if (options._splitMax == null)
        options._splitMax = 0;
      var stringified = stringify(value, options);
      if (is_key) {
        return [{ raw: stringified, type: "key", stack, value }];
      }
      options._addstack = stack;
      var result = tokenize(stringified, {
        _addstack: stack
      });
      result.data = null;
      return result;
    }
    function arg_to_path(path) {
      if (typeof path === "number")
        path = String(path);
      if (path === "")
        path = [];
      if (typeof path === "string")
        path = path.split(".");
      if (!Array.isArray(path))
        throw Error("Invalid path type, string or array expected");
      return path;
    }
    function find_element_in_tokenlist(element, lvl, tokens, begin, end) {
      while (tokens[begin].stack[lvl] != element) {
        if (begin++ >= end)
          return false;
      }
      while (tokens[end].stack[lvl] != element) {
        if (end-- < begin)
          return false;
      }
      return [begin, end];
    }
    function is_whitespace(token_type) {
      return token_type === "whitespace" || token_type === "newline" || token_type === "comment";
    }
    function find_first_non_ws_token(tokens, begin, end) {
      while (is_whitespace(tokens[begin].type)) {
        if (begin++ >= end)
          return false;
      }
      return begin;
    }
    function find_last_non_ws_token(tokens, begin, end) {
      while (is_whitespace(tokens[end].type)) {
        if (end-- < begin)
          return false;
      }
      return end;
    }
    function detect_indent_style(tokens, is_array, begin, end, level) {
      var result = {
        sep1: [],
        sep2: [],
        suffix: [],
        prefix: [],
        newline: []
      };
      if (tokens[end].type === "separator" && tokens[end].stack.length !== level + 1 && tokens[end].raw !== ",") {
        return result;
      }
      if (tokens[end].type === "separator")
        end = find_last_non_ws_token(tokens, begin, end - 1);
      if (end === false)
        return result;
      while (tokens[end].stack.length > level)
        end--;
      if (!is_array) {
        while (is_whitespace(tokens[end].type)) {
          if (end < begin)
            return result;
          if (tokens[end].type === "whitespace") {
            result.sep2.unshift(tokens[end]);
          } else {
            return result;
          }
          end--;
        }
        assert.equal(tokens[end].type, "separator");
        assert.equal(tokens[end].raw, ":");
        while (is_whitespace(tokens[--end].type)) {
          if (end < begin)
            return result;
          if (tokens[end].type === "whitespace") {
            result.sep1.unshift(tokens[end]);
          } else {
            return result;
          }
        }
        assert.equal(tokens[end].type, "key");
        end--;
      }
      while (is_whitespace(tokens[end].type)) {
        if (end < begin)
          return result;
        if (tokens[end].type === "whitespace") {
          result.prefix.unshift(tokens[end]);
        } else if (tokens[end].type === "newline") {
          result.newline.unshift(tokens[end]);
          return result;
        } else {
          return result;
        }
        end--;
      }
      return result;
    }
    function Document(text, options) {
      var self2 = Object.create(Document.prototype);
      if (options == null)
        options = {};
      var tokens = self2._tokens = tokenize(text, options);
      self2._data = tokens.data;
      tokens.data = null;
      self2._options = options;
      var stats = analyze(text, options);
      if (options.indent == null) {
        options.indent = stats.indent;
      }
      if (options.quote == null) {
        options.quote = stats.quote;
      }
      if (options.quote_keys == null) {
        options.quote_keys = stats.quote_keys;
      }
      if (options.no_trailing_comma == null) {
        options.no_trailing_comma = !stats.has_trailing_comma;
      }
      return self2;
    }
    function check_if_can_be_placed(key, object, is_unset) {
      function error(add) {
        return Error("You can't " + (is_unset ? "unset" : "set") + " key '" + key + "'" + add);
      }
      if (!isObject(object)) {
        throw error(" of an non-object");
      }
      if (Array.isArray(object)) {
        if (String(key).match(/^\d+$/)) {
          key = Number(String(key));
          if (object.length < key || is_unset && object.length === key) {
            throw error(", out of bounds");
          } else if (is_unset && object.length !== key + 1) {
            throw error(" in the middle of an array");
          } else {
            return true;
          }
        } else {
          throw error(" of an array");
        }
      } else {
        return true;
      }
    }
    Document.prototype.set = function(path, value) {
      path = arg_to_path(path);
      if (path.length === 0) {
        if (value === void 0)
          throw Error("can't remove root document");
        this._data = value;
        var new_key = false;
      } else {
        var data = this._data;
        for (var i = 0; i < path.length - 1; i++) {
          check_if_can_be_placed(path[i], data, false);
          data = data[path[i]];
        }
        if (i === path.length - 1) {
          check_if_can_be_placed(path[i], data, value === void 0);
        }
        var new_key = !(path[i] in data);
        if (value === void 0) {
          if (Array.isArray(data)) {
            data.pop();
          } else {
            delete data[path[i]];
          }
        } else {
          data[path[i]] = value;
        }
      }
      if (!this._tokens.length)
        this._tokens = [{ raw: "", type: "literal", stack: [], value: void 0 }];
      var position = [
        find_first_non_ws_token(this._tokens, 0, this._tokens.length - 1),
        find_last_non_ws_token(this._tokens, 0, this._tokens.length - 1)
      ];
      for (var i = 0; i < path.length - 1; i++) {
        position = find_element_in_tokenlist(path[i], i, this._tokens, position[0], position[1]);
        if (position == false)
          throw Error("internal error, please report this");
      }
      if (path.length === 0) {
        var newtokens = value_to_tokenlist(value, path, this._options);
      } else if (!new_key) {
        var pos_old = position;
        position = find_element_in_tokenlist(path[i], i, this._tokens, position[0], position[1]);
        if (value === void 0 && position !== false) {
          var newtokens = [];
          if (!Array.isArray(data)) {
            var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1);
            assert.equal(this._tokens[pos2].type, "separator");
            assert.equal(this._tokens[pos2].raw, ":");
            position[0] = pos2;
            var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1);
            assert.equal(this._tokens[pos2].type, "key");
            assert.equal(this._tokens[pos2].value, path[path.length - 1]);
            position[0] = pos2;
          }
          var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1);
          assert.equal(this._tokens[pos2].type, "separator");
          if (this._tokens[pos2].raw === ",") {
            position[0] = pos2;
          } else {
            pos2 = find_first_non_ws_token(this._tokens, position[1] + 1, pos_old[1]);
            assert.equal(this._tokens[pos2].type, "separator");
            if (this._tokens[pos2].raw === ",") {
              position[1] = pos2;
            }
          }
        } else {
          var indent = pos2 !== false ? detect_indent_style(this._tokens, Array.isArray(data), pos_old[0], position[1] - 1, i) : {};
          var newtokens = value_to_tokenlist(value, path, this._options, false, indent);
        }
      } else {
        var path_1 = path.slice(0, i);
        var pos2 = find_last_non_ws_token(this._tokens, position[0] + 1, position[1] - 1);
        assert(pos2 !== false);
        var indent = pos2 !== false ? detect_indent_style(this._tokens, Array.isArray(data), position[0] + 1, pos2, i) : {};
        var newtokens = value_to_tokenlist(value, path, this._options, false, indent);
        var prefix = [];
        if (indent.newline && indent.newline.length)
          prefix = prefix.concat(indent.newline);
        if (indent.prefix && indent.prefix.length)
          prefix = prefix.concat(indent.prefix);
        if (!Array.isArray(data)) {
          prefix = prefix.concat(value_to_tokenlist(path[path.length - 1], path_1, this._options, true));
          if (indent.sep1 && indent.sep1.length)
            prefix = prefix.concat(indent.sep1);
          prefix.push({ raw: ":", type: "separator", stack: path_1 });
          if (indent.sep2 && indent.sep2.length)
            prefix = prefix.concat(indent.sep2);
        }
        newtokens.unshift.apply(newtokens, prefix);
        if (this._tokens[pos2].type === "separator" && this._tokens[pos2].stack.length === path.length - 1) {
          if (this._tokens[pos2].raw === ",") {
            newtokens.push({ raw: ",", type: "separator", stack: path_1 });
          }
        } else {
          newtokens.unshift({ raw: ",", type: "separator", stack: path_1 });
        }
        if (indent.suffix && indent.suffix.length)
          newtokens.push.apply(newtokens, indent.suffix);
        assert.equal(this._tokens[position[1]].type, "separator");
        position[0] = pos2 + 1;
        position[1] = pos2;
      }
      newtokens.unshift(position[1] - position[0] + 1);
      newtokens.unshift(position[0]);
      this._tokens.splice.apply(this._tokens, newtokens);
      return this;
    };
    Document.prototype.unset = function(path) {
      return this.set(path, void 0);
    };
    Document.prototype.get = function(path) {
      path = arg_to_path(path);
      var data = this._data;
      for (var i = 0; i < path.length; i++) {
        if (!isObject(data))
          return void 0;
        data = data[path[i]];
      }
      return data;
    };
    Document.prototype.has = function(path) {
      path = arg_to_path(path);
      var data = this._data;
      for (var i = 0; i < path.length; i++) {
        if (!isObject(data))
          return false;
        data = data[path[i]];
      }
      return data !== void 0;
    };
    Document.prototype.update = function(value) {
      var self2 = this;
      change([], self2._data, value);
      return self2;
      function change(path, old_data, new_data) {
        if (!isObject(new_data) || !isObject(old_data)) {
          if (new_data !== old_data)
            self2.set(path, new_data);
        } else if (Array.isArray(new_data) != Array.isArray(old_data)) {
          self2.set(path, new_data);
        } else if (Array.isArray(new_data)) {
          if (new_data.length > old_data.length) {
            for (var i = 0; i < new_data.length; i++) {
              path.push(String(i));
              change(path, old_data[i], new_data[i]);
              path.pop();
            }
          } else {
            for (var i = old_data.length - 1; i >= 0; i--) {
              path.push(String(i));
              change(path, old_data[i], new_data[i]);
              path.pop();
            }
          }
        } else {
          for (var i in new_data) {
            path.push(String(i));
            change(path, old_data[i], new_data[i]);
            path.pop();
          }
          for (var i in old_data) {
            if (i in new_data)
              continue;
            path.push(String(i));
            change(path, old_data[i], new_data[i]);
            path.pop();
          }
        }
      }
    };
    Document.prototype.toString = function() {
      return this._tokens.map(function(x) {
        return x.raw;
      }).join("");
    };
    module2.exports.Document = Document;
    module2.exports.update = function updateJSON(source, new_value, options) {
      return Document(source, options).update(new_value).toString();
    };
  }
});

// ../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/lib/utils.js"(exports2, module2) {
    "use strict";
    var FS = require("fs");
    var jju = require_jju();
    module2.exports.register = function() {
      var r = require, e = "extensions";
      r[e][".json5"] = function(m, f) {
        m.exports = jju.parse(FS.readFileSync(f, "utf8"));
      };
    };
    module2.exports.patch_JSON_parse = function() {
      var _parse = JSON.parse;
      JSON.parse = function(text, rev) {
        try {
          return _parse(text, rev);
        } catch (err) {
          require_jju().parse(text, {
            mode: "json",
            legacy: true,
            reviver: rev,
            reserved_keys: "replace",
            null_prototype: false
          });
          throw err;
        }
      };
    };
    module2.exports.middleware = function() {
      return function(req, res, next) {
        throw Error("this function is removed, use express-json5 instead");
      };
    };
  }
});

// ../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/index.js
var require_jju = __commonJS({
  "../../node_modules/.pnpm/jju@1.4.0/node_modules/jju/index.js"(exports2, module2) {
    "use strict";
    module2.exports.__defineGetter__("parse", function() {
      return require_parse().parse;
    });
    module2.exports.__defineGetter__("stringify", function() {
      return require_stringify().stringify;
    });
    module2.exports.__defineGetter__("tokenize", function() {
      return require_parse().tokenize;
    });
    module2.exports.__defineGetter__("update", function() {
      return require_document().update;
    });
    module2.exports.__defineGetter__("analyze", function() {
      return require_analyze().analyze;
    });
    module2.exports.__defineGetter__("utils", function() {
      return require_utils();
    });
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/JsonFile.js
var require_JsonFile = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/JsonFile.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JsonFile = exports2.JsonSyntax = void 0;
    var os = __importStar(require("os"));
    var jju = __importStar(require_jju());
    var Text_1 = require_Text();
    var FileSystem_1 = require_FileSystem();
    var JsonSyntax;
    (function(JsonSyntax2) {
      JsonSyntax2["Strict"] = "strict";
      JsonSyntax2["JsonWithComments"] = "jsonWithComments";
      JsonSyntax2["Json5"] = "json5";
    })(JsonSyntax || (exports2.JsonSyntax = JsonSyntax = {}));
    var DEFAULT_ENCODING = "utf8";
    var JsonFile = class _JsonFile {
      /**
       * Loads a JSON file.
       */
      static load(jsonFilename, options) {
        try {
          const contents = FileSystem_1.FileSystem.readFile(jsonFilename);
          const parseOptions = _JsonFile._buildJjuParseOptions(options);
          return jju.parse(contents, parseOptions);
        } catch (error) {
          if (FileSystem_1.FileSystem.isNotExistError(error)) {
            throw error;
          } else {
            throw new Error(`Error reading "${_JsonFile._formatPathForError(jsonFilename)}":` + os.EOL + `  ${error.message}`);
          }
        }
      }
      /**
       * An async version of {@link JsonFile.load}.
       */
      static async loadAsync(jsonFilename, options) {
        try {
          const contents = await FileSystem_1.FileSystem.readFileAsync(jsonFilename);
          const parseOptions = _JsonFile._buildJjuParseOptions(options);
          return jju.parse(contents, parseOptions);
        } catch (error) {
          if (FileSystem_1.FileSystem.isNotExistError(error)) {
            throw error;
          } else {
            throw new Error(`Error reading "${_JsonFile._formatPathForError(jsonFilename)}":` + os.EOL + `  ${error.message}`);
          }
        }
      }
      /**
       * Parses a JSON file's contents.
       */
      static parseString(jsonContents, options) {
        const parseOptions = _JsonFile._buildJjuParseOptions(options);
        return jju.parse(jsonContents, parseOptions);
      }
      /**
       * Loads a JSON file and validate its schema.
       */
      static loadAndValidate(jsonFilename, jsonSchema, options) {
        const jsonObject = _JsonFile.load(jsonFilename, options);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
      }
      /**
       * An async version of {@link JsonFile.loadAndValidate}.
       */
      static async loadAndValidateAsync(jsonFilename, jsonSchema, options) {
        const jsonObject = await _JsonFile.loadAsync(jsonFilename, options);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
      }
      /**
       * Loads a JSON file and validate its schema, reporting errors using a callback
       * @remarks
       * See JsonSchema.validateObjectWithCallback() for more info.
       */
      static loadAndValidateWithCallback(jsonFilename, jsonSchema, errorCallback, options) {
        const jsonObject = _JsonFile.load(jsonFilename, options);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
      }
      /**
       * An async version of {@link JsonFile.loadAndValidateWithCallback}.
       */
      static async loadAndValidateWithCallbackAsync(jsonFilename, jsonSchema, errorCallback, options) {
        const jsonObject = await _JsonFile.loadAsync(jsonFilename, options);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
      }
      /**
       * Serializes the specified JSON object to a string buffer.
       * @param jsonObject - the object to be serialized
       * @param options - other settings that control serialization
       * @returns a JSON string, with newlines, and indented with two spaces
       */
      static stringify(jsonObject, options) {
        return _JsonFile.updateString("", jsonObject, options);
      }
      /**
       * Serializes the specified JSON object to a string buffer.
       * @param previousJson - the previous JSON string, which will be updated
       * @param newJsonObject - the object to be serialized
       * @param options - other settings that control serialization
       * @returns a JSON string, with newlines, and indented with two spaces
       */
      static updateString(previousJson, newJsonObject, options = {}) {
        if (!options.ignoreUndefinedValues) {
          _JsonFile.validateNoUndefinedMembers(newJsonObject);
        }
        let stringified;
        if (previousJson !== "") {
          stringified = jju.update(previousJson, newJsonObject, {
            mode: JsonSyntax.Json5,
            indent: 2
          });
        } else if (options.prettyFormatting) {
          stringified = jju.stringify(newJsonObject, {
            mode: "json",
            indent: 2
          });
          if (options.headerComment !== void 0) {
            stringified = _JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
          }
        } else {
          stringified = JSON.stringify(newJsonObject, void 0, 2);
          if (options.headerComment !== void 0) {
            stringified = _JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
          }
        }
        stringified = Text_1.Text.ensureTrailingNewline(stringified);
        if (options.newlineConversion) {
          stringified = Text_1.Text.convertTo(stringified, options.newlineConversion);
        }
        return stringified;
      }
      /**
       * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.
       * @param jsonObject - the object to be saved
       * @param jsonFilename - the file path to write
       * @param options - other settings that control how the file is saved
       * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise
       */
      static save(jsonObject, jsonFilename, options = {}) {
        let oldBuffer = void 0;
        if (options.updateExistingFile || options.onlyIfChanged) {
          try {
            oldBuffer = FileSystem_1.FileSystem.readFileToBuffer(jsonFilename);
          } catch (error) {
            if (!FileSystem_1.FileSystem.isNotExistError(error)) {
              throw error;
            }
          }
        }
        let jsonToUpdate = "";
        if (options.updateExistingFile && oldBuffer) {
          jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = _JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
          if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
            return false;
          }
        }
        FileSystem_1.FileSystem.writeFile(jsonFilename, newBuffer, {
          ensureFolderExists: options.ensureFolderExists
        });
        return true;
      }
      /**
       * An async version of {@link JsonFile.save}.
       */
      static async saveAsync(jsonObject, jsonFilename, options = {}) {
        let oldBuffer = void 0;
        if (options.updateExistingFile || options.onlyIfChanged) {
          try {
            oldBuffer = await FileSystem_1.FileSystem.readFileToBufferAsync(jsonFilename);
          } catch (error) {
            if (!FileSystem_1.FileSystem.isNotExistError(error)) {
              throw error;
            }
          }
        }
        let jsonToUpdate = "";
        if (options.updateExistingFile && oldBuffer) {
          jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = _JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
          if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
            return false;
          }
        }
        await FileSystem_1.FileSystem.writeFileAsync(jsonFilename, newBuffer, {
          ensureFolderExists: options.ensureFolderExists
        });
        return true;
      }
      /**
       * Used to validate a data structure before writing.  Reports an error if there
       * are any undefined members.
       */
      static validateNoUndefinedMembers(jsonObject) {
        return _JsonFile._validateNoUndefinedMembers(jsonObject, []);
      }
      // Private implementation of validateNoUndefinedMembers()
      static _validateNoUndefinedMembers(jsonObject, keyPath) {
        if (!jsonObject) {
          return;
        }
        if (typeof jsonObject === "object") {
          for (const key of Object.keys(jsonObject)) {
            keyPath.push(key);
            const value = jsonObject[key];
            if (value === void 0) {
              const fullPath = _JsonFile._formatKeyPath(keyPath);
              throw new Error(`The value for ${fullPath} is "undefined" and cannot be serialized as JSON`);
            }
            _JsonFile._validateNoUndefinedMembers(value, keyPath);
            keyPath.pop();
          }
        }
      }
      // Given this input:    ['items', '4', 'syntax', 'parameters', 'string "with" symbols", 'type']
      // Return this string:  items[4].syntax.parameters["string \"with\" symbols"].type
      static _formatKeyPath(keyPath) {
        let result = "";
        for (const key of keyPath) {
          if (/^[0-9]+$/.test(key)) {
            result += `[${key}]`;
          } else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {
            if (result) {
              result += ".";
            }
            result += `${key}`;
          } else {
            const escapedKey = key.replace(/[\\]/g, "\\\\").replace(/["]/g, "\\");
            result += `["${escapedKey}"]`;
          }
        }
        return result;
      }
      static _formatJsonHeaderComment(headerComment) {
        if (headerComment === "") {
          return "";
        }
        const lines = headerComment.split("\n");
        const result = [];
        for (const line of lines) {
          if (!/^\s*$/.test(line) && !/^\s*\/\//.test(line)) {
            throw new Error('The headerComment lines must be blank or start with the "//" prefix.\nInvalid line' + JSON.stringify(line));
          }
          result.push(Text_1.Text.replaceAll(line, "\r", ""));
        }
        return lines.join("\n") + "\n";
      }
      static _buildJjuParseOptions(options = {}) {
        const parseOptions = {};
        switch (options.jsonSyntax) {
          case JsonSyntax.Strict:
            parseOptions.mode = "json";
            break;
          case JsonSyntax.JsonWithComments:
            parseOptions.mode = "cjson";
            break;
          case JsonSyntax.Json5:
          default:
            parseOptions.mode = "json5";
            break;
        }
        return parseOptions;
      }
    };
    exports2.JsonFile = JsonFile;
    JsonFile._formatPathForError = (path) => path;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/PackageJsonLookup.js
var require_PackageJsonLookup = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/PackageJsonLookup.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PackageJsonLookup = void 0;
    var path = __importStar(require("path"));
    var JsonFile_1 = require_JsonFile();
    var Constants_1 = require_Constants();
    var FileSystem_1 = require_FileSystem();
    var PackageJsonLookup = class _PackageJsonLookup {
      /**
       * A singleton instance of `PackageJsonLookup`, which is useful for short-lived processes
       * that can reasonably assume that the file system will not be modified after the cache
       * is populated.
       *
       * @remarks
       * For long-running processes that need to clear the cache at appropriate times,
       * it is recommended to create your own instance of `PackageJsonLookup` instead
       * of relying on this instance.
       */
      static get instance() {
        if (!_PackageJsonLookup._instance) {
          _PackageJsonLookup._instance = new _PackageJsonLookup({ loadExtraFields: true });
        }
        return _PackageJsonLookup._instance;
      }
      constructor(parameters) {
        this._loadExtraFields = false;
        if (parameters) {
          if (parameters.loadExtraFields) {
            this._loadExtraFields = parameters.loadExtraFields;
          }
        }
        this.clearCache();
      }
      /**
       * A helper for loading the caller's own package.json file.
       *
       * @remarks
       *
       * This function provides a concise and efficient way for an NPM package to report metadata about itself.
       * For example, a tool might want to report its version.
       *
       * The `loadOwnPackageJson()` probes upwards from the caller's folder, expecting to find a package.json file,
       * which is assumed to be the caller's package.  The result is cached, under the assumption that a tool's
       * own package.json (and intermediary folders) will never change during the lifetime of the process.
       *
       * @example
       * ```ts
       * // Report the version of our NPM package
       * const myPackageVersion: string = PackageJsonLookup.loadOwnPackageJson(__dirname).version;
       * console.log(`Cool Tool - Version ${myPackageVersion}`);
       * ```
       *
       * @param dirnameOfCaller - The NodeJS `__dirname` macro for the caller.
       * @returns This function always returns a valid `IPackageJson` object.  If any problems are encountered during
       * loading, an exception will be thrown instead.
       */
      static loadOwnPackageJson(dirnameOfCaller) {
        const packageJson = _PackageJsonLookup.instance.tryLoadPackageJsonFor(dirnameOfCaller);
        if (packageJson === void 0) {
          throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed to find the caller's package.json.  The __dirname was: ${dirnameOfCaller}`);
        }
        if (packageJson.version !== void 0) {
          return packageJson;
        }
        const errorPath = _PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(dirnameOfCaller) || "package.json";
        throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed because the "version" field is missing in ${errorPath}`);
      }
      /**
       * Clears the internal file cache.
       * @remarks
       * Call this method if changes have been made to the package.json files on disk.
       */
      clearCache() {
        this._packageFolderCache = /* @__PURE__ */ new Map();
        this._packageJsonCache = /* @__PURE__ */ new Map();
      }
      /**
       * Returns the absolute path of a folder containing a package.json file, by looking
       * upwards from the specified fileOrFolderPath.  If no package.json can be found,
       * undefined is returned.
       *
       * @remarks
       * The fileOrFolderPath is not required to actually exist on disk.
       * The fileOrFolderPath itself can be the return value, if it is a folder containing
       * a package.json file.
       * Both positive and negative lookup results are cached.
       *
       * @param fileOrFolderPath - a relative or absolute path to a source file or folder
       * that may be part of a package
       * @returns an absolute path to a folder containing a package.json file
       */
      tryGetPackageFolderFor(fileOrFolderPath) {
        const resolvedFileOrFolderPath = path.resolve(fileOrFolderPath);
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
          return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        return this._tryGetPackageFolderFor(resolvedFileOrFolderPath);
      }
      /**
       * If the specified file or folder is part of a package, this returns the absolute path
       * to the associated package.json file.
       *
       * @remarks
       * The package folder is determined using the same algorithm
       * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
       *
       * @param fileOrFolderPath - a relative or absolute path to a source file or folder
       * that may be part of a package
       * @returns an absolute path to * package.json file
       */
      tryGetPackageJsonFilePathFor(fileOrFolderPath) {
        const packageJsonFolder = this.tryGetPackageFolderFor(fileOrFolderPath);
        if (!packageJsonFolder) {
          return void 0;
        }
        return path.join(packageJsonFolder, Constants_1.FileConstants.PackageJson);
      }
      /**
       * If the specified file or folder is part of a package, this loads and returns the
       * associated package.json file.
       *
       * @remarks
       * The package folder is determined using the same algorithm
       * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
       *
       * @param fileOrFolderPath - a relative or absolute path to a source file or folder
       * that may be part of a package
       * @returns an IPackageJson object, or undefined if the fileOrFolderPath does not
       * belong to a package
       */
      tryLoadPackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
          return void 0;
        }
        return this.loadPackageJson(packageJsonFilePath);
      }
      /**
       * This function is similar to {@link PackageJsonLookup.tryLoadPackageJsonFor}, except that it does not report
       * an error if the `version` field is missing from the package.json file.
       */
      tryLoadNodePackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
          return void 0;
        }
        return this.loadNodePackageJson(packageJsonFilePath);
      }
      /**
       * Loads the specified package.json file, if it is not already present in the cache.
       *
       * @remarks
       * Unless {@link IPackageJsonLookupParameters.loadExtraFields} was specified,
       * the returned IPackageJson object will contain a subset of essential fields.
       * The returned object should be considered to be immutable; the caller must never
       * modify it.
       *
       * @param jsonFilename - a relative or absolute path to a package.json file
       */
      loadPackageJson(jsonFilename) {
        const packageJson = this.loadNodePackageJson(jsonFilename);
        if (!packageJson.version) {
          throw new Error(`Error reading "${jsonFilename}":
  The required field "version" was not found`);
        }
        return packageJson;
      }
      /**
       * This function is similar to {@link PackageJsonLookup.loadPackageJson}, except that it does not report an error
       * if the `version` field is missing from the package.json file.
       */
      loadNodePackageJson(jsonFilename) {
        return this._loadPackageJsonInner(jsonFilename);
      }
      _loadPackageJsonInner(jsonFilename, errorsToIgnore) {
        const loadResult = this._tryLoadNodePackageJsonInner(jsonFilename);
        if (loadResult.error && (errorsToIgnore === null || errorsToIgnore === void 0 ? void 0 : errorsToIgnore.has(loadResult.error))) {
          return void 0;
        }
        switch (loadResult.error) {
          case "FILE_NOT_FOUND": {
            throw new Error(`Input file not found: ${jsonFilename}`);
          }
          case "MISSING_NAME_FIELD": {
            throw new Error(`Error reading "${jsonFilename}":
  The required field "name" was not found`);
          }
          case "OTHER_ERROR": {
            throw loadResult.errorObject;
          }
          default: {
            return loadResult.packageJson;
          }
        }
      }
      /**
       * Try to load a package.json file as an INodePackageJson,
       * returning undefined if the found file does not contain a `name` field.
       */
      _tryLoadNodePackageJsonInner(jsonFilename) {
        let normalizedFilePath;
        try {
          normalizedFilePath = FileSystem_1.FileSystem.getRealPath(jsonFilename);
        } catch (e) {
          if (FileSystem_1.FileSystem.isNotExistError(e)) {
            return {
              error: "FILE_NOT_FOUND"
            };
          } else {
            return {
              error: "OTHER_ERROR",
              errorObject: e
            };
          }
        }
        let packageJson = this._packageJsonCache.get(normalizedFilePath);
        if (!packageJson) {
          const loadedPackageJson = JsonFile_1.JsonFile.load(normalizedFilePath);
          if (!loadedPackageJson.name) {
            return {
              error: "MISSING_NAME_FIELD"
            };
          }
          if (this._loadExtraFields) {
            packageJson = loadedPackageJson;
          } else {
            packageJson = {};
            packageJson.bin = loadedPackageJson.bin;
            packageJson.dependencies = loadedPackageJson.dependencies;
            packageJson.description = loadedPackageJson.description;
            packageJson.devDependencies = loadedPackageJson.devDependencies;
            packageJson.homepage = loadedPackageJson.homepage;
            packageJson.license = loadedPackageJson.license;
            packageJson.main = loadedPackageJson.main;
            packageJson.name = loadedPackageJson.name;
            packageJson.optionalDependencies = loadedPackageJson.optionalDependencies;
            packageJson.peerDependencies = loadedPackageJson.peerDependencies;
            packageJson.private = loadedPackageJson.private;
            packageJson.scripts = loadedPackageJson.scripts;
            packageJson.typings = loadedPackageJson.typings || loadedPackageJson.types;
            packageJson.tsdocMetadata = loadedPackageJson.tsdocMetadata;
            packageJson.version = loadedPackageJson.version;
          }
          Object.freeze(packageJson);
          this._packageJsonCache.set(normalizedFilePath, packageJson);
        }
        return {
          packageJson
        };
      }
      // Recursive part of the algorithm from tryGetPackageFolderFor()
      _tryGetPackageFolderFor(resolvedFileOrFolderPath) {
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
          return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        const packageJsonFilePath = `${resolvedFileOrFolderPath}/${Constants_1.FileConstants.PackageJson}`;
        const packageJson = this._loadPackageJsonInner(packageJsonFilePath, /* @__PURE__ */ new Set(["FILE_NOT_FOUND", "MISSING_NAME_FIELD"]));
        if (packageJson) {
          this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);
          return resolvedFileOrFolderPath;
        }
        const parentFolder = path.dirname(resolvedFileOrFolderPath);
        if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {
          this._packageFolderCache.set(resolvedFileOrFolderPath, void 0);
          return void 0;
        }
        const parentResult = this._tryGetPackageFolderFor(parentFolder);
        this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);
        return parentResult;
      }
    };
    exports2.PackageJsonLookup = PackageJsonLookup;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/PackageName.js
var require_PackageName = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/PackageName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PackageName = exports2.PackageNameParser = void 0;
    var PackageNameParser = class _PackageNameParser {
      constructor(options = {}) {
        this._options = Object.assign({}, options);
      }
      /**
       * This attempts to parse a package name that may include a scope component.
       * The packageName must not be an empty string.
       * @remarks
       * This function will not throw an exception.
       *
       * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be
       * nonempty if the string could not be parsed.
       */
      tryParse(packageName) {
        const result = {
          scope: "",
          unscopedName: "",
          error: ""
        };
        let input = packageName;
        if (input === null || input === void 0) {
          result.error = "The package name must not be null or undefined";
          return result;
        }
        if (packageName.length > 214) {
          result.error = "The package name cannot be longer than 214 characters";
          return result;
        }
        if (input[0] === "@") {
          const indexOfScopeSlash = input.indexOf("/");
          if (indexOfScopeSlash <= 0) {
            result.scope = input;
            result.error = `Error parsing "${packageName}": The scope must be followed by a slash`;
            return result;
          }
          result.scope = input.substr(0, indexOfScopeSlash);
          input = input.substr(indexOfScopeSlash + 1);
        }
        result.unscopedName = input;
        if (result.scope === "@") {
          result.error = `Error parsing "${packageName}": The scope name cannot be empty`;
          return result;
        }
        if (result.unscopedName === "") {
          result.error = "The package name must not be empty";
          return result;
        }
        if (result.unscopedName[0] === "." || result.unscopedName[0] === "_") {
          result.error = `The package name "${packageName}" starts with an invalid character`;
          return result;
        }
        const nameWithoutScopeSymbols = (result.scope ? result.scope.slice(1, -1) : "") + result.unscopedName;
        if (!this._options.allowUpperCase) {
          if (result.scope !== result.scope.toLowerCase()) {
            result.error = `The package scope "${result.scope}" must not contain upper case characters`;
            return result;
          }
        }
        const match = nameWithoutScopeSymbols.match(_PackageNameParser._invalidNameCharactersRegExp);
        if (match) {
          result.error = `The package name "${packageName}" contains an invalid character: "${match[0]}"`;
          return result;
        }
        return result;
      }
      /**
       * Same as {@link PackageName.tryParse}, except this throws an exception if the input
       * cannot be parsed.
       * @remarks
       * The packageName must not be an empty string.
       */
      parse(packageName) {
        const result = this.tryParse(packageName);
        if (result.error) {
          throw new Error(result.error);
        }
        return result;
      }
      /**
       * {@inheritDoc IParsedPackageName.scope}
       */
      getScope(packageName) {
        return this.parse(packageName).scope;
      }
      /**
       * {@inheritDoc IParsedPackageName.unscopedName}
       */
      getUnscopedName(packageName) {
        return this.parse(packageName).unscopedName;
      }
      /**
       * Returns true if the specified package name is valid, or false otherwise.
       * @remarks
       * This function will not throw an exception.
       */
      isValidName(packageName) {
        const result = this.tryParse(packageName);
        return !result.error;
      }
      /**
       * Throws an exception if the specified name is not a valid package name.
       * The packageName must not be an empty string.
       */
      validate(packageName) {
        this.parse(packageName);
      }
      /**
       * Combines an optional package scope with an unscoped root name.
       * @param scope - Must be either an empty string, or a scope name such as "\@example"
       * @param unscopedName - Must be a nonempty package name that does not contain a scope
       * @returns A full package name such as "\@example/some-library".
       */
      combineParts(scope, unscopedName) {
        if (scope !== "") {
          if (scope[0] !== "@") {
            throw new Error('The scope must start with an "@" character');
          }
        }
        if (scope.indexOf("/") >= 0) {
          throw new Error('The scope must not contain a "/" character');
        }
        if (unscopedName[0] === "@") {
          throw new Error('The unscopedName cannot start with an "@" character');
        }
        if (unscopedName.indexOf("/") >= 0) {
          throw new Error('The unscopedName must not contain a "/" character');
        }
        let result;
        if (scope === "") {
          result = unscopedName;
        } else {
          result = scope + "/" + unscopedName;
        }
        this.validate(result);
        return result;
      }
    };
    exports2.PackageNameParser = PackageNameParser;
    PackageNameParser._invalidNameCharactersRegExp = /[^A-Za-z0-9\-_\.]/;
    var PackageName = class _PackageName {
      /** {@inheritDoc PackageNameParser.tryParse} */
      static tryParse(packageName) {
        return _PackageName._parser.tryParse(packageName);
      }
      /** {@inheritDoc PackageNameParser.parse} */
      static parse(packageName) {
        return this._parser.parse(packageName);
      }
      /** {@inheritDoc PackageNameParser.getScope} */
      static getScope(packageName) {
        return this._parser.getScope(packageName);
      }
      /** {@inheritDoc PackageNameParser.getUnscopedName} */
      static getUnscopedName(packageName) {
        return this._parser.getUnscopedName(packageName);
      }
      /** {@inheritDoc PackageNameParser.isValidName} */
      static isValidName(packageName) {
        return this._parser.isValidName(packageName);
      }
      /** {@inheritDoc PackageNameParser.validate} */
      static validate(packageName) {
        return this._parser.validate(packageName);
      }
      /** {@inheritDoc PackageNameParser.combineParts} */
      static combineParts(scope, unscopedName) {
        return this._parser.combineParts(scope, unscopedName);
      }
    };
    exports2.PackageName = PackageName;
    PackageName._parser = new PackageNameParser();
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Import.js
var require_Import = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Import.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Import = void 0;
    var path = __importStar(require("path"));
    var importLazy = require_import_lazy();
    var Resolve = __importStar(require_resolve());
    var nodeModule = require("module");
    var PackageJsonLookup_1 = require_PackageJsonLookup();
    var FileSystem_1 = require_FileSystem();
    var PackageName_1 = require_PackageName();
    var Import = class _Import {
      static get _builtInModules() {
        if (!_Import.__builtInModules) {
          _Import.__builtInModules = new Set(nodeModule.builtinModules);
        }
        return _Import.__builtInModules;
      }
      /**
       * Provides a way to improve process startup times by lazy-loading imported modules.
       *
       * @remarks
       * This is a more structured wrapper for the {@link https://www.npmjs.com/package/import-lazy|import-lazy}
       * package.  It enables you to replace an import like this:
       *
       * ```ts
       * import * as example from 'example'; // <-- 100ms load time
       *
       * if (condition) {
       *   example.doSomething();
       * }
       * ```
       *
       * ...with a pattern like this:
       *
       * ```ts
       * const example: typeof import('example') = Import.lazy('example', require);
       *
       * if (condition) {
       *   example.doSomething(); // <-- 100ms load time occurs here, only if needed
       * }
       * ```
       *
       * The implementation relies on JavaScript's `Proxy` feature to intercept access to object members.  Thus
       * it will only work correctly with certain types of module exports.  If a particular export isn't well behaved,
       * you may need to find (or introduce) some other module in your dependency graph to apply the optimization to.
       *
       * Usage guidelines:
       *
       * - Always specify types using `typeof` as shown above.
       *
       * - Never apply lazy-loading in a way that would convert the module's type to `any`. Losing type safety
       *   seriously impacts the maintainability of the code base.
       *
       * - In cases where the non-runtime types are needed, import them separately using the `Types` suffix:
       *
       * ```ts
       * const example: typeof import('example') = Import.lazy('example', require);
       * import type * as exampleTypes from 'example';
       * ```
       *
       * - If the imported module confusingly has the same name as its export, then use the Module suffix:
       *
       * ```ts
       * const exampleModule: typeof import('../../logic/Example') = Import.lazy(
       *   '../../logic/Example', require);
       * import type * as exampleTypes from '../../logic/Example';
       * ```
       *
       * - If the exports cause a lot of awkwardness (e.g. too many expressions need to have `exampleModule.` inserted
       *   into them), or if some exports cannot be proxied (e.g. `Import.lazy('example', require)` returns a function
       *   signature), then do not lazy-load that module.  Instead, apply lazy-loading to some other module which is
       *   better behaved.
       *
       * - It's recommended to sort imports in a standard ordering:
       *
       * ```ts
       * // 1. external imports
       * import * as path from 'path';
       * import { Import, JsonFile, JsonObject } from '@rushstack/node-core-library';
       *
       * // 2. local imports
       * import { LocalFile } from './path/LocalFile';
       *
       * // 3. lazy-imports (which are technically variables, not imports)
       * const semver: typeof import('semver') = Import.lazy('semver', require);
       * ```
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static lazy(moduleName, require2) {
        const importLazyLocal = importLazy(require2);
        return importLazyLocal(moduleName);
      }
      /**
       * This resolves a module path using similar logic as the Node.js `require.resolve()` API,
       * but supporting extra features such as specifying the base folder.
       *
       * @remarks
       * A module path is a text string that might appear in a statement such as
       * `import { X } from "____";` or `const x = require("___");`.  The implementation is based
       * on the popular `resolve` NPM package.
       *
       * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
       * ```ts
       * // Returns "/path/to/project/node_modules/example/lib/index.js"
       * Import.resolveModule({ modulePath: 'example' });
       *
       * // Returns "/path/to/project/node_modules/example/lib/other.js"
       * Import.resolveModule({ modulePath: 'example/lib/other' });
       * ```
       * If you need to determine the containing package folder
       * (`/path/to/project/node_modules/example`), use {@link Import.resolvePackage} instead.
       *
       * @returns the absolute path of the resolved module.
       * If {@link IImportResolveOptions.includeSystemModules} is specified
       * and a system module is found, then its name is returned without any file path.
       */
      static resolveModule(options) {
        const { modulePath, baseFolderPath, includeSystemModules, allowSelfReference, getRealPath } = options;
        if (path.isAbsolute(modulePath)) {
          return modulePath;
        }
        const normalizedRootPath = (getRealPath || FileSystem_1.FileSystem.getRealPath)(baseFolderPath);
        if (modulePath.startsWith(".")) {
          return path.resolve(normalizedRootPath, modulePath);
        }
        const slashIndex = modulePath.indexOf("/");
        const moduleName = slashIndex === -1 ? modulePath : modulePath.slice(0, slashIndex);
        if (!includeSystemModules && _Import._builtInModules.has(moduleName)) {
          throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}".`);
        }
        if (allowSelfReference === true) {
          const ownPackage = _Import._getPackageName(normalizedRootPath);
          if (ownPackage && (modulePath === ownPackage.packageName || modulePath.startsWith(`${ownPackage.packageName}/`))) {
            const packagePath = modulePath.slice(ownPackage.packageName.length + 1);
            return path.resolve(ownPackage.packageRootPath, packagePath);
          }
        }
        try {
          return Resolve.sync(modulePath, {
            basedir: normalizedRootPath,
            preserveSymlinks: false,
            realpathSync: getRealPath
          });
        } catch (e) {
          throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}": ${e}`);
        }
      }
      /**
       * Async version of {@link Import.resolveModule}.
       */
      static async resolveModuleAsync(options) {
        const { modulePath, baseFolderPath, includeSystemModules, allowSelfReference, getRealPath, getRealPathAsync } = options;
        if (path.isAbsolute(modulePath)) {
          return modulePath;
        }
        const normalizedRootPath = await (getRealPathAsync || getRealPath || FileSystem_1.FileSystem.getRealPathAsync)(baseFolderPath);
        if (modulePath.startsWith(".")) {
          return path.resolve(normalizedRootPath, modulePath);
        }
        const slashIndex = modulePath.indexOf("/");
        const moduleName = slashIndex === -1 ? modulePath : modulePath.slice(0, slashIndex);
        if (!includeSystemModules && _Import._builtInModules.has(moduleName)) {
          throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}".`);
        }
        if (allowSelfReference === true) {
          const ownPackage = _Import._getPackageName(normalizedRootPath);
          if (ownPackage && (modulePath === ownPackage.packageName || modulePath.startsWith(`${ownPackage.packageName}/`))) {
            const packagePath = modulePath.slice(ownPackage.packageName.length + 1);
            return path.resolve(ownPackage.packageRootPath, packagePath);
          }
        }
        try {
          const resolvePromise = new Promise((resolve, reject) => {
            const realPathFn = getRealPathAsync || getRealPath ? (filePath, callback) => {
              if (getRealPathAsync) {
                getRealPathAsync(filePath).then((resolvedPath) => callback(null, resolvedPath)).catch((error) => callback(error));
              } else {
                try {
                  const resolvedPath = getRealPath(filePath);
                  callback(null, resolvedPath);
                } catch (error) {
                  callback(error);
                }
              }
            } : void 0;
            Resolve.default(modulePath, {
              basedir: normalizedRootPath,
              preserveSymlinks: false,
              realpath: realPathFn
            }, (error, resolvedPath) => {
              if (error) {
                reject(error);
              } else {
                resolve(resolvedPath);
              }
            });
          });
          return await resolvePromise;
        } catch (e) {
          throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}": ${e}`);
        }
      }
      /**
       * Performs module resolution to determine the folder where a package is installed.
       *
       * @remarks
       * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
       * ```ts
       * // Returns "/path/to/project/node_modules/example"
       * Import.resolvePackage({ packageName: 'example' });
       * ```
       *
       * If you need to resolve a module path, use {@link Import.resolveModule} instead:
       * ```ts
       * // Returns "/path/to/project/node_modules/example/lib/index.js"
       * Import.resolveModule({ modulePath: 'example' });
       * ```
       *
       * @returns the absolute path of the package folder.
       * If {@link IImportResolveOptions.includeSystemModules} is specified
       * and a system module is found, then its name is returned without any file path.
       */
      static resolvePackage(options) {
        const { packageName, includeSystemModules, baseFolderPath, allowSelfReference, getRealPath } = options;
        if (includeSystemModules && _Import._builtInModules.has(packageName)) {
          return packageName;
        }
        const normalizedRootPath = (getRealPath || FileSystem_1.FileSystem.getRealPath)(baseFolderPath);
        if (allowSelfReference) {
          const ownPackage = _Import._getPackageName(normalizedRootPath);
          if (ownPackage && ownPackage.packageName === packageName) {
            return ownPackage.packageRootPath;
          }
        }
        PackageName_1.PackageName.parse(packageName);
        try {
          const resolvedPath = Resolve.sync(`${packageName}/`, {
            basedir: normalizedRootPath,
            preserveSymlinks: false,
            packageFilter: (pkg, pkgFile, dir) => {
              pkg.main = "package.json";
              return pkg;
            },
            realpathSync: getRealPath
          });
          const packagePath = path.dirname(resolvedPath);
          return packagePath;
        } catch (e) {
          throw new Error(`Cannot find package "${packageName}" from "${baseFolderPath}": ${e}.`);
        }
      }
      /**
       * Async version of {@link Import.resolvePackage}.
       */
      static async resolvePackageAsync(options) {
        const { packageName, includeSystemModules, baseFolderPath, allowSelfReference, getRealPath, getRealPathAsync } = options;
        if (includeSystemModules && _Import._builtInModules.has(packageName)) {
          return packageName;
        }
        const normalizedRootPath = await (getRealPathAsync || getRealPath || FileSystem_1.FileSystem.getRealPathAsync)(baseFolderPath);
        if (allowSelfReference) {
          const ownPackage = _Import._getPackageName(normalizedRootPath);
          if (ownPackage && ownPackage.packageName === packageName) {
            return ownPackage.packageRootPath;
          }
        }
        PackageName_1.PackageName.parse(packageName);
        try {
          const resolvePromise = new Promise((resolve, reject) => {
            const realPathFn = getRealPathAsync || getRealPath ? (filePath, callback) => {
              if (getRealPathAsync) {
                getRealPathAsync(filePath).then((resolvedPath2) => callback(null, resolvedPath2)).catch((error) => callback(error));
              } else {
                try {
                  const resolvedPath2 = getRealPath(filePath);
                  callback(null, resolvedPath2);
                } catch (error) {
                  callback(error);
                }
              }
            } : void 0;
            Resolve.default(
              // Append a slash to the package name to ensure `resolve` doesn't attempt to return a system package
              `${packageName}/`,
              {
                basedir: normalizedRootPath,
                preserveSymlinks: false,
                packageFilter: (pkg, pkgFile, dir) => {
                  pkg.main = "package.json";
                  return pkg;
                },
                realpath: realPathFn
              },
              (error, resolvedPath2) => {
                if (error) {
                  reject(error);
                } else {
                  resolve(resolvedPath2);
                }
              }
            );
          });
          const resolvedPath = await resolvePromise;
          const packagePath = path.dirname(resolvedPath);
          return packagePath;
        } catch (e) {
          throw new Error(`Cannot find package "${packageName}" from "${baseFolderPath}": ${e}`);
        }
      }
      static _getPackageName(rootPath) {
        const packageJsonPath = PackageJsonLookup_1.PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(rootPath);
        if (packageJsonPath) {
          const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(packageJsonPath);
          return {
            packageRootPath: path.dirname(packageJsonPath),
            packageName: packageJson.name
          };
        } else {
          return void 0;
        }
      }
    };
    exports2.Import = Import;
  }
});

// ../../node_modules/.pnpm/z-schema@5.0.5/node_modules/z-schema/dist/ZSchema-browser-min.js
var require_ZSchema_browser_min = __commonJS({
  "../../node_modules/.pnpm/z-schema@5.0.5/node_modules/z-schema/dist/ZSchema-browser-min.js"(exports2, module2) {
    "use strict";
    !function(e) {
      if ("object" == typeof exports2 && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).ZSchema = e();
      }
    }(function() {
      return function a(o, s, l) {
        function u(t, e2) {
          if (!s[t]) {
            if (!o[t]) {
              var r = "function" == typeof require && require;
              if (!e2 && r)
                return r(t, true);
              if (d)
                return d(t, true);
              var i = new Error("Cannot find module '" + t + "'");
              throw i.code = "MODULE_NOT_FOUND", i;
            }
            var n = s[t] = { exports: {} };
            o[t][0].call(n.exports, function(e3) {
              return u(o[t][1][e3] || e3);
            }, n, n.exports, a, o, s, l);
          }
          return s[t].exports;
        }
        for (var d = "function" == typeof require && require, e = 0; e < l.length; e++)
          u(l[e]);
        return u;
      }({ 1: [function(e, W, t) {
        (function(H) {
          (function() {
            var e2 = "Expected a function", i = "__lodash_hash_undefined__", r = 1 / 0, n = "[object Function]", a = "[object GeneratorFunction]", o = "[object Symbol]", s = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, l = /^\w*$/, u = /^\./, d = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, f = /\\(\\)?/g, c = /^\[object .+?Constructor\]$/, t2 = "object" == typeof H && H && H.Object === Object && H, p = "object" == typeof self && self && self.Object === Object && self, h = t2 || p || Function("return this")();
            var m, v = Array.prototype, _ = Function.prototype, g = Object.prototype, y = h["__core-js_shared__"], E = (m = /[^.]+$/.exec(y && y.keys && y.keys.IE_PROTO || "")) ? "Symbol(src)_1." + m : "", A = _.toString, S = g.hasOwnProperty, b = g.toString, O = RegExp("^" + A.call(S).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), M = h.Symbol, I = v.splice, R = w(h, "Map"), $ = w(Object, "create"), P = M ? M.prototype : void 0, T = P ? P.toString : void 0;
            function D(e3) {
              var t3 = -1, r2 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r2; ) {
                var i2 = e3[t3];
                this.set(i2[0], i2[1]);
              }
            }
            function L(e3) {
              var t3 = -1, r2 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r2; ) {
                var i2 = e3[t3];
                this.set(i2[0], i2[1]);
              }
            }
            function C(e3) {
              var t3 = -1, r2 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r2; ) {
                var i2 = e3[t3];
                this.set(i2[0], i2[1]);
              }
            }
            function x(e3, t3) {
              for (var r2, i2, n2 = e3.length; n2--; )
                if ((r2 = e3[n2][0]) === (i2 = t3) || r2 != r2 && i2 != i2)
                  return n2;
              return -1;
            }
            function N(e3, t3) {
              for (var r2, i2 = 0, n2 = (t3 = function(e4, t4) {
                if (Y(e4))
                  return false;
                var r3 = typeof e4;
                if ("number" == r3 || "symbol" == r3 || "boolean" == r3 || null == e4 || G(e4))
                  return true;
                return l.test(e4) || !s.test(e4) || null != t4 && e4 in Object(t4);
              }(t3, e3) ? [t3] : Y(r2 = t3) ? r2 : U(r2)).length; null != e3 && i2 < n2; )
                e3 = e3[j(t3[i2++])];
              return i2 && i2 == n2 ? e3 : void 0;
            }
            function B(e3) {
              return !(!K(e3) || (t3 = e3, E && E in t3)) && ((i2 = K(r2 = e3) ? b.call(r2) : "") == n || i2 == a || function(e4) {
                var t4 = false;
                if (null != e4 && "function" != typeof e4.toString)
                  try {
                    t4 = !!(e4 + "");
                  } catch (e5) {
                  }
                return t4;
              }(e3) ? O : c).test(function(e4) {
                if (null != e4) {
                  try {
                    return A.call(e4);
                  } catch (e5) {
                  }
                  try {
                    return e4 + "";
                  } catch (e5) {
                  }
                }
                return "";
              }(e3));
              var t3, r2, i2;
            }
            function F(e3, t3) {
              var r2, i2, n2 = e3.__data__;
              return ("string" == (i2 = typeof (r2 = t3)) || "number" == i2 || "symbol" == i2 || "boolean" == i2 ? "__proto__" !== r2 : null === r2) ? n2["string" == typeof t3 ? "string" : "hash"] : n2.map;
            }
            function w(e3, t3) {
              var r2, i2, n2 = (i2 = t3, null == (r2 = e3) ? void 0 : r2[i2]);
              return B(n2) ? n2 : void 0;
            }
            D.prototype.clear = function() {
              this.__data__ = $ ? $(null) : {};
            }, D.prototype.delete = function(e3) {
              return this.has(e3) && delete this.__data__[e3];
            }, D.prototype.get = function(e3) {
              var t3 = this.__data__;
              if ($) {
                var r2 = t3[e3];
                return r2 === i ? void 0 : r2;
              }
              return S.call(t3, e3) ? t3[e3] : void 0;
            }, D.prototype.has = function(e3) {
              var t3 = this.__data__;
              return $ ? void 0 !== t3[e3] : S.call(t3, e3);
            }, D.prototype.set = function(e3, t3) {
              return this.__data__[e3] = $ && void 0 === t3 ? i : t3, this;
            }, L.prototype.clear = function() {
              this.__data__ = [];
            }, L.prototype.delete = function(e3) {
              var t3 = this.__data__, r2 = x(t3, e3);
              return !(r2 < 0 || (r2 == t3.length - 1 ? t3.pop() : I.call(t3, r2, 1), 0));
            }, L.prototype.get = function(e3) {
              var t3 = this.__data__, r2 = x(t3, e3);
              return r2 < 0 ? void 0 : t3[r2][1];
            }, L.prototype.has = function(e3) {
              return -1 < x(this.__data__, e3);
            }, L.prototype.set = function(e3, t3) {
              var r2 = this.__data__, i2 = x(r2, e3);
              return i2 < 0 ? r2.push([e3, t3]) : r2[i2][1] = t3, this;
            }, C.prototype.clear = function() {
              this.__data__ = { hash: new D(), map: new (R || L)(), string: new D() };
            }, C.prototype.delete = function(e3) {
              return F(this, e3).delete(e3);
            }, C.prototype.get = function(e3) {
              return F(this, e3).get(e3);
            }, C.prototype.has = function(e3) {
              return F(this, e3).has(e3);
            }, C.prototype.set = function(e3, t3) {
              return F(this, e3).set(e3, t3), this;
            };
            var U = Z(function(e3) {
              var t3;
              e3 = null == (t3 = e3) ? "" : function(e4) {
                if ("string" == typeof e4)
                  return e4;
                if (G(e4))
                  return T ? T.call(e4) : "";
                var t4 = e4 + "";
                return "0" == t4 && 1 / e4 == -r ? "-0" : t4;
              }(t3);
              var n2 = [];
              return u.test(e3) && n2.push(""), e3.replace(d, function(e4, t4, r2, i2) {
                n2.push(r2 ? i2.replace(f, "$1") : t4 || e4);
              }), n2;
            });
            function j(e3) {
              if ("string" == typeof e3 || G(e3))
                return e3;
              var t3 = e3 + "";
              return "0" == t3 && 1 / e3 == -r ? "-0" : t3;
            }
            function Z(n2, a2) {
              if ("function" != typeof n2 || a2 && "function" != typeof a2)
                throw new TypeError(e2);
              var o2 = function() {
                var e3 = arguments, t3 = a2 ? a2.apply(this, e3) : e3[0], r2 = o2.cache;
                if (r2.has(t3))
                  return r2.get(t3);
                var i2 = n2.apply(this, e3);
                return o2.cache = r2.set(t3, i2), i2;
              };
              return o2.cache = new (Z.Cache || C)(), o2;
            }
            Z.Cache = C;
            var Y = Array.isArray;
            function K(e3) {
              var t3 = typeof e3;
              return !!e3 && ("object" == t3 || "function" == t3);
            }
            function G(e3) {
              return "symbol" == typeof e3 || !!(t3 = e3) && "object" == typeof t3 && b.call(e3) == o;
              var t3;
            }
            W.exports = function(e3, t3, r2) {
              var i2 = null == e3 ? void 0 : N(e3, t3);
              return void 0 === i2 ? r2 : i2;
            };
          }).call(this);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 2: [function(e, Qe, et) {
        (function(Je) {
          (function() {
            var i = "__lodash_hash_undefined__", E = 1, _ = 2, r = 9007199254740991, g = "[object Arguments]", y = "[object Array]", n = "[object AsyncFunction]", A = "[object Boolean]", S = "[object Date]", b = "[object Error]", a = "[object Function]", o = "[object GeneratorFunction]", O = "[object Map]", M = "[object Number]", s = "[object Null]", I = "[object Object]", l = "[object Promise]", u = "[object Proxy]", R = "[object RegExp]", $ = "[object Set]", P = "[object String]", T = "[object Symbol]", d = "[object Undefined]", f = "[object WeakMap]", D = "[object ArrayBuffer]", L = "[object DataView]", c = /^\[object .+?Constructor\]$/, p = /^(?:0|[1-9]\d*)$/, t = {};
            t["[object Float32Array]"] = t["[object Float64Array]"] = t["[object Int8Array]"] = t["[object Int16Array]"] = t["[object Int32Array]"] = t["[object Uint8Array]"] = t["[object Uint8ClampedArray]"] = t["[object Uint16Array]"] = t["[object Uint32Array]"] = true, t[g] = t[y] = t[D] = t[A] = t[L] = t[S] = t[b] = t[a] = t[O] = t[M] = t[I] = t[R] = t[$] = t[P] = t[f] = false;
            var e2 = "object" == typeof Je && Je && Je.Object === Object && Je, h = "object" == typeof self && self && self.Object === Object && self, m = e2 || h || Function("return this")(), v = "object" == typeof et && et && !et.nodeType && et, C = v && "object" == typeof Qe && Qe && !Qe.nodeType && Qe, x = C && C.exports === v, N = x && e2.process, B = function() {
              try {
                return N && N.binding && N.binding("util");
              } catch (e3) {
              }
            }(), F = B && B.isTypedArray;
            function w(e3, t2) {
              for (var r2 = -1, i2 = null == e3 ? 0 : e3.length; ++r2 < i2; )
                if (t2(e3[r2], r2, e3))
                  return true;
              return false;
            }
            function U(e3) {
              var r2 = -1, i2 = Array(e3.size);
              return e3.forEach(function(e4, t2) {
                i2[++r2] = [t2, e4];
              }), i2;
            }
            function j(e3) {
              var t2 = -1, r2 = Array(e3.size);
              return e3.forEach(function(e4) {
                r2[++t2] = e4;
              }), r2;
            }
            var Z, Y, K, G = Array.prototype, H = Function.prototype, W = Object.prototype, k = m["__core-js_shared__"], V = H.toString, X = W.hasOwnProperty, z = (Z = /[^.]+$/.exec(k && k.keys && k.keys.IE_PROTO || "")) ? "Symbol(src)_1." + Z : "", q = W.toString, J = RegExp("^" + V.call(X).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Q = x ? m.Buffer : void 0, ee = m.Symbol, te = m.Uint8Array, re = W.propertyIsEnumerable, ie = G.splice, ne = ee ? ee.toStringTag : void 0, ae = Object.getOwnPropertySymbols, oe = Q ? Q.isBuffer : void 0, se = (Y = Object.keys, K = Object, function(e3) {
              return Y(K(e3));
            }), le = Be(m, "DataView"), ue = Be(m, "Map"), de = Be(m, "Promise"), fe = Be(m, "Set"), ce = Be(m, "WeakMap"), pe = Be(Object, "create"), he = je(le), me = je(ue), ve = je(de), _e = je(fe), ge = je(ce), ye = ee ? ee.prototype : void 0, Ee = ye ? ye.valueOf : void 0;
            function Ae(e3) {
              var t2 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.clear(); ++t2 < r2; ) {
                var i2 = e3[t2];
                this.set(i2[0], i2[1]);
              }
            }
            function Se(e3) {
              var t2 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.clear(); ++t2 < r2; ) {
                var i2 = e3[t2];
                this.set(i2[0], i2[1]);
              }
            }
            function be(e3) {
              var t2 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.clear(); ++t2 < r2; ) {
                var i2 = e3[t2];
                this.set(i2[0], i2[1]);
              }
            }
            function Oe(e3) {
              var t2 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.__data__ = new be(); ++t2 < r2; )
                this.add(e3[t2]);
            }
            function Me(e3) {
              var t2 = this.__data__ = new Se(e3);
              this.size = t2.size;
            }
            function Ie(e3, t2) {
              var r2 = Ke(e3), i2 = !r2 && Ye(e3), n2 = !r2 && !i2 && Ge(e3), a2 = !r2 && !i2 && !n2 && ze(e3), o2 = r2 || i2 || n2 || a2, s2 = o2 ? function(e4, t3) {
                for (var r3 = -1, i3 = Array(e4); ++r3 < e4; )
                  i3[r3] = t3(r3);
                return i3;
              }(e3.length, String) : [], l2 = s2.length;
              for (var u2 in e3)
                !t2 && !X.call(e3, u2) || o2 && ("length" == u2 || n2 && ("offset" == u2 || "parent" == u2) || a2 && ("buffer" == u2 || "byteLength" == u2 || "byteOffset" == u2) || Ue(u2, l2)) || s2.push(u2);
              return s2;
            }
            function Re(e3, t2) {
              for (var r2 = e3.length; r2--; )
                if (Ze(e3[r2][0], t2))
                  return r2;
              return -1;
            }
            function $e(e3) {
              return null == e3 ? void 0 === e3 ? d : s : ne && ne in Object(e3) ? function(e4) {
                var t3 = X.call(e4, ne), r2 = e4[ne];
                try {
                  var i2 = !(e4[ne] = void 0);
                } catch (e5) {
                }
                var n2 = q.call(e4);
                i2 && (t3 ? e4[ne] = r2 : delete e4[ne]);
                return n2;
              }(e3) : (t2 = e3, q.call(t2));
              var t2;
            }
            function Pe(e3) {
              return Ve(e3) && $e(e3) == g;
            }
            function Te(e3, t2, r2, i2, n2) {
              return e3 === t2 || (null == e3 || null == t2 || !Ve(e3) && !Ve(t2) ? e3 != e3 && t2 != t2 : function(e4, t3, r3, i3, n3, a2) {
                var o2 = Ke(e4), s2 = Ke(t3), l2 = o2 ? y : we(e4), u2 = s2 ? y : we(t3), d2 = (l2 = l2 == g ? I : l2) == I, f2 = (u2 = u2 == g ? I : u2) == I, c2 = l2 == u2;
                if (c2 && Ge(e4)) {
                  if (!Ge(t3))
                    return false;
                  d2 = !(o2 = true);
                }
                if (c2 && !d2)
                  return a2 || (a2 = new Me()), o2 || ze(e4) ? Ce(e4, t3, r3, i3, n3, a2) : function(e5, t4, r4, i4, n4, a3, o3) {
                    switch (r4) {
                      case L:
                        if (e5.byteLength != t4.byteLength || e5.byteOffset != t4.byteOffset)
                          return false;
                        e5 = e5.buffer, t4 = t4.buffer;
                      case D:
                        return !(e5.byteLength != t4.byteLength || !a3(new te(e5), new te(t4)));
                      case A:
                      case S:
                      case M:
                        return Ze(+e5, +t4);
                      case b:
                        return e5.name == t4.name && e5.message == t4.message;
                      case R:
                      case P:
                        return e5 == t4 + "";
                      case O:
                        var s3 = U;
                      case $:
                        var l3 = i4 & E;
                        if (s3 || (s3 = j), e5.size != t4.size && !l3)
                          return false;
                        var u3 = o3.get(e5);
                        if (u3)
                          return u3 == t4;
                        i4 |= _, o3.set(e5, t4);
                        var d3 = Ce(s3(e5), s3(t4), i4, n4, a3, o3);
                        return o3.delete(e5), d3;
                      case T:
                        if (Ee)
                          return Ee.call(e5) == Ee.call(t4);
                    }
                    return false;
                  }(e4, t3, l2, r3, i3, n3, a2);
                if (!(r3 & E)) {
                  var p2 = d2 && X.call(e4, "__wrapped__"), h2 = f2 && X.call(t3, "__wrapped__");
                  if (p2 || h2) {
                    var m2 = p2 ? e4.value() : e4, v2 = h2 ? t3.value() : t3;
                    return a2 || (a2 = new Me()), n3(m2, v2, r3, i3, a2);
                  }
                }
                return !!c2 && (a2 || (a2 = new Me()), function(e5, t4, r4, i4, n4, a3) {
                  var o3 = r4 & E, s3 = xe(e5), l3 = s3.length, u3 = xe(t4).length;
                  if (l3 != u3 && !o3)
                    return false;
                  for (var d3 = l3; d3--; ) {
                    var f3 = s3[d3];
                    if (!(o3 ? f3 in t4 : X.call(t4, f3)))
                      return false;
                  }
                  var c3 = a3.get(e5);
                  if (c3 && a3.get(t4))
                    return c3 == t4;
                  var p3 = true;
                  a3.set(e5, t4), a3.set(t4, e5);
                  for (var h3 = o3; ++d3 < l3; ) {
                    f3 = s3[d3];
                    var m3 = e5[f3], v3 = t4[f3];
                    if (i4)
                      var _2 = o3 ? i4(v3, m3, f3, t4, e5, a3) : i4(m3, v3, f3, e5, t4, a3);
                    if (!(void 0 === _2 ? m3 === v3 || n4(m3, v3, r4, i4, a3) : _2)) {
                      p3 = false;
                      break;
                    }
                    h3 || (h3 = "constructor" == f3);
                  }
                  if (p3 && !h3) {
                    var g2 = e5.constructor, y2 = t4.constructor;
                    g2 != y2 && "constructor" in e5 && "constructor" in t4 && !("function" == typeof g2 && g2 instanceof g2 && "function" == typeof y2 && y2 instanceof y2) && (p3 = false);
                  }
                  return a3.delete(e5), a3.delete(t4), p3;
                }(e4, t3, r3, i3, n3, a2));
              }(e3, t2, r2, i2, Te, n2));
            }
            function De(e3) {
              return !(!ke(e3) || (t2 = e3, z && z in t2)) && (He(e3) ? J : c).test(je(e3));
              var t2;
            }
            function Le(e3) {
              if (r2 = (t2 = e3) && t2.constructor, i2 = "function" == typeof r2 && r2.prototype || W, t2 !== i2)
                return se(e3);
              var t2, r2, i2, n2 = [];
              for (var a2 in Object(e3))
                X.call(e3, a2) && "constructor" != a2 && n2.push(a2);
              return n2;
            }
            function Ce(e3, t2, i2, n2, a2, o2) {
              var r2 = i2 & E, s2 = e3.length, l2 = t2.length;
              if (s2 != l2 && !(r2 && s2 < l2))
                return false;
              var u2 = o2.get(e3);
              if (u2 && o2.get(t2))
                return u2 == t2;
              var d2 = -1, f2 = true, c2 = i2 & _ ? new Oe() : void 0;
              for (o2.set(e3, t2), o2.set(t2, e3); ++d2 < s2; ) {
                var p2 = e3[d2], h2 = t2[d2];
                if (n2)
                  var m2 = r2 ? n2(h2, p2, d2, t2, e3, o2) : n2(p2, h2, d2, e3, t2, o2);
                if (void 0 !== m2) {
                  if (m2)
                    continue;
                  f2 = false;
                  break;
                }
                if (c2) {
                  if (!w(t2, function(e4, t3) {
                    if (r3 = t3, !c2.has(r3) && (p2 === e4 || a2(p2, e4, i2, n2, o2)))
                      return c2.push(t3);
                    var r3;
                  })) {
                    f2 = false;
                    break;
                  }
                } else if (p2 !== h2 && !a2(p2, h2, i2, n2, o2)) {
                  f2 = false;
                  break;
                }
              }
              return o2.delete(e3), o2.delete(t2), f2;
            }
            function xe(e3) {
              return r2 = Fe, i2 = qe(t2 = e3), Ke(t2) ? i2 : function(e4, t3) {
                for (var r3 = -1, i3 = t3.length, n2 = e4.length; ++r3 < i3; )
                  e4[n2 + r3] = t3[r3];
                return e4;
              }(i2, r2(t2));
              var t2, r2, i2;
            }
            function Ne(e3, t2) {
              var r2, i2, n2 = e3.__data__;
              return ("string" == (i2 = typeof (r2 = t2)) || "number" == i2 || "symbol" == i2 || "boolean" == i2 ? "__proto__" !== r2 : null === r2) ? n2["string" == typeof t2 ? "string" : "hash"] : n2.map;
            }
            function Be(e3, t2) {
              var r2, i2, n2 = (i2 = t2, null == (r2 = e3) ? void 0 : r2[i2]);
              return De(n2) ? n2 : void 0;
            }
            Ae.prototype.clear = function() {
              this.__data__ = pe ? pe(null) : {}, this.size = 0;
            }, Ae.prototype.delete = function(e3) {
              var t2 = this.has(e3) && delete this.__data__[e3];
              return this.size -= t2 ? 1 : 0, t2;
            }, Ae.prototype.get = function(e3) {
              var t2 = this.__data__;
              if (pe) {
                var r2 = t2[e3];
                return r2 === i ? void 0 : r2;
              }
              return X.call(t2, e3) ? t2[e3] : void 0;
            }, Ae.prototype.has = function(e3) {
              var t2 = this.__data__;
              return pe ? void 0 !== t2[e3] : X.call(t2, e3);
            }, Ae.prototype.set = function(e3, t2) {
              var r2 = this.__data__;
              return this.size += this.has(e3) ? 0 : 1, r2[e3] = pe && void 0 === t2 ? i : t2, this;
            }, Se.prototype.clear = function() {
              this.__data__ = [], this.size = 0;
            }, Se.prototype.delete = function(e3) {
              var t2 = this.__data__, r2 = Re(t2, e3);
              return !(r2 < 0 || (r2 == t2.length - 1 ? t2.pop() : ie.call(t2, r2, 1), --this.size, 0));
            }, Se.prototype.get = function(e3) {
              var t2 = this.__data__, r2 = Re(t2, e3);
              return r2 < 0 ? void 0 : t2[r2][1];
            }, Se.prototype.has = function(e3) {
              return -1 < Re(this.__data__, e3);
            }, Se.prototype.set = function(e3, t2) {
              var r2 = this.__data__, i2 = Re(r2, e3);
              return i2 < 0 ? (++this.size, r2.push([e3, t2])) : r2[i2][1] = t2, this;
            }, be.prototype.clear = function() {
              this.size = 0, this.__data__ = { hash: new Ae(), map: new (ue || Se)(), string: new Ae() };
            }, be.prototype.delete = function(e3) {
              var t2 = Ne(this, e3).delete(e3);
              return this.size -= t2 ? 1 : 0, t2;
            }, be.prototype.get = function(e3) {
              return Ne(this, e3).get(e3);
            }, be.prototype.has = function(e3) {
              return Ne(this, e3).has(e3);
            }, be.prototype.set = function(e3, t2) {
              var r2 = Ne(this, e3), i2 = r2.size;
              return r2.set(e3, t2), this.size += r2.size == i2 ? 0 : 1, this;
            }, Oe.prototype.add = Oe.prototype.push = function(e3) {
              return this.__data__.set(e3, i), this;
            }, Oe.prototype.has = function(e3) {
              return this.__data__.has(e3);
            }, Me.prototype.clear = function() {
              this.__data__ = new Se(), this.size = 0;
            }, Me.prototype.delete = function(e3) {
              var t2 = this.__data__, r2 = t2.delete(e3);
              return this.size = t2.size, r2;
            }, Me.prototype.get = function(e3) {
              return this.__data__.get(e3);
            }, Me.prototype.has = function(e3) {
              return this.__data__.has(e3);
            }, Me.prototype.set = function(e3, t2) {
              var r2 = this.__data__;
              if (r2 instanceof Se) {
                var i2 = r2.__data__;
                if (!ue || i2.length < 199)
                  return i2.push([e3, t2]), this.size = ++r2.size, this;
                r2 = this.__data__ = new be(i2);
              }
              return r2.set(e3, t2), this.size = r2.size, this;
            };
            var Fe = ae ? function(t2) {
              return null == t2 ? [] : (t2 = Object(t2), function(e3, t3) {
                for (var r2 = -1, i2 = null == e3 ? 0 : e3.length, n2 = 0, a2 = []; ++r2 < i2; ) {
                  var o2 = e3[r2];
                  t3(o2, r2, e3) && (a2[n2++] = o2);
                }
                return a2;
              }(ae(t2), function(e3) {
                return re.call(t2, e3);
              }));
            } : function() {
              return [];
            }, we = $e;
            function Ue(e3, t2) {
              return !!(t2 = null == t2 ? r : t2) && ("number" == typeof e3 || p.test(e3)) && -1 < e3 && e3 % 1 == 0 && e3 < t2;
            }
            function je(e3) {
              if (null != e3) {
                try {
                  return V.call(e3);
                } catch (e4) {
                }
                try {
                  return e3 + "";
                } catch (e4) {
                }
              }
              return "";
            }
            function Ze(e3, t2) {
              return e3 === t2 || e3 != e3 && t2 != t2;
            }
            (le && we(new le(new ArrayBuffer(1))) != L || ue && we(new ue()) != O || de && we(de.resolve()) != l || fe && we(new fe()) != $ || ce && we(new ce()) != f) && (we = function(e3) {
              var t2 = $e(e3), r2 = t2 == I ? e3.constructor : void 0, i2 = r2 ? je(r2) : "";
              if (i2)
                switch (i2) {
                  case he:
                    return L;
                  case me:
                    return O;
                  case ve:
                    return l;
                  case _e:
                    return $;
                  case ge:
                    return f;
                }
              return t2;
            });
            var Ye = Pe(/* @__PURE__ */ function() {
              return arguments;
            }()) ? Pe : function(e3) {
              return Ve(e3) && X.call(e3, "callee") && !re.call(e3, "callee");
            }, Ke = Array.isArray;
            var Ge = oe || function() {
              return false;
            };
            function He(e3) {
              if (!ke(e3))
                return false;
              var t2 = $e(e3);
              return t2 == a || t2 == o || t2 == n || t2 == u;
            }
            function We(e3) {
              return "number" == typeof e3 && -1 < e3 && e3 % 1 == 0 && e3 <= r;
            }
            function ke(e3) {
              var t2 = typeof e3;
              return null != e3 && ("object" == t2 || "function" == t2);
            }
            function Ve(e3) {
              return null != e3 && "object" == typeof e3;
            }
            var Xe, ze = F ? (Xe = F, function(e3) {
              return Xe(e3);
            }) : function(e3) {
              return Ve(e3) && We(e3.length) && !!t[$e(e3)];
            };
            function qe(e3) {
              return null != (t2 = e3) && We(t2.length) && !He(t2) ? Ie(e3) : Le(e3);
              var t2;
            }
            Qe.exports = function(e3, t2) {
              return Te(e3, t2);
            };
          }).call(this);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 3: [function(e, t, r) {
        var i, n, a = t.exports = {};
        function o() {
          throw new Error("setTimeout has not been defined");
        }
        function s() {
          throw new Error("clearTimeout has not been defined");
        }
        function l(t2) {
          if (i === setTimeout)
            return setTimeout(t2, 0);
          if ((i === o || !i) && setTimeout)
            return i = setTimeout, setTimeout(t2, 0);
          try {
            return i(t2, 0);
          } catch (e2) {
            try {
              return i.call(null, t2, 0);
            } catch (e3) {
              return i.call(this, t2, 0);
            }
          }
        }
        !function() {
          try {
            i = "function" == typeof setTimeout ? setTimeout : o;
          } catch (e2) {
            i = o;
          }
          try {
            n = "function" == typeof clearTimeout ? clearTimeout : s;
          } catch (e2) {
            n = s;
          }
        }();
        var u, d = [], f = false, c = -1;
        function p() {
          f && u && (f = false, u.length ? d = u.concat(d) : c = -1, d.length && h());
        }
        function h() {
          if (!f) {
            var e2 = l(p);
            f = true;
            for (var t2 = d.length; t2; ) {
              for (u = d, d = []; ++c < t2; )
                u && u[c].run();
              c = -1, t2 = d.length;
            }
            u = null, f = false, function(t3) {
              if (n === clearTimeout)
                return clearTimeout(t3);
              if ((n === s || !n) && clearTimeout)
                return n = clearTimeout, clearTimeout(t3);
              try {
                n(t3);
              } catch (e3) {
                try {
                  return n.call(null, t3);
                } catch (e4) {
                  return n.call(this, t3);
                }
              }
            }(e2);
          }
        }
        function m(e2, t2) {
          this.fun = e2, this.array = t2;
        }
        function v() {
        }
        a.nextTick = function(e2) {
          var t2 = new Array(arguments.length - 1);
          if (1 < arguments.length)
            for (var r2 = 1; r2 < arguments.length; r2++)
              t2[r2 - 1] = arguments[r2];
          d.push(new m(e2, t2)), 1 !== d.length || f || l(h);
        }, m.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, a.title = "browser", a.browser = true, a.env = {}, a.argv = [], a.version = "", a.versions = {}, a.on = v, a.addListener = v, a.once = v, a.off = v, a.removeListener = v, a.removeAllListeners = v, a.emit = v, a.prependListener = v, a.prependOnceListener = v, a.listeners = function(e2) {
          return [];
        }, a.binding = function(e2) {
          throw new Error("process.binding is not supported");
        }, a.cwd = function() {
          return "/";
        }, a.chdir = function(e2) {
          throw new Error("process.chdir is not supported");
        }, a.umask = function() {
          return 0;
        };
      }, {}], 4: [function(e, t, r) {
        "use strict";
        function o(e2) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var i = He(e("./lib/toDate")), n = He(e("./lib/toFloat")), a = He(e("./lib/toInt")), s = He(e("./lib/toBoolean")), l = He(e("./lib/equals")), u = He(e("./lib/contains")), d = He(e("./lib/matches")), f = He(e("./lib/isEmail")), c = He(e("./lib/isURL")), p = He(e("./lib/isMACAddress")), h = He(e("./lib/isIP")), m = He(e("./lib/isIPRange")), v = He(e("./lib/isFQDN")), _ = He(e("./lib/isDate")), g = He(e("./lib/isBoolean")), y = He(e("./lib/isLocale")), E = Ge(e("./lib/isAlpha")), A = Ge(e("./lib/isAlphanumeric")), S = He(e("./lib/isNumeric")), b = He(e("./lib/isPassportNumber")), O = He(e("./lib/isPort")), M = He(e("./lib/isLowercase")), I = He(e("./lib/isUppercase")), R = He(e("./lib/isIMEI")), $ = He(e("./lib/isAscii")), P = He(e("./lib/isFullWidth")), T = He(e("./lib/isHalfWidth")), D = He(e("./lib/isVariableWidth")), L = He(e("./lib/isMultibyte")), C = He(e("./lib/isSemVer")), x = He(e("./lib/isSurrogatePair")), N = He(e("./lib/isInt")), B = Ge(e("./lib/isFloat")), F = He(e("./lib/isDecimal")), w = He(e("./lib/isHexadecimal")), U = He(e("./lib/isOctal")), j = He(e("./lib/isDivisibleBy")), Z = He(e("./lib/isHexColor")), Y = He(e("./lib/isRgbColor")), K = He(e("./lib/isHSL")), G = He(e("./lib/isISRC")), H = Ge(e("./lib/isIBAN")), W = He(e("./lib/isBIC")), k = He(e("./lib/isMD5")), V = He(e("./lib/isHash")), X = He(e("./lib/isJWT")), z = He(e("./lib/isJSON")), q = He(e("./lib/isEmpty")), J = He(e("./lib/isLength")), Q = He(e("./lib/isByteLength")), ee = He(e("./lib/isUUID")), te = He(e("./lib/isMongoId")), re = He(e("./lib/isAfter")), ie = He(e("./lib/isBefore")), ne = He(e("./lib/isIn")), ae = He(e("./lib/isCreditCard")), oe = He(e("./lib/isIdentityCard")), se = He(e("./lib/isEAN")), le = He(e("./lib/isISIN")), ue = He(e("./lib/isISBN")), de = He(e("./lib/isISSN")), fe = He(e("./lib/isTaxID")), ce = Ge(e("./lib/isMobilePhone")), pe = He(e("./lib/isEthereumAddress")), he = He(e("./lib/isCurrency")), me = He(e("./lib/isBtcAddress")), ve = He(e("./lib/isISO8601")), _e = He(e("./lib/isRFC3339")), ge = He(e("./lib/isISO31661Alpha2")), ye = He(e("./lib/isISO31661Alpha3")), Ee = He(e("./lib/isISO4217")), Ae = He(e("./lib/isBase32")), Se = He(e("./lib/isBase58")), be = He(e("./lib/isBase64")), Oe = He(e("./lib/isDataURI")), Me = He(e("./lib/isMagnetURI")), Ie = He(e("./lib/isMimeType")), Re = He(e("./lib/isLatLong")), $e = Ge(e("./lib/isPostalCode")), Pe = He(e("./lib/ltrim")), Te = He(e("./lib/rtrim")), De = He(e("./lib/trim")), Le = He(e("./lib/escape")), Ce = He(e("./lib/unescape")), xe = He(e("./lib/stripLow")), Ne = He(e("./lib/whitelist")), Be = He(e("./lib/blacklist")), Fe = He(e("./lib/isWhitelisted")), we = He(e("./lib/normalizeEmail")), Ue = He(e("./lib/isSlug")), je = He(e("./lib/isLicensePlate")), Ze = He(e("./lib/isStrongPassword")), Ye = He(e("./lib/isVAT"));
        function Ke() {
          if ("function" != typeof WeakMap)
            return null;
          var e2 = /* @__PURE__ */ new WeakMap();
          return Ke = function() {
            return e2;
          }, e2;
        }
        function Ge(e2) {
          if (e2 && e2.__esModule)
            return e2;
          if (null === e2 || "object" !== o(e2) && "function" != typeof e2)
            return { default: e2 };
          var t2 = Ke();
          if (t2 && t2.has(e2))
            return t2.get(e2);
          var r2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var n2 in e2)
            if (Object.prototype.hasOwnProperty.call(e2, n2)) {
              var a2 = i2 ? Object.getOwnPropertyDescriptor(e2, n2) : null;
              a2 && (a2.get || a2.set) ? Object.defineProperty(r2, n2, a2) : r2[n2] = e2[n2];
            }
          return r2.default = e2, t2 && t2.set(e2, r2), r2;
        }
        function He(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var We = { version: "13.7.0", toDate: i.default, toFloat: n.default, toInt: a.default, toBoolean: s.default, equals: l.default, contains: u.default, matches: d.default, isEmail: f.default, isURL: c.default, isMACAddress: p.default, isIP: h.default, isIPRange: m.default, isFQDN: v.default, isBoolean: g.default, isIBAN: H.default, isBIC: W.default, isAlpha: E.default, isAlphaLocales: E.locales, isAlphanumeric: A.default, isAlphanumericLocales: A.locales, isNumeric: S.default, isPassportNumber: b.default, isPort: O.default, isLowercase: M.default, isUppercase: I.default, isAscii: $.default, isFullWidth: P.default, isHalfWidth: T.default, isVariableWidth: D.default, isMultibyte: L.default, isSemVer: C.default, isSurrogatePair: x.default, isInt: N.default, isIMEI: R.default, isFloat: B.default, isFloatLocales: B.locales, isDecimal: F.default, isHexadecimal: w.default, isOctal: U.default, isDivisibleBy: j.default, isHexColor: Z.default, isRgbColor: Y.default, isHSL: K.default, isISRC: G.default, isMD5: k.default, isHash: V.default, isJWT: X.default, isJSON: z.default, isEmpty: q.default, isLength: J.default, isLocale: y.default, isByteLength: Q.default, isUUID: ee.default, isMongoId: te.default, isAfter: re.default, isBefore: ie.default, isIn: ne.default, isCreditCard: ae.default, isIdentityCard: oe.default, isEAN: se.default, isISIN: le.default, isISBN: ue.default, isISSN: de.default, isMobilePhone: ce.default, isMobilePhoneLocales: ce.locales, isPostalCode: $e.default, isPostalCodeLocales: $e.locales, isEthereumAddress: pe.default, isCurrency: he.default, isBtcAddress: me.default, isISO8601: ve.default, isRFC3339: _e.default, isISO31661Alpha2: ge.default, isISO31661Alpha3: ye.default, isISO4217: Ee.default, isBase32: Ae.default, isBase58: Se.default, isBase64: be.default, isDataURI: Oe.default, isMagnetURI: Me.default, isMimeType: Ie.default, isLatLong: Re.default, ltrim: Pe.default, rtrim: Te.default, trim: De.default, escape: Le.default, unescape: Ce.default, stripLow: xe.default, whitelist: Ne.default, blacklist: Be.default, isWhitelisted: Fe.default, normalizeEmail: we.default, toString, isSlug: Ue.default, isStrongPassword: Ze.default, isTaxID: fe.default, isDate: _.default, isLicensePlate: je.default, isVAT: Ye.default, ibanLocales: H.locales };
        r.default = We, t.exports = r.default, t.exports.default = r.default;
      }, { "./lib/blacklist": 6, "./lib/contains": 7, "./lib/equals": 8, "./lib/escape": 9, "./lib/isAfter": 10, "./lib/isAlpha": 11, "./lib/isAlphanumeric": 12, "./lib/isAscii": 13, "./lib/isBIC": 14, "./lib/isBase32": 15, "./lib/isBase58": 16, "./lib/isBase64": 17, "./lib/isBefore": 18, "./lib/isBoolean": 19, "./lib/isBtcAddress": 20, "./lib/isByteLength": 21, "./lib/isCreditCard": 22, "./lib/isCurrency": 23, "./lib/isDataURI": 24, "./lib/isDate": 25, "./lib/isDecimal": 26, "./lib/isDivisibleBy": 27, "./lib/isEAN": 28, "./lib/isEmail": 29, "./lib/isEmpty": 30, "./lib/isEthereumAddress": 31, "./lib/isFQDN": 32, "./lib/isFloat": 33, "./lib/isFullWidth": 34, "./lib/isHSL": 35, "./lib/isHalfWidth": 36, "./lib/isHash": 37, "./lib/isHexColor": 38, "./lib/isHexadecimal": 39, "./lib/isIBAN": 40, "./lib/isIMEI": 41, "./lib/isIP": 42, "./lib/isIPRange": 43, "./lib/isISBN": 44, "./lib/isISIN": 45, "./lib/isISO31661Alpha2": 46, "./lib/isISO31661Alpha3": 47, "./lib/isISO4217": 48, "./lib/isISO8601": 49, "./lib/isISRC": 50, "./lib/isISSN": 51, "./lib/isIdentityCard": 52, "./lib/isIn": 53, "./lib/isInt": 54, "./lib/isJSON": 55, "./lib/isJWT": 56, "./lib/isLatLong": 57, "./lib/isLength": 58, "./lib/isLicensePlate": 59, "./lib/isLocale": 60, "./lib/isLowercase": 61, "./lib/isMACAddress": 62, "./lib/isMD5": 63, "./lib/isMagnetURI": 64, "./lib/isMimeType": 65, "./lib/isMobilePhone": 66, "./lib/isMongoId": 67, "./lib/isMultibyte": 68, "./lib/isNumeric": 69, "./lib/isOctal": 70, "./lib/isPassportNumber": 71, "./lib/isPort": 72, "./lib/isPostalCode": 73, "./lib/isRFC3339": 74, "./lib/isRgbColor": 75, "./lib/isSemVer": 76, "./lib/isSlug": 77, "./lib/isStrongPassword": 78, "./lib/isSurrogatePair": 79, "./lib/isTaxID": 80, "./lib/isURL": 81, "./lib/isUUID": 82, "./lib/isUppercase": 83, "./lib/isVAT": 84, "./lib/isVariableWidth": 85, "./lib/isWhitelisted": 86, "./lib/ltrim": 87, "./lib/matches": 88, "./lib/normalizeEmail": 89, "./lib/rtrim": 90, "./lib/stripLow": 91, "./lib/toBoolean": 92, "./lib/toDate": 93, "./lib/toFloat": 94, "./lib/toInt": 95, "./lib/trim": 96, "./lib/unescape": 97, "./lib/whitelist": 104 }], 5: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.commaDecimal = r.dotDecimal = r.farsiLocales = r.arabicLocales = r.englishLocales = r.decimal = r.alphanumeric = r.alpha = void 0;
        var i = { "en-US": /^[A-Z]+$/i, "az-AZ": /^[A-VXYZÇƏĞİıÖŞÜ]+$/i, "bg-BG": /^[А-Я]+$/i, "cs-CZ": /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i, "da-DK": /^[A-ZÆØÅ]+$/i, "de-DE": /^[A-ZÄÖÜß]+$/i, "el-GR": /^[Α-ώ]+$/i, "es-ES": /^[A-ZÁÉÍÑÓÚÜ]+$/i, "fa-IR": /^[ابپتثجچحخدذرزژسشصضطظعغفقکگلمنوهی]+$/i, "fi-FI": /^[A-ZÅÄÖ]+$/i, "fr-FR": /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i, "it-IT": /^[A-ZÀÉÈÌÎÓÒÙ]+$/i, "nb-NO": /^[A-ZÆØÅ]+$/i, "nl-NL": /^[A-ZÁÉËÏÓÖÜÚ]+$/i, "nn-NO": /^[A-ZÆØÅ]+$/i, "hu-HU": /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i, "pl-PL": /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i, "pt-PT": /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i, "ru-RU": /^[А-ЯЁ]+$/i, "sl-SI": /^[A-ZČĆĐŠŽ]+$/i, "sk-SK": /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i, "sr-RS@latin": /^[A-ZČĆŽŠĐ]+$/i, "sr-RS": /^[А-ЯЂЈЉЊЋЏ]+$/i, "sv-SE": /^[A-ZÅÄÖ]+$/i, "th-TH": /^[ก-๐\s]+$/i, "tr-TR": /^[A-ZÇĞİıÖŞÜ]+$/i, "uk-UA": /^[А-ЩЬЮЯЄIЇҐі]+$/i, "vi-VN": /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i, "ku-IQ": /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i, ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/, he: /^[א-ת]+$/, fa: /^['آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی']+$/i, "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i };
        r.alpha = i;
        var n = { "en-US": /^[0-9A-Z]+$/i, "az-AZ": /^[0-9A-VXYZÇƏĞİıÖŞÜ]+$/i, "bg-BG": /^[0-9А-Я]+$/i, "cs-CZ": /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i, "da-DK": /^[0-9A-ZÆØÅ]+$/i, "de-DE": /^[0-9A-ZÄÖÜß]+$/i, "el-GR": /^[0-9Α-ω]+$/i, "es-ES": /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i, "fi-FI": /^[0-9A-ZÅÄÖ]+$/i, "fr-FR": /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i, "it-IT": /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i, "hu-HU": /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i, "nb-NO": /^[0-9A-ZÆØÅ]+$/i, "nl-NL": /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i, "nn-NO": /^[0-9A-ZÆØÅ]+$/i, "pl-PL": /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i, "pt-PT": /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i, "ru-RU": /^[0-9А-ЯЁ]+$/i, "sl-SI": /^[0-9A-ZČĆĐŠŽ]+$/i, "sk-SK": /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i, "sr-RS@latin": /^[0-9A-ZČĆŽŠĐ]+$/i, "sr-RS": /^[0-9А-ЯЂЈЉЊЋЏ]+$/i, "sv-SE": /^[0-9A-ZÅÄÖ]+$/i, "th-TH": /^[ก-๙\s]+$/i, "tr-TR": /^[0-9A-ZÇĞİıÖŞÜ]+$/i, "uk-UA": /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i, "ku-IQ": /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i, "vi-VN": /^[0-9A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i, ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/, he: /^[0-9א-ת]+$/, fa: /^['0-9آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی۱۲۳۴۵۶۷۸۹۰']+$/i, "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i };
        r.alphanumeric = n;
        var a = { "en-US": ".", ar: "\u066B" };
        r.decimal = a;
        var o = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
        r.englishLocales = o;
        for (var s, l = 0; l < o.length; l++)
          i[s = "en-".concat(o[l])] = i["en-US"], n[s] = n["en-US"], a[s] = a["en-US"];
        var u = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
        r.arabicLocales = u;
        for (var d, f = 0; f < u.length; f++)
          i[d = "ar-".concat(u[f])] = i.ar, n[d] = n.ar, a[d] = a.ar;
        var c = ["IR", "AF"];
        r.farsiLocales = c;
        for (var p, h = 0; h < c.length; h++)
          n[p = "fa-".concat(c[h])] = n.fa, a[p] = a.ar;
        var m = ["ar-EG", "ar-LB", "ar-LY"];
        r.dotDecimal = m;
        var v = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
        r.commaDecimal = v;
        for (var _ = 0; _ < m.length; _++)
          a[m[_]] = a["en-US"];
        for (var g = 0; g < v.length; g++)
          a[v[g]] = ",";
        i["fr-CA"] = i["fr-FR"], n["fr-CA"] = n["fr-FR"], i["pt-BR"] = i["pt-PT"], n["pt-BR"] = n["pt-PT"], a["pt-BR"] = a["pt-PT"], i["pl-Pl"] = i["pl-PL"], n["pl-Pl"] = n["pl-PL"], a["pl-Pl"] = a["pl-PL"], i["fa-AF"] = i.fa;
      }, {}], 6: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), e2.replace(new RegExp("[".concat(t2, "]+"), "g"), "");
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 7: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2, r2) {
          if ((0, i.default)(e2), (r2 = (0, a.default)(r2, s)).ignoreCase)
            return e2.toLowerCase().split((0, n.default)(t2).toLowerCase()).length > r2.minOccurrences;
          return e2.split((0, n.default)(t2)).length > r2.minOccurrences;
        };
        var i = o(e("./util/assertString")), n = o(e("./util/toString")), a = o(e("./util/merge"));
        function o(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var s = { ignoreCase: false, minOccurrences: 1 };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101, "./util/toString": 103 }], 8: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), e2 === t2;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 9: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), e2.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;");
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 10: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : String(/* @__PURE__ */ new Date());
          (0, n.default)(e2);
          var r2 = (0, a.default)(t2), i2 = (0, a.default)(e2);
          return !!(i2 && r2 && r2 < i2);
        };
        var n = i(e("./util/assertString")), a = i(e("./toDate"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./toDate": 93, "./util/assertString": 99 }], 11: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "en-US", r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
          (0, a.default)(e2);
          var i2 = e2, n2 = r2.ignore;
          if (n2)
            if (n2 instanceof RegExp)
              i2 = i2.replace(n2, "");
            else {
              if ("string" != typeof n2)
                throw new Error("ignore should be instance of a String or RegExp");
              i2 = i2.replace(new RegExp("[".concat(n2.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
            }
          if (t2 in o.alpha)
            return o.alpha[t2].test(i2);
          throw new Error("Invalid locale '".concat(t2, "'"));
        }, r.locales = void 0;
        var i, a = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, o = e("./alpha");
        var n = Object.keys(o.alpha);
        r.locales = n;
      }, { "./alpha": 5, "./util/assertString": 99 }], 12: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "en-US", r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
          (0, a.default)(e2);
          var i2 = e2, n2 = r2.ignore;
          if (n2)
            if (n2 instanceof RegExp)
              i2 = i2.replace(n2, "");
            else {
              if ("string" != typeof n2)
                throw new Error("ignore should be instance of a String or RegExp");
              i2 = i2.replace(new RegExp("[".concat(n2.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
            }
          if (t2 in o.alphanumeric)
            return o.alphanumeric[t2].test(i2);
          throw new Error("Invalid locale '".concat(t2, "'"));
        }, r.locales = void 0;
        var i, a = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, o = e("./alpha");
        var n = Object.keys(o.alphanumeric);
        r.locales = n;
      }, { "./alpha": 5, "./util/assertString": 99 }], 13: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[\x00-\x7F]+$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 14: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), !!a.CountryCodes.has(e2.slice(4, 6).toUpperCase()) && o.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, a = e("./isISO31661Alpha2");
        var o = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isISO31661Alpha2": 46, "./util/assertString": 99 }], 15: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          if ((0, n.default)(e2), e2.length % 8 == 0 && a.test(e2))
            return true;
          return false;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[A-Z2-7]+=*$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 16: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          if ((0, n.default)(e2), a.test(e2))
            return true;
          return false;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[A-HJ-NP-Za-km-z1-9]*$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 17: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2), t2 = (0, a.default)(t2, l);
          var r2 = e2.length;
          if (t2.urlSafe)
            return s.test(e2);
          if (r2 % 4 != 0 || o.test(e2))
            return false;
          var i2 = e2.indexOf("=");
          return -1 === i2 || i2 === r2 - 1 || i2 === r2 - 2 && "=" === e2[r2 - 1];
        };
        var n = i(e("./util/assertString")), a = i(e("./util/merge"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = /[^A-Z0-9+\/=]/i, s = /^[A-Z0-9_\-]*$/i, l = { urlSafe: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 18: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : String(/* @__PURE__ */ new Date());
          (0, n.default)(e2);
          var r2 = (0, a.default)(t2), i2 = (0, a.default)(e2);
          return !!(i2 && r2 && i2 < r2);
        };
        var n = i(e("./util/assertString")), a = i(e("./toDate"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./toDate": 93, "./util/assertString": 99 }], 19: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : a;
          if ((0, n.default)(e2), t2.loose)
            return s.includes(e2.toLowerCase());
          return o.includes(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { loose: false }, o = ["true", "false", "1", "0"], s = [].concat(o, ["yes", "no"]);
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 20: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          if ((0, n.default)(e2), e2.startsWith("bc1"))
            return a.test(e2);
          return o.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(bc1)[a-z0-9]{25,39}$/, o = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 21: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          var r2, i2;
          (0, a.default)(e2), i2 = "object" === o(t2) ? (r2 = t2.min || 0, t2.max) : (r2 = arguments[1], arguments[2]);
          var n = encodeURI(e2).split(/%..|./).length - 1;
          return r2 <= n && (void 0 === i2 || n <= i2);
        };
        var i, a = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        function o(e2) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 22: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          (0, s.default)(e2);
          var t2 = e2.replace(/[- ]+/g, "");
          if (!l.test(t2))
            return false;
          for (var r2, i2, n, a = 0, o = t2.length - 1; 0 <= o; o--)
            r2 = t2.substring(o, o + 1), i2 = parseInt(r2, 10), a += n && 10 <= (i2 *= 2) ? i2 % 10 + 1 : i2, n = !n;
          return !(a % 10 != 0 || !t2);
        };
        var i, s = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var l = /^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 23: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), function(e3) {
            var r2 = "\\d{".concat(e3.digits_after_decimal[0], "}");
            e3.digits_after_decimal.forEach(function(e4, t4) {
              0 !== t4 && (r2 = "".concat(r2, "|\\d{").concat(e4, "}"));
            });
            var t3 = "(".concat(e3.symbol.replace(/\W/, function(e4) {
              return "\\".concat(e4);
            }), ")").concat(e3.require_symbol ? "" : "?"), i2 = "[1-9]\\d{0,2}(\\".concat(e3.thousands_separator, "\\d{3})*"), n2 = "(".concat(["0", "[1-9]\\d*", i2].join("|"), ")?"), a2 = "(\\".concat(e3.decimal_separator, "(").concat(r2, "))").concat(e3.require_decimal ? "" : "?"), o2 = n2 + (e3.allow_decimal || e3.require_decimal ? a2 : "");
            return e3.allow_negatives && !e3.parens_for_negatives && (e3.negative_sign_after_digits ? o2 += "-?" : e3.negative_sign_before_digits && (o2 = "-?" + o2)), e3.allow_negative_sign_placeholder ? o2 = "( (?!\\-))?".concat(o2) : e3.allow_space_after_symbol ? o2 = " ?".concat(o2) : e3.allow_space_after_digits && (o2 += "( (?!$))?"), e3.symbol_after_digits ? o2 += t3 : o2 = t3 + o2, e3.allow_negatives && (e3.parens_for_negatives ? o2 = "(\\(".concat(o2, "\\)|").concat(o2, ")") : e3.negative_sign_before_digits || e3.negative_sign_after_digits || (o2 = "-?" + o2)), new RegExp("^(?!-? )(?=.*\\d)".concat(o2, "$"));
          }(t2 = (0, i.default)(t2, o)).test(e2);
        };
        var i = a(e("./util/merge")), n = a(e("./util/assertString"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = { symbol: "$", require_symbol: false, allow_space_after_symbol: false, symbol_after_digits: false, allow_negatives: true, parens_for_negatives: false, negative_sign_before_digits: false, negative_sign_after_digits: false, allow_negative_sign_placeholder: false, thousands_separator: ",", decimal_separator: ".", allow_decimal: true, require_decimal: false, digits_after_decimal: [2], allow_space_after_digits: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 24: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          (0, s.default)(e2);
          var t2 = e2.split(",");
          if (t2.length < 2)
            return false;
          var r2 = t2.shift().trim().split(";"), i2 = r2.shift();
          if ("data:" !== i2.substr(0, 5))
            return false;
          var n = i2.substr(5);
          if ("" !== n && !l.test(n))
            return false;
          for (var a = 0; a < r2.length; a++)
            if ((a !== r2.length - 1 || "base64" !== r2[a].toLowerCase()) && !u.test(r2[a]))
              return false;
          for (var o = 0; o < t2.length; o++)
            if (!d.test(t2[o]))
              return false;
          return true;
        };
        var i, s = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var l = /^[a-z]+\/[a-z0-9\-\+]+$/i, u = /^[a-z\-]+=[a-z0-9\-]+$/i, d = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 25: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(t2, r2) {
          r2 = "string" == typeof r2 ? (0, h.default)({ format: r2 }, v) : (0, h.default)(r2, v);
          if ("string" == typeof t2 && (p = r2.format, /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(p))) {
            var e2, i2 = r2.delimiters.find(function(e3) {
              return -1 !== r2.format.indexOf(e3);
            }), n2 = r2.strictMode ? i2 : r2.delimiters.find(function(e3) {
              return -1 !== t2.indexOf(e3);
            }), a = function(e3, t3) {
              for (var r3 = [], i3 = Math.min(e3.length, t3.length), n3 = 0; n3 < i3; n3++)
                r3.push([e3[n3], t3[n3]]);
              return r3;
            }(t2.split(n2), r2.format.toLowerCase().split(i2)), o = {}, s = function(e3, t3) {
              var r3;
              if ("undefined" == typeof Symbol || null == e3[Symbol.iterator]) {
                if (Array.isArray(e3) || (r3 = m(e3)) || t3 && e3 && "number" == typeof e3.length) {
                  r3 && (e3 = r3);
                  var i3 = 0, n3 = function() {
                  };
                  return { s: n3, n: function() {
                    return i3 >= e3.length ? { done: true } : { done: false, value: e3[i3++] };
                  }, e: function(e4) {
                    throw e4;
                  }, f: n3 };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var a2, o2 = true, s2 = false;
              return { s: function() {
                r3 = e3[Symbol.iterator]();
              }, n: function() {
                var e4 = r3.next();
                return o2 = e4.done, e4;
              }, e: function(e4) {
                s2 = true, a2 = e4;
              }, f: function() {
                try {
                  o2 || null == r3.return || r3.return();
                } finally {
                  if (s2)
                    throw a2;
                }
              } };
            }(a);
            try {
              for (s.s(); !(e2 = s.n()).done; ) {
                var l = (f = e2.value, c = 2, function(e3) {
                  if (Array.isArray(e3))
                    return e3;
                }(f) || function(e3, t3) {
                  if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e3)))
                    return;
                  var r3 = [], i3 = true, n3 = false, a2 = void 0;
                  try {
                    for (var o2, s2 = e3[Symbol.iterator](); !(i3 = (o2 = s2.next()).done) && (r3.push(o2.value), !t3 || r3.length !== t3); i3 = true)
                      ;
                  } catch (e4) {
                    n3 = true, a2 = e4;
                  } finally {
                    try {
                      i3 || null == s2.return || s2.return();
                    } finally {
                      if (n3)
                        throw a2;
                    }
                  }
                  return r3;
                }(f, c) || m(f, c) || function() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }()), u = l[0], d = l[1];
                if (u.length !== d.length)
                  return false;
                o[d.charAt(0)] = u;
              }
            } catch (e3) {
              s.e(e3);
            } finally {
              s.f();
            }
            return new Date("".concat(o.m, "/").concat(o.d, "/").concat(o.y)).getDate() === +o.d;
          }
          var f, c;
          var p;
          return !r2.strictMode && "[object Date]" === Object.prototype.toString.call(t2) && isFinite(t2);
        };
        var i, h = (i = e("./util/merge")) && i.__esModule ? i : { default: i };
        function m(e2, t2) {
          if (e2) {
            if ("string" == typeof e2)
              return n(e2, t2);
            var r2 = Object.prototype.toString.call(e2).slice(8, -1);
            return "Object" === r2 && e2.constructor && (r2 = e2.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(e2) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? n(e2, t2) : void 0;
          }
        }
        function n(e2, t2) {
          (null == t2 || t2 > e2.length) && (t2 = e2.length);
          for (var r2 = 0, i2 = new Array(t2); r2 < t2; r2++)
            i2[r2] = e2[r2];
          return i2;
        }
        var v = { format: "YYYY/MM/DD", delimiters: ["/", "-"], strictMode: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/merge": 101 }], 26: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), (t2 = (0, i.default)(t2, l)).locale in o.decimal)
            return !(0, a.default)(u, e2.replace(/ /g, "")) && (r2 = t2, new RegExp("^[-+]?([0-9]+)?(\\".concat(o.decimal[r2.locale], "[0-9]{").concat(r2.decimal_digits, "})").concat(r2.force_decimal ? "" : "?", "$"))).test(e2);
          var r2;
          throw new Error("Invalid locale '".concat(t2.locale, "'"));
        };
        var i = s(e("./util/merge")), n = s(e("./util/assertString")), a = s(e("./util/includes")), o = e("./alpha");
        function s(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var l = { force_decimal: false, decimal_digits: "1,", locale: "en-US" }, u = ["", "-", "+"];
        t.exports = r.default, t.exports.default = r.default;
      }, { "./alpha": 5, "./util/assertString": 99, "./util/includes": 100, "./util/merge": 101 }], 27: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, i.default)(e2), (0, n.default)(e2) % parseInt(t2, 10) == 0;
        };
        var i = a(e("./util/assertString")), n = a(e("./toFloat"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./toFloat": 94, "./util/assertString": 99 }], 28: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          (0, a.default)(e2);
          var t2 = Number(e2.slice(-1));
          return l.test(e2) && t2 === (n = e2, r2 = 10 - n.slice(0, -1).split("").map(function(e3, t3) {
            return Number(e3) * (r3 = n.length, i2 = t3, r3 !== o && r3 !== s ? i2 % 2 == 0 ? 1 : 3 : i2 % 2 == 0 ? 3 : 1);
            var r3, i2;
          }).reduce(function(e3, t3) {
            return e3 + t3;
          }, 0) % 10, r2 < 10 ? r2 : 0);
          var n, r2;
        };
        var i, a = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var o = 8, s = 14, l = /^(\d{8}|\d{13}|\d{14})$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 29: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, m.default)(e2), (t2 = (0, v.default)(t2, E)).require_display_name || t2.allow_display_name) {
            var r2 = e2.match(A);
            if (r2) {
              var i2 = r2[1];
              if (e2 = e2.replace(i2, "").replace(/(^<|>$)/g, ""), i2.endsWith(" ") && (i2 = i2.substr(0, i2.length - 1)), !function(e3) {
                var t3 = e3.replace(/^"(.+)"$/, "$1");
                if (!t3.trim())
                  return false;
                if (/[\.";<>]/.test(t3)) {
                  if (t3 === e3)
                    return false;
                  var r3 = t3.split('"').length === t3.split('\\"').length;
                  if (!r3)
                    return false;
                }
                return true;
              }(i2))
                return false;
            } else if (t2.require_display_name)
              return false;
          }
          if (!t2.ignore_max_length && e2.length > R)
            return false;
          var n = e2.split("@"), a = n.pop(), o = a.toLowerCase();
          if (t2.host_blacklist.includes(o))
            return false;
          var s = n.join("@");
          if (t2.domain_specific_validation && ("gmail.com" === o || "googlemail.com" === o)) {
            var l = (s = s.toLowerCase()).split("+")[0];
            if (!(0, _.default)(l.replace(/\./g, ""), { min: 6, max: 30 }))
              return false;
            for (var u = l.split("."), d = 0; d < u.length; d++)
              if (!b.test(u[d]))
                return false;
          }
          if (!(false !== t2.ignore_max_length || (0, _.default)(s, { max: 64 }) && (0, _.default)(a, { max: 254 })))
            return false;
          if (!(0, g.default)(a, { require_tld: t2.require_tld })) {
            if (!t2.allow_ip_domain)
              return false;
            if (!(0, y.default)(a)) {
              if (!a.startsWith("[") || !a.endsWith("]"))
                return false;
              var f = a.substr(1, a.length - 2);
              if (0 === f.length || !(0, y.default)(f))
                return false;
            }
          }
          if ('"' === s[0])
            return s = s.slice(1, s.length - 1), t2.allow_utf8_local_part ? I.test(s) : O.test(s);
          for (var c = t2.allow_utf8_local_part ? M : S, p = s.split("."), h = 0; h < p.length; h++)
            if (!c.test(p[h]))
              return false;
          if (t2.blacklisted_chars && -1 !== s.search(new RegExp("[".concat(t2.blacklisted_chars, "]+"), "g")))
            return false;
          return true;
        };
        var m = i(e("./util/assertString")), v = i(e("./util/merge")), _ = i(e("./isByteLength")), g = i(e("./isFQDN")), y = i(e("./isIP"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var E = { allow_display_name: false, require_display_name: false, allow_utf8_local_part: true, require_tld: true, blacklisted_chars: "", ignore_max_length: false, host_blacklist: [] }, A = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i, S = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i, b = /^[a-z\d]+$/, O = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i, M = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i, I = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i, R = 254;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isByteLength": 21, "./isFQDN": 32, "./isIP": 42, "./util/assertString": 99, "./util/merge": 101 }], 30: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, i.default)(e2), 0 === ((t2 = (0, n.default)(t2, o)).ignore_whitespace ? e2.trim().length : e2.length);
        };
        var i = a(e("./util/assertString")), n = a(e("./util/merge"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = { ignore_whitespace: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 31: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(0x)[0-9a-f]{40}$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 32: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2), (t2 = (0, a.default)(t2, o)).allow_trailing_dot && "." === e2[e2.length - 1] && (e2 = e2.substring(0, e2.length - 1));
          true === t2.allow_wildcard && 0 === e2.indexOf("*.") && (e2 = e2.substring(2));
          var r2 = e2.split("."), i2 = r2[r2.length - 1];
          if (t2.require_tld) {
            if (r2.length < 2)
              return false;
            if (!/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(i2))
              return false;
            if (/\s/.test(i2))
              return false;
          }
          return !(!t2.allow_numeric_tld && /^\d+$/.test(i2)) && r2.every(function(e3) {
            return !(63 < e3.length || !/^[a-z_\u00a1-\uffff0-9-]+$/i.test(e3) || /[\uff01-\uff5e]/.test(e3) || /^-|-$/.test(e3) || !t2.allow_underscores && /_/.test(e3));
          });
        };
        var n = i(e("./util/assertString")), a = i(e("./util/merge"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = { require_tld: true, allow_underscores: false, allow_trailing_dot: false, allow_numeric_tld: false, allow_wildcard: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 33: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2), t2 = t2 || {};
          var r2 = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(t2.locale ? a.decimal[t2.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
          if ("" === e2 || "." === e2 || "-" === e2 || "+" === e2)
            return false;
          var i2 = parseFloat(e2.replace(",", "."));
          return r2.test(e2) && (!t2.hasOwnProperty("min") || i2 >= t2.min) && (!t2.hasOwnProperty("max") || i2 <= t2.max) && (!t2.hasOwnProperty("lt") || i2 < t2.lt) && (!t2.hasOwnProperty("gt") || i2 > t2.gt);
        }, r.locales = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, a = e("./alpha");
        var o = Object.keys(a.decimal);
        r.locales = o;
      }, { "./alpha": 5, "./util/assertString": 99 }], 34: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        }, r.fullWidth = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
        r.fullWidth = a;
      }, { "./util/assertString": 99 }], 35: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          (0, n.default)(e2);
          var t2 = e2.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/gi, "$1");
          return -1 === t2.indexOf(",") ? o.test(t2) : a.test(t2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i, o = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 36: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        }, r.halfWidth = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
        r.halfWidth = a;
      }, { "./util/assertString": 99 }], 37: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), new RegExp("^[a-fA-F0-9]{".concat(a[t2], "}$")).test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { md5: 32, md4: 32, sha1: 40, sha256: 64, sha384: 96, sha512: 128, ripemd128: 32, ripemd160: 40, tiger128: 32, tiger160: 40, tiger192: 48, crc32: 8, crc32b: 8 };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 38: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 39: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(0x|0h)?[0-9A-F]+$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 40: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, o.default)(e2), i2 = e2, n2 = i2.replace(/[\s\-]+/gi, "").toUpperCase(), a = n2.slice(0, 2).toUpperCase(), a in s && s[a].test(n2) && (t2 = e2, r2 = t2.replace(/[^A-Z0-9]+/gi, "").toUpperCase(), 1 === (r2.slice(4) + r2.slice(0, 4)).replace(/[A-Z]/g, function(e3) {
            return e3.charCodeAt(0) - 55;
          }).match(/\d{1,7}/g).reduce(function(e3, t3) {
            return Number(e3 + t3) % 97;
          }, ""));
          var t2, r2;
          var i2, n2, a;
        }, r.locales = void 0;
        var i, o = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var s = { AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/, AE: /^(AE[0-9]{2})\d{3}\d{16}$/, AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/, AT: /^(AT[0-9]{2})\d{16}$/, AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/, BA: /^(BA[0-9]{2})\d{16}$/, BE: /^(BE[0-9]{2})\d{12}$/, BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/, BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/, BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/, BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/, CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/, CR: /^(CR[0-9]{2})\d{18}$/, CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/, CZ: /^(CZ[0-9]{2})\d{20}$/, DE: /^(DE[0-9]{2})\d{18}$/, DK: /^(DK[0-9]{2})\d{14}$/, DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/, EE: /^(EE[0-9]{2})\d{16}$/, EG: /^(EG[0-9]{2})\d{25}$/, ES: /^(ES[0-9]{2})\d{20}$/, FI: /^(FI[0-9]{2})\d{14}$/, FO: /^(FO[0-9]{2})\d{14}$/, FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/, GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/, GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/, GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/, GL: /^(GL[0-9]{2})\d{14}$/, GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/, GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/, HR: /^(HR[0-9]{2})\d{17}$/, HU: /^(HU[0-9]{2})\d{24}$/, IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/, IL: /^(IL[0-9]{2})\d{19}$/, IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/, IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/, IS: /^(IS[0-9]{2})\d{22}$/, IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/, JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/, KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/, KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/, LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/, LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/, LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/, LT: /^(LT[0-9]{2})\d{16}$/, LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/, LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/, MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/, MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/, ME: /^(ME[0-9]{2})\d{18}$/, MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/, MR: /^(MR[0-9]{2})\d{23}$/, MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/, MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/, MZ: /^(MZ[0-9]{2})\d{21}$/, NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/, NO: /^(NO[0-9]{2})\d{11}$/, PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/, PL: /^(PL[0-9]{2})\d{24}$/, PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/, PT: /^(PT[0-9]{2})\d{21}$/, QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/, RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/, RS: /^(RS[0-9]{2})\d{18}$/, SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/, SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/, SE: /^(SE[0-9]{2})\d{20}$/, SI: /^(SI[0-9]{2})\d{15}$/, SK: /^(SK[0-9]{2})\d{20}$/, SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/, SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/, TL: /^(TL[0-9]{2})\d{19}$/, TN: /^(TN[0-9]{2})\d{20}$/, TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/, UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/, VA: /^(VA[0-9]{2})\d{18}$/, VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/, XK: /^(XK[0-9]{2})\d{16}$/ };
        var n = Object.keys(s);
        r.locales = n;
      }, { "./util/assertString": 99 }], 41: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, l.default)(e2);
          var r2 = u;
          (t2 = t2 || {}).allow_hyphens && (r2 = d);
          if (!r2.test(e2))
            return false;
          e2 = e2.replace(/-/g, "");
          for (var i2 = 0, n = 2, a = 0; a < 14; a++) {
            var o = e2.substring(14 - a - 1, 14 - a), s = parseInt(o, 10) * n;
            i2 += 10 <= s ? s % 10 + 1 : s, 1 === n ? n += 1 : n -= 1;
          }
          return (10 - i2 % 10) % 10 === parseInt(e2.substring(14, 15), 10);
        };
        var i, l = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var u = /^[0-9]{15}$/, d = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 42: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function e2(t2) {
          var r2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "";
          (0, n.default)(t2);
          r2 = String(r2);
          if (!r2)
            return e2(t2, 4) || e2(t2, 6);
          if ("4" === r2) {
            if (!s.test(t2))
              return false;
            var i2 = t2.split(".").sort(function(e3, t3) {
              return e3 - t3;
            });
            return i2[3] <= 255;
          }
          if ("6" === r2)
            return !!u.test(t2);
          return false;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])", o = "(".concat(a, "[.]){3}").concat(a), s = new RegExp("^".concat(o, "$")), l = "(?:[0-9a-fA-F]{1,4})", u = new RegExp("^(" + "(?:".concat(l, ":){7}(?:").concat(l, "|:)|") + "(?:".concat(l, ":){6}(?:").concat(o, "|:").concat(l, "|:)|") + "(?:".concat(l, ":){5}(?::").concat(o, "|(:").concat(l, "){1,2}|:)|") + "(?:".concat(l, ":){4}(?:(:").concat(l, "){0,1}:").concat(o, "|(:").concat(l, "){1,3}|:)|") + "(?:".concat(l, ":){3}(?:(:").concat(l, "){0,2}:").concat(o, "|(:").concat(l, "){1,4}|:)|") + "(?:".concat(l, ":){2}(?:(:").concat(l, "){0,3}:").concat(o, "|(:").concat(l, "){1,5}|:)|") + "(?:".concat(l, ":){1}(?:(:").concat(l, "){0,4}:").concat(o, "|(:").concat(l, "){1,6}|:)|") + "(?::((?::".concat(l, "){0,5}:").concat(o, "|(?::").concat(l, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 43: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "";
          (0, n.default)(e2);
          var r2 = e2.split("/");
          if (2 !== r2.length)
            return false;
          if (!o.test(r2[1]))
            return false;
          if (1 < r2[1].length && r2[1].startsWith("0"))
            return false;
          if (!(0, a.default)(r2[0], t2))
            return false;
          var i2 = null;
          switch (String(t2)) {
            case "4":
              i2 = s;
              break;
            case "6":
              i2 = l;
              break;
            default:
              i2 = (0, a.default)(r2[0], "6") ? l : s;
          }
          return r2[1] <= i2 && 0 <= r2[1];
        };
        var n = i(e("./util/assertString")), a = i(e("./isIP"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = /^\d{1,3}$/, s = 32, l = 128;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isIP": 42, "./util/assertString": 99 }], 44: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function e2(t2) {
          var r2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "";
          (0, o.default)(t2);
          r2 = String(r2);
          if (!r2)
            return e2(t2, 10) || e2(t2, 13);
          var i2 = t2.replace(/[\s-]+/g, "");
          var n = 0;
          var a;
          if ("10" === r2) {
            if (!s.test(i2))
              return false;
            for (a = 0; a < 9; a++)
              n += (a + 1) * i2.charAt(a);
            if ("X" === i2.charAt(9) ? n += 100 : n += 10 * i2.charAt(9), n % 11 == 0)
              return !!i2;
          } else if ("13" === r2) {
            if (!l.test(i2))
              return false;
            for (a = 0; a < 12; a++)
              n += u[a % 2] * i2.charAt(a);
            if (i2.charAt(12) - (10 - n % 10) % 10 == 0)
              return !!i2;
          }
          return false;
        };
        var i, o = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var s = /^(?:[0-9]{9}X|[0-9]{10})$/, l = /^(?:[0-9]{13})$/, u = [1, 3];
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 45: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          if ((0, c.default)(e2), !p.test(e2))
            return false;
          for (var t2 = true, r2 = 0, i2 = e2.length - 2; 0 <= i2; i2--)
            if ("A" <= e2[i2] && e2[i2] <= "Z")
              for (var n = e2[i2].charCodeAt(0) - 55, a = n % 10, o = Math.trunc(n / 10), s = 0, l = [a, o]; s < l.length; s++) {
                var u = l[s];
                r2 += t2 ? 5 <= u ? 1 + 2 * (u - 5) : 2 * u : u, t2 = !t2;
              }
            else {
              var d = e2[i2].charCodeAt(0) - "0".charCodeAt(0);
              r2 += t2 ? 5 <= d ? 1 + 2 * (d - 5) : 2 * d : d, t2 = !t2;
            }
          var f = 10 * Math.trunc((r2 + 9) / 10) - r2;
          return +e2[e2.length - 1] === f;
        };
        var i, c = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var p = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 46: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.has(e2.toUpperCase());
        }, r.CountryCodes = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /* @__PURE__ */ new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
        var o = a;
        r.CountryCodes = o;
      }, { "./util/assertString": 99 }], 47: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.has(e2.toUpperCase());
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /* @__PURE__ */ new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 48: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.has(e2.toUpperCase());
        }, r.CurrencyCodes = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /* @__PURE__ */ new Set(["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"]);
        var o = a;
        r.CurrencyCodes = o;
      }, { "./util/assertString": 99 }], 49: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
          (0, n.default)(e2);
          var r2 = t2.strictSeparator ? o.test(e2) : a.test(e2);
          return r2 && t2.strict ? s(e2) : r2;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/, o = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/, s = function(e2) {
          var t2 = e2.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
          if (t2) {
            var r2 = Number(t2[1]), i2 = Number(t2[2]);
            return r2 % 4 == 0 && r2 % 100 != 0 || r2 % 400 == 0 ? i2 <= 366 : i2 <= 365;
          }
          var n2 = e2.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number), a2 = n2[1], o2 = n2[2], s2 = n2[3], l = o2 ? "0".concat(o2).slice(-2) : o2, u = s2 ? "0".concat(s2).slice(-2) : s2, d = new Date("".concat(a2, "-").concat(l || "01", "-").concat(u || "01"));
          return !o2 || !s2 || d.getUTCFullYear() === a2 && d.getUTCMonth() + 1 === o2 && d.getUTCDate() === s2;
        };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 50: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 51: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
          (0, s.default)(e2);
          var r2 = l;
          if (r2 = t2.require_hyphen ? r2.replace("?", "") : r2, !(r2 = t2.case_sensitive ? new RegExp(r2) : new RegExp(r2, "i")).test(e2))
            return false;
          for (var i2 = e2.replace("-", "").toUpperCase(), n = 0, a = 0; a < i2.length; a++) {
            var o = i2[a];
            n += ("X" === o ? 10 : +o) * (8 - a);
          }
          return n % 11 == 0;
        };
        var i, s = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var l = "^\\d{4}-?\\d{3}[\\dX]$";
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 52: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          {
            if ((0, n.default)(e2), t2 in o)
              return o[t2](e2);
            if ("any" === t2) {
              for (var r2 in o)
                if (o.hasOwnProperty(r2)) {
                  var i2 = o[r2];
                  if (i2(e2))
                    return true;
                }
              return false;
            }
          }
          throw new Error("Invalid locale '".concat(t2, "'"));
        };
        var n = i(e("./util/assertString")), a = i(e("./isInt"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = { PL: function(e2) {
          (0, n.default)(e2);
          var i2 = { 1: 1, 2: 3, 3: 7, 4: 9, 5: 1, 6: 3, 7: 7, 8: 9, 9: 1, 10: 3, 11: 0 };
          if (null != e2 && 11 === e2.length && (0, a.default)(e2, { allow_leading_zeroes: true })) {
            var t2 = e2.split("").slice(0, -1).reduce(function(e3, t3, r3) {
              return e3 + Number(t3) * i2[r3 + 1];
            }, 0) % 10, r2 = Number(e2.charAt(e2.length - 1));
            if (0 === t2 && 0 === r2 || r2 === 10 - t2)
              return true;
          }
          return false;
        }, ES: function(e2) {
          (0, n.default)(e2);
          var t2 = { X: 0, Y: 1, Z: 2 }, r2 = e2.trim().toUpperCase();
          if (!/^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/.test(r2))
            return false;
          var i2 = r2.slice(0, -1).replace(/[X,Y,Z]/g, function(e3) {
            return t2[e3];
          });
          return r2.endsWith(["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"][i2 % 23]);
        }, FI: function(e2) {
          if ((0, n.default)(e2), 11 !== e2.length)
            return false;
          if (!e2.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/))
            return false;
          return "0123456789ABCDEFHJKLMNPRSTUVWXY"[(1e3 * parseInt(e2.slice(0, 6), 10) + parseInt(e2.slice(7, 10), 10)) % 31] === e2.slice(10, 11);
        }, IN: function(e2) {
          var r2 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]], i2 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]], t2 = e2.trim();
          if (!/^[1-9]\d{3}\s?\d{4}\s?\d{4}$/.test(t2))
            return false;
          var n2 = 0;
          return t2.replace(/\s/g, "").split("").map(Number).reverse().forEach(function(e3, t3) {
            n2 = r2[n2][i2[t3 % 8][e3]];
          }), 0 === n2;
        }, IR: function(e2) {
          if (!e2.match(/^\d{10}$/))
            return false;
          if (e2 = "0000".concat(e2).substr(e2.length - 6), 0 === parseInt(e2.substr(3, 6), 10))
            return false;
          for (var t2 = parseInt(e2.substr(9, 1), 10), r2 = 0, i2 = 0; i2 < 9; i2++)
            r2 += parseInt(e2.substr(i2, 1), 10) * (10 - i2);
          return (r2 %= 11) < 2 && t2 === r2 || 2 <= r2 && t2 === 11 - r2;
        }, IT: function(e2) {
          return 9 === e2.length && ("CA00000AA" !== e2 && -1 < e2.search(/C[A-Z][0-9]{5}[A-Z]{2}/i));
        }, NO: function(e2) {
          var t2 = e2.trim();
          if (isNaN(Number(t2)))
            return false;
          if (11 !== t2.length)
            return false;
          if ("00000000000" === t2)
            return false;
          var r2 = t2.split("").map(Number), i2 = (11 - (3 * r2[0] + 7 * r2[1] + 6 * r2[2] + 1 * r2[3] + 8 * r2[4] + 9 * r2[5] + 4 * r2[6] + 5 * r2[7] + 2 * r2[8]) % 11) % 11, n2 = (11 - (5 * r2[0] + 4 * r2[1] + 3 * r2[2] + 2 * r2[3] + 7 * r2[4] + 6 * r2[5] + 5 * r2[6] + 4 * r2[7] + 3 * r2[8] + 2 * i2) % 11) % 11;
          return i2 === r2[9] && n2 === r2[10];
        }, TH: function(e2) {
          if (!e2.match(/^[1-8]\d{12}$/))
            return false;
          for (var t2 = 0, r2 = 0; r2 < 12; r2++)
            t2 += parseInt(e2[r2], 10) * (13 - r2);
          return e2[12] === ((11 - t2 % 11) % 10).toString();
        }, LK: function(e2) {
          return !(10 !== e2.length || !/^[1-9]\d{8}[vx]$/i.test(e2)) || !(12 !== e2.length || !/^[1-9]\d{11}$/i.test(e2));
        }, "he-IL": function(e2) {
          var t2 = e2.trim();
          if (!/^\d{9}$/.test(t2))
            return false;
          for (var r2, i2 = t2, n2 = 0, a2 = 0; a2 < i2.length; a2++)
            n2 += 9 < (r2 = Number(i2[a2]) * (a2 % 2 + 1)) ? r2 - 9 : r2;
          return n2 % 10 == 0;
        }, "ar-LY": function(e2) {
          var t2 = e2.trim();
          return !!/^(1|2)\d{11}$/.test(t2);
        }, "ar-TN": function(e2) {
          var t2 = e2.trim();
          return !!/^\d{8}$/.test(t2);
        }, "zh-CN": function(e2) {
          var t2, r2 = ["11", "12", "13", "14", "15", "21", "22", "23", "31", "32", "33", "34", "35", "36", "37", "41", "42", "43", "44", "45", "46", "50", "51", "52", "53", "54", "61", "62", "63", "64", "65", "71", "81", "82", "91"], n2 = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"], a2 = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"], o2 = function(e3) {
            return r2.includes(e3);
          }, s = function(e3) {
            var t3 = parseInt(e3.substring(0, 4), 10), r3 = parseInt(e3.substring(4, 6), 10), i2 = parseInt(e3.substring(6), 10), n3 = new Date(t3, r3 - 1, i2);
            return !(n3 > /* @__PURE__ */ new Date()) && (n3.getFullYear() === t3 && n3.getMonth() === r3 - 1 && n3.getDate() === i2);
          }, l = function(e3) {
            return function(e4) {
              for (var t3 = e4.substring(0, 17), r3 = 0, i2 = 0; i2 < 17; i2++)
                r3 += parseInt(t3.charAt(i2), 10) * parseInt(n2[i2], 10);
              return a2[r3 % 11];
            }(e3) === e3.charAt(17).toUpperCase();
          };
          return !!/^\d{15}|(\d{17}(\d|x|X))$/.test(t2 = e2) && (15 === t2.length ? function(e3) {
            var t3 = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(e3);
            if (!t3)
              return false;
            var r3 = e3.substring(0, 2);
            if (!(t3 = o2(r3)))
              return false;
            var i2 = "19".concat(e3.substring(6, 12));
            return !!(t3 = s(i2));
          }(t2) : function(e3) {
            var t3 = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(e3);
            if (!t3)
              return false;
            var r3 = e3.substring(0, 2);
            if (!(t3 = o2(r3)))
              return false;
            var i2 = e3.substring(6, 14);
            return !!(t3 = s(i2)) && l(e3);
          }(t2));
        }, "zh-TW": function(e2) {
          var n2 = { A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, G: 16, H: 17, I: 34, J: 18, K: 19, L: 20, M: 21, N: 22, O: 35, P: 23, Q: 24, R: 25, S: 26, T: 27, U: 28, V: 29, W: 32, X: 30, Y: 31, Z: 33 }, t2 = e2.trim().toUpperCase();
          return !!/^[A-Z][0-9]{9}$/.test(t2) && Array.from(t2).reduce(function(e3, t3, r2) {
            if (0 !== r2)
              return 9 === r2 ? (10 - e3 % 10 - Number(t3)) % 10 == 0 : e3 + Number(t3) * (9 - r2);
            var i2 = n2[t3];
            return i2 % 10 * 9 + Math.floor(i2 / 10);
          }, 0);
        } };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isInt": 54, "./util/assertString": 99 }], 53: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          var r2;
          {
            if ((0, n.default)(e2), "[object Array]" === Object.prototype.toString.call(t2)) {
              var i2 = [];
              for (r2 in t2)
                ({}).hasOwnProperty.call(t2, r2) && (i2[r2] = (0, a.default)(t2[r2]));
              return 0 <= i2.indexOf(e2);
            }
            if ("object" === o(t2))
              return t2.hasOwnProperty(e2);
            if (t2 && "function" == typeof t2.indexOf)
              return 0 <= t2.indexOf(e2);
          }
          return false;
        };
        var n = i(e("./util/assertString")), a = i(e("./util/toString"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function o(e2) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/toString": 103 }], 54: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, s.default)(e2);
          var r2 = (t2 = t2 || {}).hasOwnProperty("allow_leading_zeroes") && !t2.allow_leading_zeroes ? l : u, i2 = !t2.hasOwnProperty("min") || e2 >= t2.min, n = !t2.hasOwnProperty("max") || e2 <= t2.max, a = !t2.hasOwnProperty("lt") || e2 < t2.lt, o = !t2.hasOwnProperty("gt") || e2 > t2.gt;
          return r2.test(e2) && i2 && n && a && o;
        };
        var i, s = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var l = /^(?:[-+]?(?:0|[1-9][0-9]*))$/, u = /^[-+]?[0-9]+$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 55: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2);
          try {
            t2 = (0, a.default)(t2, s);
            var r2 = [];
            t2.allow_primitives && (r2 = [null, false, true]);
            var i2 = JSON.parse(e2);
            return r2.includes(i2) || !!i2 && "object" === o(i2);
          } catch (e3) {
          }
          return false;
        };
        var n = i(e("./util/assertString")), a = i(e("./util/merge"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function o(e2) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        var s = { allow_primitives: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 56: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          (0, i.default)(e2);
          var t2 = e2.split("."), r2 = t2.length;
          if (3 < r2 || r2 < 2)
            return false;
          return t2.reduce(function(e3, t3) {
            return e3 && (0, n.default)(t3, { urlSafe: true });
          }, true);
        };
        var i = a(e("./util/assertString")), n = a(e("./isBase64"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isBase64": 17, "./util/assertString": 99 }], 57: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, i.default)(e2), t2 = (0, n.default)(t2, d), !e2.includes(","))
            return false;
          var r2 = e2.split(",");
          if (r2[0].startsWith("(") && !r2[1].endsWith(")") || r2[1].endsWith(")") && !r2[0].startsWith("("))
            return false;
          if (t2.checkDMS)
            return l.test(r2[0]) && u.test(r2[1]);
          return o.test(r2[0]) && s.test(r2[1]);
        };
        var i = a(e("./util/assertString")), n = a(e("./util/merge"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/, s = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/, l = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i, u = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i, d = { checkDMS: false };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 58: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          var r2, i2;
          (0, o.default)(e2), i2 = "object" === s(t2) ? (r2 = t2.min || 0, t2.max) : (r2 = arguments[1] || 0, arguments[2]);
          var n = e2.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [], a = e2.length - n.length;
          return r2 <= a && (void 0 === i2 || a <= i2);
        };
        var i, o = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        function s(e2) {
          return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 59: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          {
            if ((0, n.default)(e2), t2 in a)
              return a[t2](e2);
            if ("any" === t2) {
              for (var r2 in a) {
                var i2 = a[r2];
                if (i2(e2))
                  return true;
              }
              return false;
            }
          }
          throw new Error("Invalid locale '".concat(t2, "'"));
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { "cs-CZ": function(e2) {
          return /^(([ABCDEFHKIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(e2);
        }, "de-DE": function(e2) {
          return /^((AW|UL|AK|GA|AÖ|LF|AZ|AM|AS|ZE|AN|AB|A|KG|KH|BA|EW|BZ|HY|KM|BT|HP|B|BC|BI|BO|FN|TT|ÜB|BN|AH|BS|FR|HB|ZZ|BB|BK|BÖ|OC|OK|CW|CE|C|CO|LH|CB|KW|LC|LN|DA|DI|DE|DH|SY|NÖ|DO|DD|DU|DN|D|EI|EA|EE|FI|EM|EL|EN|PF|ED|EF|ER|AU|ZP|E|ES|NT|EU|FL|FO|FT|FF|F|FS|FD|FÜ|GE|G|GI|GF|GS|ZR|GG|GP|GR|NY|ZI|GÖ|GZ|GT|HA|HH|HM|HU|WL|HZ|WR|RN|HK|HD|HN|HS|GK|HE|HF|RZ|HI|HG|HO|HX|IK|IL|IN|J|JL|KL|KA|KS|KF|KE|KI|KT|KO|KN|KR|KC|KU|K|LD|LL|LA|L|OP|LM|LI|LB|LU|LÖ|HL|LG|MD|GN|MZ|MA|ML|MR|MY|AT|DM|MC|NZ|RM|RG|MM|ME|MB|MI|FG|DL|HC|MW|RL|MK|MG|MÜ|WS|MH|M|MS|NU|NB|ND|NM|NK|NW|NR|NI|NF|DZ|EB|OZ|TG|TO|N|OA|GM|OB|CA|EH|FW|OF|OL|OE|OG|BH|LR|OS|AA|GD|OH|KY|NP|WK|PB|PA|PE|PI|PS|P|PM|PR|RA|RV|RE|R|H|SB|WN|RS|RD|RT|BM|NE|GV|RP|SU|GL|RO|GÜ|RH|EG|RW|PN|SK|MQ|RU|SZ|RI|SL|SM|SC|HR|FZ|VS|SW|SN|CR|SE|SI|SO|LP|SG|NH|SP|IZ|ST|BF|TE|HV|OD|SR|S|AC|DW|ZW|TF|TS|TR|TÜ|UM|PZ|TP|UE|UN|UH|MN|KK|VB|V|AE|PL|RC|VG|GW|PW|VR|VK|KB|WA|WT|BE|WM|WE|AP|MO|WW|FB|WZ|WI|WB|JE|WF|WO|W|WÜ|BL|Z|GC)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(AIC|FDB|ABG|SLN|SAW|KLZ|BUL|ESB|NAB|SUL|WST|ABI|AZE|BTF|KÖT|DKB|FEU|ROT|ALZ|SMÜ|WER|AUR|NOR|DÜW|BRK|HAB|TÖL|WOR|BAD|BAR|BER|BIW|EBS|KEM|MÜB|PEG|BGL|BGD|REI|WIL|BKS|BIR|WAT|BOR|BOH|BOT|BRB|BLK|HHM|NEB|NMB|WSF|LEO|HDL|WMS|WZL|BÜS|CHA|KÖZ|ROD|WÜM|CLP|NEC|COC|ZEL|COE|CUX|DAH|LDS|DEG|DEL|RSL|DLG|DGF|LAN|HEI|MED|DON|KIB|ROK|JÜL|MON|SLE|EBE|EIC|HIG|WBS|BIT|PRÜ|LIB|EMD|WIT|ERH|HÖS|ERZ|ANA|ASZ|MAB|MEK|STL|SZB|FDS|HCH|HOR|WOL|FRG|GRA|WOS|FRI|FFB|GAP|GER|BRL|CLZ|GTH|NOH|HGW|GRZ|LÖB|NOL|WSW|DUD|HMÜ|OHA|KRU|HAL|HAM|HBS|QLB|HVL|NAU|HAS|EBN|GEO|HOH|HDH|ERK|HER|WAN|HEF|ROF|HBN|ALF|HSK|USI|NAI|REH|SAN|KÜN|ÖHR|HOL|WAR|ARN|BRG|GNT|HOG|WOH|KEH|MAI|PAR|RID|ROL|KLE|GEL|KUS|KYF|ART|SDH|LDK|DIL|MAL|VIB|LER|BNA|GHA|GRM|MTL|WUR|LEV|LIF|STE|WEL|LIP|VAI|LUP|HGN|LBZ|LWL|PCH|STB|DAN|MKK|SLÜ|MSP|TBB|MGH|MTK|BIN|MSH|EIL|HET|SGH|BID|MYK|MSE|MST|MÜR|WRN|MEI|GRH|RIE|MZG|MIL|OBB|BED|FLÖ|MOL|FRW|SEE|SRB|AIB|MOS|BCH|ILL|SOB|NMS|NEA|SEF|UFF|NEW|VOH|NDH|TDO|NWM|GDB|GVM|WIS|NOM|EIN|GAN|LAU|HEB|OHV|OSL|SFB|ERB|LOS|BSK|KEL|BSB|MEL|WTL|OAL|FÜS|MOD|OHZ|OPR|BÜR|PAF|PLÖ|CAS|GLA|REG|VIT|ECK|SIM|GOA|EMS|DIZ|GOH|RÜD|SWA|NES|KÖN|MET|LRO|BÜZ|DBR|ROS|TET|HRO|ROW|BRV|HIP|PAN|GRI|SHK|EIS|SRO|SOK|LBS|SCZ|MER|QFT|SLF|SLS|HOM|SLK|ASL|BBG|SBK|SFT|SHG|MGN|MEG|ZIG|SAD|NEN|OVI|SHA|BLB|SIG|SON|SPN|FOR|GUB|SPB|IGB|WND|STD|STA|SDL|OBG|HST|BOG|SHL|PIR|FTL|SEB|SÖM|SÜW|TIR|SAB|TUT|ANG|SDT|LÜN|LSZ|MHL|VEC|VER|VIE|OVL|ANK|OVP|SBG|UEM|UER|WLG|GMN|NVP|RDG|RÜG|DAU|FKB|WAF|WAK|SLZ|WEN|SOG|APD|WUG|GUN|ESW|WIZ|WES|DIN|BRA|BÜD|WHV|HWI|GHC|WTM|WOB|WUN|MAK|SEL|OCH|HOT|WDA)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(e2);
        }, "de-LI": function(e2) {
          return /^FL[- ]?\d{1,5}[UZ]?$/.test(e2);
        }, "fi-FI": function(e2) {
          return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(e2);
        }, "pt-PT": function(e2) {
          return /^([A-Z]{2}|[0-9]{2})[ -·]?([A-Z]{2}|[0-9]{2})[ -·]?([A-Z]{2}|[0-9]{2})$/.test(e2);
        }, "sq-AL": function(e2) {
          return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(e2);
        }, "pt-BR": function(e2) {
          return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(e2);
        } };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 60: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), "en_US_POSIX" === e2 || "ca_ES_VALENCIA" === e2 || a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[A-Za-z]{2,4}([_-]([A-Za-z]{4}|[\d]{3}))?([_-]([A-Za-z]{2}|[\d]{3}))?$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 61: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), e2 === e2.toLowerCase();
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 62: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), t2 && (t2.no_colons || t2.no_separators))
            return o.test(e2);
          return a.test(e2) || s.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/, o = /^([0-9a-fA-F]){12}$/, s = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 63: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[a-f0-9]{32}$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 64: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2.trim());
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^magnet:\?xt(?:\.1)?=urn:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?($|&)/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 65: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2) || o.test(e2) || s.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+]{1,100}$/i, o = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i, s = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 66: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(r2, e2, t2) {
          if ((0, a.default)(r2), t2 && t2.strictMode && !r2.startsWith("+"))
            return false;
          {
            if (Array.isArray(e2))
              return e2.some(function(e3) {
                if (o.hasOwnProperty(e3)) {
                  var t3 = o[e3];
                  if (t3.test(r2))
                    return true;
                }
                return false;
              });
            if (e2 in o)
              return o[e2].test(r2);
            if (!e2 || "any" === e2) {
              for (var i2 in o)
                if (o.hasOwnProperty(i2)) {
                  var n2 = o[i2];
                  if (n2.test(r2))
                    return true;
                }
              return false;
            }
          }
          throw new Error("Invalid locale '".concat(e2, "'"));
        }, r.locales = void 0;
        var i, a = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var o = { "am-AM": /^(\+?374|0)((10|[9|7][0-9])\d{6}$|[2-4]\d{7}$)/, "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/, "ar-BH": /^(\+?973)?(3|6)\d{7}$/, "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/, "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/, "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/, "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/, "ar-JO": /^(\+?962|0)?7[789]\d{7}$/, "ar-KW": /^(\+?965)[569]\d{7}$/, "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/, "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/, "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/, "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/, "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/, "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/, "ar-TN": /^(\+?216)?[2459]\d{7}$/, "az-AZ": /^(\+994|0)(5[015]|7[07]|99)\d{7}$/, "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/, "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/, "bg-BG": /^(\+?359|0)?8[789]\d{7}$/, "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/, "ca-AD": /^(\+376)?[346]\d{5}$/, "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/, "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/, "de-DE": /^((\+49|0)[1|3])([0|5][0-45-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/, "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/, "de-CH": /^(\+41|0)([1-9])\d{1,9}$/, "de-LU": /^(\+352)?((6\d1)\d{6})$/, "dv-MV": /^(\+?960)?(7[2-9]|91|9[3-9])\d{7}$/, "el-GR": /^(\+?30|0)?(69\d{8})$/, "en-AU": /^(\+?61|0)4\d{8}$/, "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}))/, "en-GB": /^(\+?44|0)7\d{9}$/, "en-GG": /^(\+?44|0)1481\d{6}$/, "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/, "en-GY": /^(\+592|0)6\d{6}$/, "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/, "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/, "en-IE": /^(\+?353|0)8[356789]\d{7}$/, "en-IN": /^(\+?91|0)?[6789]\d{9}$/, "en-KE": /^(\+?254|0)(7|1)\d{8}$/, "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/, "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/, "en-MU": /^(\+?230|0)?\d{8}$/, "en-NA": /^(\+?264|0)(6|8)\d{7}$/, "en-NG": /^(\+?234|0)?[789]\d{9}$/, "en-NZ": /^(\+?64|0)[28]\d{7,9}$/, "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/, "en-PH": /^(09|\+639)\d{9}$/, "en-RW": /^(\+?250|0)?[7]\d{8}$/, "en-SG": /^(\+65)?[3689]\d{7}$/, "en-SL": /^(\+?232|0)\d{8}$/, "en-TZ": /^(\+?255|0)?[67]\d{8}$/, "en-UG": /^(\+?256|0)?[7]\d{8}$/, "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/, "en-ZA": /^(\+?27|0)\d{9}$/, "en-ZM": /^(\+?26)?09[567]\d{7}$/, "en-ZW": /^(\+263)[0-9]{9}$/, "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/, "es-AR": /^\+?549(11|[2368]\d)\d{8}$/, "es-BO": /^(\+?591)?(6|7)\d{7}$/, "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/, "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/, "es-CR": /^(\+506)?[2-8]\d{7}$/, "es-CU": /^(\+53|0053)?5\d{7}/, "es-DO": /^(\+?1)?8[024]9\d{7}$/, "es-HN": /^(\+?504)?[9|8]\d{7}$/, "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/, "es-ES": /^(\+?34)?[6|7]\d{8}$/, "es-PE": /^(\+?51)?9\d{8}$/, "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/, "es-PA": /^(\+?507)\d{7,8}$/, "es-PY": /^(\+?595|0)9[9876]\d{7}$/, "es-SV": /^(\+?503)?[67]\d{7}$/, "es-UY": /^(\+598|0)9[1-9][\d]{6}$/, "es-VE": /^(\+?58)?(2|4)\d{9}$/, "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/, "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/, "fi-FI": /^(\+?358|0)\s?(4(0|1|2|4|5|6)?|50)\s?(\d\s?){4,8}\d$/, "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/, "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/, "fr-BF": /^(\+226|0)[67]\d{7}$/, "fr-CM": /^(\+?237)6[0-9]{8}$/, "fr-FR": /^(\+?33|0)[67]\d{8}$/, "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/, "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/, "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/, "fr-PF": /^(\+?689)?8[789]\d{6}$/, "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/, "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/, "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/, "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/, "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/, "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/, "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/, "ka-GE": /^(\+?995)?(5|79)\d{7}$/, "kk-KZ": /^(\+?7|8)?7\d{9}$/, "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/, "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/, "lt-LT": /^(\+370|8)\d{8}$/, "lv-LV": /^(\+?371)2\d{7}$/, "ms-MY": /^(\+?6?01){1}(([0145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/, "mz-MZ": /^(\+?258)?8[234567]\d{7}$/, "nb-NO": /^(\+?47)?[49]\d{7}$/, "ne-NP": /^(\+?977)?9[78]\d{8}$/, "nl-BE": /^(\+?32|0)4\d{8}$/, "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/, "nn-NO": /^(\+?47)?[49]\d{7}$/, "pl-PL": /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/, "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[2-9]{1}\d{3}\-?\d{4}))$/, "pt-PT": /^(\+?351)?9[1236]\d{7}$/, "pt-AO": /^(\+244)\d{9}$/, "ro-RO": /^(\+?4?0)\s?7\d{2}(\/|\s|\.|\-)?\d{3}(\s|\.|\-)?\d{3}$/, "ru-RU": /^(\+?7|8)?9\d{9}$/, "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/, "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/, "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/, "sq-AL": /^(\+355|0)6[789]\d{6}$/, "sr-RS": /^(\+3816|06)[- \d]{5,9}$/, "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/, "tg-TJ": /^(\+?992)?[5][5]\d{7}$/, "th-TH": /^(\+66|66|0)\d{9}$/, "tr-TR": /^(\+?90|0)?5\d{9}$/, "tk-TM": /^(\+993|993|8)\d{8}$/, "uk-UA": /^(\+?38|8)?0\d{9}$/, "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/, "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/, "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/, "zh-TW": /^(\+?886\-?|0)?9\d{8}$/, "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/ };
        o["en-CA"] = o["en-US"], o["fr-CA"] = o["en-CA"], o["fr-BE"] = o["nl-BE"], o["zh-HK"] = o["en-HK"], o["zh-MO"] = o["en-MO"], o["ga-IE"] = o["en-IE"], o["fr-CH"] = o["de-CH"], o["it-CH"] = o["fr-CH"];
        var n = Object.keys(o);
        r.locales = n;
      }, { "./util/assertString": 99 }], 67: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, i.default)(e2), (0, n.default)(e2) && 24 === e2.length;
        };
        var i = a(e("./util/assertString")), n = a(e("./isHexadecimal"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isHexadecimal": 39, "./util/assertString": 99 }], 68: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /[^\x00-\x7F]/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 69: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), t2 && t2.no_symbols)
            return o.test(e2);
          return new RegExp("^[+-]?([0-9]*[".concat((t2 || {}).locale ? a.decimal[t2.locale] : ".", "])?[0-9]+$")).test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, a = e("./alpha");
        var o = /^[0-9]+$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./alpha": 5, "./util/assertString": 99 }], 70: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^(0o)?[0-7]+$/i;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 71: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2);
          var r2 = e2.replace(/\s/g, "").toUpperCase();
          return t2.toUpperCase() in a && a[t2].test(r2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { AM: /^[A-Z]{2}\d{7}$/, AR: /^[A-Z]{3}\d{6}$/, AT: /^[A-Z]\d{7}$/, AU: /^[A-Z]\d{7}$/, BE: /^[A-Z]{2}\d{6}$/, BG: /^\d{9}$/, BR: /^[A-Z]{2}\d{6}$/, BY: /^[A-Z]{2}\d{7}$/, CA: /^[A-Z]{2}\d{6}$/, CH: /^[A-Z]\d{7}$/, CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/, CY: /^[A-Z](\d{6}|\d{8})$/, CZ: /^\d{8}$/, DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/, DK: /^\d{9}$/, DZ: /^\d{9}$/, EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/, ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/, FI: /^[A-Z]{2}\d{7}$/, FR: /^\d{2}[A-Z]{2}\d{5}$/, GB: /^\d{9}$/, GR: /^[A-Z]{2}\d{7}$/, HR: /^\d{9}$/, HU: /^[A-Z]{2}(\d{6}|\d{7})$/, IE: /^[A-Z0-9]{2}\d{7}$/, IN: /^[A-Z]{1}-?\d{7}$/, ID: /^[A-C]\d{7}$/, IR: /^[A-Z]\d{8}$/, IS: /^(A)\d{7}$/, IT: /^[A-Z0-9]{2}\d{7}$/, JP: /^[A-Z]{2}\d{7}$/, KR: /^[MS]\d{8}$/, LT: /^[A-Z0-9]{8}$/, LU: /^[A-Z0-9]{8}$/, LV: /^[A-Z0-9]{2}\d{7}$/, LY: /^[A-Z0-9]{8}$/, MT: /^\d{7}$/, MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/, MY: /^[AHK]\d{8}$/, NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/, PL: /^[A-Z]{2}\d{7}$/, PT: /^[A-Z]\d{6}$/, RO: /^\d{8,9}$/, RU: /^\d{9}$/, SE: /^\d{8}$/, SL: /^(P)[A-Z]\d{7}$/, SK: /^[0-9A-Z]\d{7}$/, TR: /^[A-Z]\d{8}$/, UA: /^[A-Z]{2}\d{6}$/, US: /^\d{9}$/ };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 72: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2, { min: 0, max: 65535 });
        };
        var i, n = (i = e("./isInt")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isInt": 54 }], 73: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          {
            if ((0, n.default)(e2), t2 in l)
              return l[t2].test(e2);
            if ("any" === t2) {
              for (var r2 in l)
                if (l.hasOwnProperty(r2)) {
                  var i2 = l[r2];
                  if (i2.test(e2))
                    return true;
                }
              return false;
            }
          }
          throw new Error("Invalid locale '".concat(t2, "'"));
        }, r.locales = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^\d{4}$/, o = /^\d{5}$/, s = /^\d{6}$/, l = { AD: /^AD\d{3}$/, AT: a, AU: a, AZ: /^AZ\d{4}$/, BE: a, BG: a, BR: /^\d{5}-\d{3}$/, BY: /2[1-4]{1}\d{4}$/, CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i, CH: a, CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/, CZ: /^\d{3}\s?\d{2}$/, DE: o, DK: a, DO: o, DZ: o, EE: o, ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/, FI: o, FR: /^\d{2}\s?\d{3}$/, GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i, GR: /^\d{3}\s?\d{2}$/, HR: /^([1-5]\d{4}$)/, HT: /^HT\d{4}$/, HU: a, ID: o, IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i, IL: /^(\d{5}|\d{7})$/, IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/, IR: /\b(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}\b/, IS: /^\d{3}$/, IT: o, JP: /^\d{3}\-\d{4}$/, KE: o, KR: /^(\d{5}|\d{6})$/, LI: /^(948[5-9]|949[0-7])$/, LT: /^LT\-\d{5}$/, LU: a, LV: /^LV\-\d{4}$/, LK: o, MX: o, MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/, MY: o, NL: /^\d{4}\s?[a-z]{2}$/i, NO: a, NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i, NZ: a, PL: /^\d{2}\-\d{3}$/, PR: /^00[679]\d{2}([ -]\d{4})?$/, PT: /^\d{4}\-\d{3}?$/, RO: s, RU: s, SA: o, SE: /^[1-9]\d{2}\s?\d{2}$/, SG: s, SI: a, SK: /^\d{3}\s?\d{2}$/, TH: o, TN: a, TW: /^\d{3}(\d{2})?$/, UA: o, US: /^\d{5}(-\d{4})?$/, ZA: a, ZM: o }, u = Object.keys(l);
        r.locales = u;
      }, { "./util/assertString": 99 }], 74: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), c.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /([01][0-9]|2[0-3])/, o = /[0-5][0-9]/, s = new RegExp("[-+]".concat(a.source, ":").concat(o.source)), l = new RegExp("([zZ]|".concat(s.source, ")")), u = new RegExp("".concat(a.source, ":").concat(o.source, ":").concat(/([0-5][0-9]|60)/.source).concat(/(\.[0-9]+)?/.source)), d = new RegExp("".concat(/[0-9]{4}/.source, "-").concat(/(0[1-9]|1[0-2])/.source, "-").concat(/([12]\d|0[1-9]|3[01])/.source)), f = new RegExp("".concat(u.source).concat(l.source)), c = new RegExp("^".concat(d.source, "[ tT]").concat(f.source, "$"));
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 75: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1];
          return (0, n.default)(e2), t2 ? a.test(e2) || o.test(e2) || s.test(e2) || l.test(e2) : a.test(e2) || o.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/, o = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/, s = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)/, l = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 76: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, i.default)(e2), a.test(e2);
        };
        var i = n(e("./util/assertString"));
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var a = (0, n(e("./util/multilineRegex")).default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/multilineRegex": 102 }], 77: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 78: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null;
          (0, u.default)(e2);
          var r2 = (i2 = e2, o = i2, s = {}, Array.from(o).forEach(function(e3) {
            s[e3] ? s[e3] += 1 : s[e3] = 1;
          }), n = s, a = { length: i2.length, uniqueChars: Object.keys(n).length, uppercaseCount: 0, lowercaseCount: 0, numberCount: 0, symbolCount: 0 }, Object.keys(n).forEach(function(e3) {
            d.test(e3) ? a.uppercaseCount += n[e3] : f.test(e3) ? a.lowercaseCount += n[e3] : c.test(e3) ? a.numberCount += n[e3] : p.test(e3) && (a.symbolCount += n[e3]);
          }), a);
          var i2, n, a, o, s;
          if ((t2 = (0, l.default)(t2 || {}, h)).returnScore)
            return function(e3, t3) {
              var r3 = 0;
              r3 += e3.uniqueChars * t3.pointsPerUnique, r3 += (e3.length - e3.uniqueChars) * t3.pointsPerRepeat, 0 < e3.lowercaseCount && (r3 += t3.pointsForContainingLower);
              0 < e3.uppercaseCount && (r3 += t3.pointsForContainingUpper);
              0 < e3.numberCount && (r3 += t3.pointsForContainingNumber);
              0 < e3.symbolCount && (r3 += t3.pointsForContainingSymbol);
              return r3;
            }(r2, t2);
          return r2.length >= t2.minLength && r2.lowercaseCount >= t2.minLowercase && r2.uppercaseCount >= t2.minUppercase && r2.numberCount >= t2.minNumbers && r2.symbolCount >= t2.minSymbols;
        };
        var l = i(e("./util/merge")), u = i(e("./util/assertString"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var d = /^[A-Z]$/, f = /^[a-z]$/, c = /^[0-9]$/, p = /^[-#!$@%^&*()_+|~=`{}\[\]:";'<>?,.\/ ]$/, h = { minLength: 8, minLowercase: 1, minUppercase: 1, minNumbers: 1, minSymbols: 1, returnScore: false, pointsPerUnique: 1, pointsPerRepeat: 0.5, pointsForContainingLower: 10, pointsForContainingUpper: 10, pointsForContainingNumber: 10, pointsForContainingSymbol: 10 };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99, "./util/merge": 101 }], 79: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 80: [function(e, t, r) {
        "use strict";
        function o(e2) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "en-US";
          (0, i.default)(e2);
          var r2 = e2.slice(0);
          if (t2 in f)
            return t2 in h && (r2 = r2.replace(h[t2], "")), !!f[t2].test(r2) && (!(t2 in c) || c[t2](r2));
          throw new Error("Invalid locale '".concat(t2, "'"));
        };
        var i = n(e("./util/assertString")), l = function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          if (null === e2 || "object" !== o(e2) && "function" != typeof e2)
            return { default: e2 };
          var t2 = s();
          if (t2 && t2.has(e2))
            return t2.get(e2);
          var r2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var n2 in e2)
            if (Object.prototype.hasOwnProperty.call(e2, n2)) {
              var a2 = i2 ? Object.getOwnPropertyDescriptor(e2, n2) : null;
              a2 && (a2.get || a2.set) ? Object.defineProperty(r2, n2, a2) : r2[n2] = e2[n2];
            }
          r2.default = e2, t2 && t2.set(e2, r2);
          return r2;
        }(e("./util/algorithms")), v = n(e("./isDate"));
        function s() {
          if ("function" != typeof WeakMap)
            return null;
          var e2 = /* @__PURE__ */ new WeakMap();
          return s = function() {
            return e2;
          }, e2;
        }
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function a(e2) {
          return function(e3) {
            if (Array.isArray(e3))
              return u(e3);
          }(e2) || function(e3) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3))
              return Array.from(e3);
          }(e2) || function(e3, t2) {
            if (!e3)
              return;
            if ("string" == typeof e3)
              return u(e3, t2);
            var r2 = Object.prototype.toString.call(e3).slice(8, -1);
            "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
            if ("Map" === r2 || "Set" === r2)
              return Array.from(e3);
            if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
              return u(e3, t2);
          }(e2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function u(e2, t2) {
          (null == t2 || t2 > e2.length) && (t2 = e2.length);
          for (var r2 = 0, i2 = new Array(t2); r2 < t2; r2++)
            i2[r2] = e2[r2];
          return i2;
        }
        var d = { andover: ["10", "12"], atlanta: ["60", "67"], austin: ["50", "53"], brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"], cincinnati: ["30", "32", "35", "36", "37", "38", "61"], fresno: ["15", "24"], internet: ["20", "26", "27", "45", "46", "47"], kansas: ["40", "44"], memphis: ["94", "95"], ogden: ["80", "90"], philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"], sba: ["31"] };
        function _(e2) {
          for (var t2 = false, r2 = false, i2 = 0; i2 < 3; i2++)
            if (!t2 && /[AEIOU]/.test(e2[i2]))
              t2 = true;
            else if (!r2 && t2 && "X" === e2[i2])
              r2 = true;
            else if (0 < i2) {
              if (t2 && !r2 && !/[AEIOU]/.test(e2[i2]))
                return false;
              if (r2 && !/X/.test(e2[i2]))
                return false;
            }
          return true;
        }
        var f = { "bg-BG": /^\d{10}$/, "cs-CZ": /^\d{6}\/{0,1}\d{3,4}$/, "de-AT": /^\d{9}$/, "de-DE": /^[1-9]\d{10}$/, "dk-DK": /^\d{6}-{0,1}\d{4}$/, "el-CY": /^[09]\d{7}[A-Z]$/, "el-GR": /^([0-4]|[7-9])\d{8}$/, "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i, "en-IE": /^\d{7}[A-W][A-IW]{0,1}$/i, "en-US": /^\d{2}[- ]{0,1}\d{7}$/, "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i, "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/, "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i, "fr-BE": /^\d{11}$/, "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/, "fr-LU": /^\d{13}$/, "hr-HR": /^\d{11}$/, "hu-HU": /^8\d{9}$/, "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i, "lv-LV": /^\d{6}-{0,1}\d{5}$/, "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i, "nl-NL": /^\d{9}$/, "pl-PL": /^\d{10,11}$/, "pt-BR": /(?:^\d{11}$)|(?:^\d{14}$)/, "pt-PT": /^\d{9}$/, "ro-RO": /^\d{13}$/, "sk-SK": /^\d{6}\/{0,1}\d{3,4}$/, "sl-SI": /^[1-9]\d{7}$/, "sv-SE": /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/ };
        f["lb-LU"] = f["fr-LU"], f["lt-LT"] = f["et-EE"], f["nl-BE"] = f["fr-BE"];
        var c = { "bg-BG": function(e2) {
          var t2 = e2.slice(0, 2), r2 = parseInt(e2.slice(2, 4), 10);
          t2 = 40 < r2 ? (r2 -= 40, "20".concat(t2)) : 20 < r2 ? (r2 -= 20, "18".concat(t2)) : "19".concat(t2), r2 < 10 && (r2 = "0".concat(r2));
          var i2 = "".concat(t2, "/").concat(r2, "/").concat(e2.slice(4, 6));
          if (!(0, v.default)(i2, "YYYY/MM/DD"))
            return false;
          for (var n2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), a2 = [2, 4, 8, 5, 10, 9, 7, 3, 6], o2 = 0, s2 = 0; s2 < a2.length; s2++)
            o2 += n2[s2] * a2[s2];
          return (o2 = o2 % 11 == 10 ? 0 : o2 % 11) === n2[9];
        }, "cs-CZ": function(e2) {
          e2 = e2.replace(/\W/, "");
          var t2 = parseInt(e2.slice(0, 2), 10);
          if (10 === e2.length)
            t2 = t2 < 54 ? "20".concat(t2) : "19".concat(t2);
          else {
            if ("000" === e2.slice(6))
              return false;
            if (!(t2 < 54))
              return false;
            t2 = "19".concat(t2);
          }
          3 === t2.length && (t2 = [t2.slice(0, 2), "0", t2.slice(2)].join(""));
          var r2 = parseInt(e2.slice(2, 4), 10);
          if (50 < r2 && (r2 -= 50), 20 < r2) {
            if (parseInt(t2, 10) < 2004)
              return false;
            r2 -= 20;
          }
          r2 < 10 && (r2 = "0".concat(r2));
          var i2 = "".concat(t2, "/").concat(r2, "/").concat(e2.slice(4, 6));
          if (!(0, v.default)(i2, "YYYY/MM/DD"))
            return false;
          if (10 === e2.length && parseInt(e2, 10) % 11 != 0) {
            var n2 = parseInt(e2.slice(0, 9), 10) % 11;
            if (!(parseInt(t2, 10) < 1986 && 10 === n2))
              return false;
            if (0 !== parseInt(e2.slice(9), 10))
              return false;
          }
          return true;
        }, "de-AT": function(e2) {
          return l.luhnCheck(e2);
        }, "de-DE": function(e2) {
          for (var t2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), r2 = [], i2 = 0; i2 < t2.length - 1; i2++) {
            r2.push("");
            for (var n2 = 0; n2 < t2.length - 1; n2++)
              t2[i2] === t2[n2] && (r2[i2] += n2);
          }
          if (2 !== (r2 = r2.filter(function(e3) {
            return 1 < e3.length;
          })).length && 3 !== r2.length)
            return false;
          if (3 === r2[0].length) {
            for (var a2 = r2[0].split("").map(function(e3) {
              return parseInt(e3, 10);
            }), o2 = 0, s2 = 0; s2 < a2.length - 1; s2++)
              a2[s2] + 1 === a2[s2 + 1] && (o2 += 1);
            if (2 === o2)
              return false;
          }
          return l.iso7064Check(e2);
        }, "dk-DK": function(e2) {
          e2 = e2.replace(/\W/, "");
          var t2 = parseInt(e2.slice(4, 6), 10);
          switch (e2.slice(6, 7)) {
            case "0":
            case "1":
            case "2":
            case "3":
              t2 = "19".concat(t2);
              break;
            case "4":
            case "9":
              t2 = t2 < 37 ? "20".concat(t2) : "19".concat(t2);
              break;
            default:
              if (t2 < 37)
                t2 = "20".concat(t2);
              else {
                if (!(58 < t2))
                  return false;
                t2 = "18".concat(t2);
              }
          }
          3 === t2.length && (t2 = [t2.slice(0, 2), "0", t2.slice(2)].join(""));
          var r2 = "".concat(t2, "/").concat(e2.slice(2, 4), "/").concat(e2.slice(0, 2));
          if (!(0, v.default)(r2, "YYYY/MM/DD"))
            return false;
          for (var i2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), n2 = 0, a2 = 4, o2 = 0; o2 < 9; o2++)
            n2 += i2[o2] * a2, 1 == (a2 -= 1) && (a2 = 7);
          return 1 != (n2 %= 11) && (0 === n2 ? 0 === i2[9] : i2[9] === 11 - n2);
        }, "el-CY": function(e2) {
          for (var t2 = e2.slice(0, 8).split("").map(function(e3) {
            return parseInt(e3, 10);
          }), r2 = 0, i2 = 1; i2 < t2.length; i2 += 2)
            r2 += t2[i2];
          for (var n2 = 0; n2 < t2.length; n2 += 2)
            t2[n2] < 2 ? r2 += 1 - t2[n2] : (r2 += 2 * (t2[n2] - 2) + 5, 4 < t2[n2] && (r2 += 2));
          return String.fromCharCode(r2 % 26 + 65) === e2.charAt(8);
        }, "el-GR": function(e2) {
          for (var t2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), r2 = 0, i2 = 0; i2 < 8; i2++)
            r2 += t2[i2] * Math.pow(2, 8 - i2);
          return r2 % 11 % 10 === t2[8];
        }, "en-IE": function(e2) {
          var t2 = l.reverseMultiplyAndSum(e2.split("").slice(0, 7).map(function(e3) {
            return parseInt(e3, 10);
          }), 8);
          return 9 === e2.length && "W" !== e2[8] && (t2 += 9 * (e2[8].charCodeAt(0) - 64)), 0 == (t2 %= 23) ? "W" === e2[7].toUpperCase() : e2[7].toUpperCase() === String.fromCharCode(64 + t2);
        }, "en-US": function(e2) {
          return -1 !== function() {
            var e3 = [];
            for (var t2 in d)
              d.hasOwnProperty(t2) && e3.push.apply(e3, a(d[t2]));
            return e3;
          }().indexOf(e2.substr(0, 2));
        }, "es-ES": function(e2) {
          var t2 = e2.toUpperCase().split("");
          if (isNaN(parseInt(t2[0], 10)) && 1 < t2.length) {
            var r2 = 0;
            switch (t2[0]) {
              case "Y":
                r2 = 1;
                break;
              case "Z":
                r2 = 2;
            }
            t2.splice(0, 1, r2);
          } else
            for (; t2.length < 9; )
              t2.unshift(0);
          t2 = t2.join("");
          var i2 = parseInt(t2.slice(0, 8), 10) % 23;
          return t2[8] === ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"][i2];
        }, "et-EE": function(e2) {
          var t2 = e2.slice(1, 3);
          switch (e2.slice(0, 1)) {
            case "1":
            case "2":
              t2 = "18".concat(t2);
              break;
            case "3":
            case "4":
              t2 = "19".concat(t2);
              break;
            default:
              t2 = "20".concat(t2);
          }
          var r2 = "".concat(t2, "/").concat(e2.slice(3, 5), "/").concat(e2.slice(5, 7));
          if (!(0, v.default)(r2, "YYYY/MM/DD"))
            return false;
          for (var i2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), n2 = 0, a2 = 1, o2 = 0; o2 < 10; o2++)
            n2 += i2[o2] * a2, 10 === (a2 += 1) && (a2 = 1);
          if (n2 % 11 == 10) {
            a2 = 3;
            for (var s2 = n2 = 0; s2 < 10; s2++)
              n2 += i2[s2] * a2, 10 === (a2 += 1) && (a2 = 1);
            if (n2 % 11 == 10)
              return 0 === i2[10];
          }
          return n2 % 11 === i2[10];
        }, "fi-FI": function(e2) {
          var t2 = e2.slice(4, 6);
          switch (e2.slice(6, 7)) {
            case "+":
              t2 = "18".concat(t2);
              break;
            case "-":
              t2 = "19".concat(t2);
              break;
            default:
              t2 = "20".concat(t2);
          }
          var r2 = "".concat(t2, "/").concat(e2.slice(2, 4), "/").concat(e2.slice(0, 2));
          if (!(0, v.default)(r2, "YYYY/MM/DD"))
            return false;
          var i2 = parseInt(e2.slice(0, 6) + e2.slice(7, 10), 10) % 31;
          return i2 < 10 ? i2 === parseInt(e2.slice(10), 10) : ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"][i2 -= 10] === e2.slice(10);
        }, "fr-BE": function(e2) {
          if ("00" !== e2.slice(2, 4) || "00" !== e2.slice(4, 6)) {
            var t2 = "".concat(e2.slice(0, 2), "/").concat(e2.slice(2, 4), "/").concat(e2.slice(4, 6));
            if (!(0, v.default)(t2, "YY/MM/DD"))
              return false;
          }
          var r2 = 97 - parseInt(e2.slice(0, 9), 10) % 97, i2 = parseInt(e2.slice(9, 11), 10);
          return r2 === i2 || (r2 = 97 - parseInt("2".concat(e2.slice(0, 9)), 10) % 97) === i2;
        }, "fr-FR": function(e2) {
          return e2 = e2.replace(/\s/g, ""), parseInt(e2.slice(0, 10), 10) % 511 === parseInt(e2.slice(10, 13), 10);
        }, "fr-LU": function(e2) {
          var t2 = "".concat(e2.slice(0, 4), "/").concat(e2.slice(4, 6), "/").concat(e2.slice(6, 8));
          return !!(0, v.default)(t2, "YYYY/MM/DD") && !!l.luhnCheck(e2.slice(0, 12)) && l.verhoeffCheck("".concat(e2.slice(0, 11)).concat(e2[12]));
        }, "hr-HR": function(e2) {
          return l.iso7064Check(e2);
        }, "hu-HU": function(e2) {
          for (var t2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), r2 = 8, i2 = 1; i2 < 9; i2++)
            r2 += t2[i2] * (i2 + 1);
          return r2 % 11 === t2[9];
        }, "it-IT": function(e2) {
          var t2 = e2.toUpperCase().split("");
          if (!_(t2.slice(0, 3)))
            return false;
          if (!_(t2.slice(3, 6)))
            return false;
          for (var r2 = { L: "0", M: "1", N: "2", P: "3", Q: "4", R: "5", S: "6", T: "7", U: "8", V: "9" }, i2 = 0, n2 = [6, 7, 9, 10, 12, 13, 14]; i2 < n2.length; i2++) {
            var a2 = n2[i2];
            t2[a2] in r2 && t2.splice(a2, 1, r2[t2[a2]]);
          }
          var o2 = { A: "01", B: "02", C: "03", D: "04", E: "05", H: "06", L: "07", M: "08", P: "09", R: "10", S: "11", T: "12" }[t2[8]], s2 = parseInt(t2[9] + t2[10], 10);
          40 < s2 && (s2 -= 40), s2 < 10 && (s2 = "0".concat(s2));
          var l2 = "".concat(t2[6]).concat(t2[7], "/").concat(o2, "/").concat(s2);
          if (!(0, v.default)(l2, "YY/MM/DD"))
            return false;
          for (var u2 = 0, d2 = 1; d2 < t2.length - 1; d2 += 2) {
            var f2 = parseInt(t2[d2], 10);
            isNaN(f2) && (f2 = t2[d2].charCodeAt(0) - 65), u2 += f2;
          }
          for (var c2 = { A: 1, B: 0, C: 5, D: 7, E: 9, F: 13, G: 15, H: 17, I: 19, J: 21, K: 2, L: 4, M: 18, N: 20, O: 11, P: 3, Q: 6, R: 8, S: 12, T: 14, U: 16, V: 10, W: 22, X: 25, Y: 24, Z: 23, 0: 1, 1: 0 }, p2 = 0; p2 < t2.length - 1; p2 += 2) {
            var h2 = 0;
            if (t2[p2] in c2)
              h2 = c2[t2[p2]];
            else {
              var m = parseInt(t2[p2], 10);
              h2 = 2 * m + 1, 4 < m && (h2 += 2);
            }
            u2 += h2;
          }
          return String.fromCharCode(65 + u2 % 26) === t2[15];
        }, "lv-LV": function(e2) {
          var t2 = (e2 = e2.replace(/\W/, "")).slice(0, 2);
          if ("32" === t2)
            return true;
          if ("00" !== e2.slice(2, 4)) {
            var r2 = e2.slice(4, 6);
            switch (e2[6]) {
              case "0":
                r2 = "18".concat(r2);
                break;
              case "1":
                r2 = "19".concat(r2);
                break;
              default:
                r2 = "20".concat(r2);
            }
            var i2 = "".concat(r2, "/").concat(e2.slice(2, 4), "/").concat(t2);
            if (!(0, v.default)(i2, "YYYY/MM/DD"))
              return false;
          }
          for (var n2 = 1101, a2 = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2], o2 = 0; o2 < e2.length - 1; o2++)
            n2 -= parseInt(e2[o2], 10) * a2[o2];
          return parseInt(e2[10], 10) === n2 % 11;
        }, "mt-MT": function(e2) {
          if (9 !== e2.length) {
            for (var t2 = e2.toUpperCase().split(""); t2.length < 8; )
              t2.unshift(0);
            switch (e2[7]) {
              case "A":
              case "P":
                if (0 === parseInt(t2[6], 10))
                  return false;
                break;
              default:
                var r2 = parseInt(t2.join("").slice(0, 5), 10);
                if (32e3 < r2)
                  return false;
                if (r2 === parseInt(t2.join("").slice(5, 7), 10))
                  return false;
            }
          }
          return true;
        }, "nl-NL": function(e2) {
          return l.reverseMultiplyAndSum(e2.split("").slice(0, 8).map(function(e3) {
            return parseInt(e3, 10);
          }), 9) % 11 === parseInt(e2[8], 10);
        }, "pl-PL": function(e2) {
          if (10 === e2.length) {
            for (var t2 = [6, 5, 7, 2, 3, 4, 5, 6, 7], r2 = 0, i2 = 0; i2 < t2.length; i2++)
              r2 += parseInt(e2[i2], 10) * t2[i2];
            return 10 != (r2 %= 11) && r2 === parseInt(e2[9], 10);
          }
          var n2 = e2.slice(0, 2), a2 = parseInt(e2.slice(2, 4), 10);
          80 < a2 ? (n2 = "18".concat(n2), a2 -= 80) : 60 < a2 ? (n2 = "22".concat(n2), a2 -= 60) : 40 < a2 ? (n2 = "21".concat(n2), a2 -= 40) : 20 < a2 ? (n2 = "20".concat(n2), a2 -= 20) : n2 = "19".concat(n2), a2 < 10 && (a2 = "0".concat(a2));
          var o2 = "".concat(n2, "/").concat(a2, "/").concat(e2.slice(4, 6));
          if (!(0, v.default)(o2, "YYYY/MM/DD"))
            return false;
          for (var s2 = 0, l2 = 1, u2 = 0; u2 < e2.length - 1; u2++)
            s2 += parseInt(e2[u2], 10) * l2 % 10, 10 < (l2 += 2) ? l2 = 1 : 5 === l2 && (l2 += 2);
          return (s2 = 10 - s2 % 10) === parseInt(e2[10], 10);
        }, "pt-BR": function(e2) {
          if (11 === e2.length) {
            var t2, r2;
            if (t2 = 0, "11111111111" === e2 || "22222222222" === e2 || "33333333333" === e2 || "44444444444" === e2 || "55555555555" === e2 || "66666666666" === e2 || "77777777777" === e2 || "88888888888" === e2 || "99999999999" === e2 || "00000000000" === e2)
              return false;
            for (var i2 = 1; i2 <= 9; i2++)
              t2 += parseInt(e2.substring(i2 - 1, i2), 10) * (11 - i2);
            if (10 == (r2 = 10 * t2 % 11) && (r2 = 0), r2 !== parseInt(e2.substring(9, 10), 10))
              return false;
            t2 = 0;
            for (var n2 = 1; n2 <= 10; n2++)
              t2 += parseInt(e2.substring(n2 - 1, n2), 10) * (12 - n2);
            return 10 == (r2 = 10 * t2 % 11) && (r2 = 0), r2 === parseInt(e2.substring(10, 11), 10);
          }
          if ("00000000000000" === e2 || "11111111111111" === e2 || "22222222222222" === e2 || "33333333333333" === e2 || "44444444444444" === e2 || "55555555555555" === e2 || "66666666666666" === e2 || "77777777777777" === e2 || "88888888888888" === e2 || "99999999999999" === e2)
            return false;
          for (var a2 = e2.length - 2, o2 = e2.substring(0, a2), s2 = e2.substring(a2), l2 = 0, u2 = a2 - 7, d2 = a2; 1 <= d2; d2--)
            l2 += o2.charAt(a2 - d2) * u2, (u2 -= 1) < 2 && (u2 = 9);
          var f2 = l2 % 11 < 2 ? 0 : 11 - l2 % 11;
          if (f2 !== parseInt(s2.charAt(0), 10))
            return false;
          a2 += 1, o2 = e2.substring(0, a2), l2 = 0, u2 = a2 - 7;
          for (var c2 = a2; 1 <= c2; c2--)
            l2 += o2.charAt(a2 - c2) * u2, (u2 -= 1) < 2 && (u2 = 9);
          return (f2 = l2 % 11 < 2 ? 0 : 11 - l2 % 11) === parseInt(s2.charAt(1), 10);
        }, "pt-PT": function(e2) {
          var t2 = 11 - l.reverseMultiplyAndSum(e2.split("").slice(0, 8).map(function(e3) {
            return parseInt(e3, 10);
          }), 9) % 11;
          return 9 < t2 ? 0 === parseInt(e2[8], 10) : t2 === parseInt(e2[8], 10);
        }, "ro-RO": function(e2) {
          if ("9000" === e2.slice(0, 4))
            return true;
          var t2 = e2.slice(1, 3);
          switch (e2[0]) {
            case "1":
            case "2":
              t2 = "19".concat(t2);
              break;
            case "3":
            case "4":
              t2 = "18".concat(t2);
              break;
            case "5":
            case "6":
              t2 = "20".concat(t2);
          }
          var r2 = "".concat(t2, "/").concat(e2.slice(3, 5), "/").concat(e2.slice(5, 7));
          if (8 === r2.length) {
            if (!(0, v.default)(r2, "YY/MM/DD"))
              return false;
          } else if (!(0, v.default)(r2, "YYYY/MM/DD"))
            return false;
          for (var i2 = e2.split("").map(function(e3) {
            return parseInt(e3, 10);
          }), n2 = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9], a2 = 0, o2 = 0; o2 < n2.length; o2++)
            a2 += i2[o2] * n2[o2];
          return a2 % 11 == 10 ? 1 === i2[12] : i2[12] === a2 % 11;
        }, "sk-SK": function(e2) {
          if (9 === e2.length) {
            if ("000" === (e2 = e2.replace(/\W/, "")).slice(6))
              return false;
            var t2 = parseInt(e2.slice(0, 2), 10);
            if (53 < t2)
              return false;
            t2 = t2 < 10 ? "190".concat(t2) : "19".concat(t2);
            var r2 = parseInt(e2.slice(2, 4), 10);
            50 < r2 && (r2 -= 50), r2 < 10 && (r2 = "0".concat(r2));
            var i2 = "".concat(t2, "/").concat(r2, "/").concat(e2.slice(4, 6));
            if (!(0, v.default)(i2, "YYYY/MM/DD"))
              return false;
          }
          return true;
        }, "sl-SI": function(e2) {
          var t2 = 11 - l.reverseMultiplyAndSum(e2.split("").slice(0, 7).map(function(e3) {
            return parseInt(e3, 10);
          }), 8) % 11;
          return 10 === t2 ? 0 === parseInt(e2[7], 10) : t2 === parseInt(e2[7], 10);
        }, "sv-SE": function(e2) {
          var t2 = e2.slice(0);
          11 < e2.length && (t2 = t2.slice(2));
          var r2 = "", i2 = t2.slice(2, 4), n2 = parseInt(t2.slice(4, 6), 10);
          if (11 < e2.length)
            r2 = e2.slice(0, 4);
          else if (r2 = e2.slice(0, 2), 11 === e2.length && n2 < 60) {
            var a2 = (/* @__PURE__ */ new Date()).getFullYear().toString(), o2 = parseInt(a2.slice(0, 2), 10);
            if (a2 = parseInt(a2, 10), "-" === e2[6])
              r2 = parseInt("".concat(o2).concat(r2), 10) > a2 ? "".concat(o2 - 1).concat(r2) : "".concat(o2).concat(r2);
            else if (r2 = "".concat(o2 - 1).concat(r2), a2 - parseInt(r2, 10) < 100)
              return false;
          }
          60 < n2 && (n2 -= 60), n2 < 10 && (n2 = "0".concat(n2));
          var s2 = "".concat(r2, "/").concat(i2, "/").concat(n2);
          if (8 === s2.length) {
            if (!(0, v.default)(s2, "YY/MM/DD"))
              return false;
          } else if (!(0, v.default)(s2, "YYYY/MM/DD"))
            return false;
          return l.luhnCheck(e2.replace(/\W/, ""));
        } };
        c["lb-LU"] = c["fr-LU"], c["lt-LT"] = c["et-EE"], c["nl-BE"] = c["fr-BE"];
        var p = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g, h = { "de-AT": p, "de-DE": /[\/\\]/g, "fr-BE": p };
        h["nl-BE"] = h["fr-BE"], t.exports = r.default, t.exports.default = r.default;
      }, { "./isDate": 25, "./util/algorithms": 98, "./util/assertString": 99 }], 81: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, _.default)(e2), !e2 || /[\s<>]/.test(e2))
            return false;
          if (0 === e2.indexOf("mailto:"))
            return false;
          if ((t2 = (0, E.default)(t2, S)).validate_length && 2083 <= e2.length)
            return false;
          if (!t2.allow_fragments && e2.includes("#"))
            return false;
          if (!t2.allow_query_components && (e2.includes("?") || e2.includes("&")))
            return false;
          var r2, i2, n, a, o, s, l, u;
          if (1 < (l = (e2 = (l = (e2 = (l = e2.split("#")).shift()).split("?")).shift()).split("://")).length) {
            if (r2 = l.shift().toLowerCase(), t2.require_valid_protocol && -1 === t2.protocols.indexOf(r2))
              return false;
          } else {
            if (t2.require_protocol)
              return false;
            if ("//" === e2.substr(0, 2)) {
              if (!t2.allow_protocol_relative_urls)
                return false;
              l[0] = e2.substr(2);
            }
          }
          if ("" === (e2 = l.join("://")))
            return false;
          if ("" === (e2 = (l = e2.split("/")).shift()) && !t2.require_host)
            return true;
          if (1 < (l = e2.split("@")).length) {
            if (t2.disallow_auth)
              return false;
            if ("" === l[0])
              return false;
            if (0 <= (i2 = l.shift()).indexOf(":") && 2 < i2.split(":").length)
              return false;
            var d = i2.split(":"), f = (m = 2, function(e3) {
              if (Array.isArray(e3))
                return e3;
            }(h = d) || function(e3, t3) {
              if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3)) {
                var r3 = [], i3 = true, n2 = false, a2 = void 0;
                try {
                  for (var o2, s2 = e3[Symbol.iterator](); !(i3 = (o2 = s2.next()).done) && (r3.push(o2.value), !t3 || r3.length !== t3); i3 = true)
                    ;
                } catch (e4) {
                  n2 = true, a2 = e4;
                } finally {
                  try {
                    i3 || null == s2.return || s2.return();
                  } finally {
                    if (n2)
                      throw a2;
                  }
                }
                return r3;
              }
            }(h, m) || function(e3, t3) {
              if (e3) {
                if ("string" == typeof e3)
                  return A(e3, t3);
                var r3 = Object.prototype.toString.call(e3).slice(8, -1);
                return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? A(e3, t3) : void 0;
              }
            }(h, m) || function() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }()), c = f[0], p = f[1];
            if ("" === c && "" === p)
              return false;
          }
          var h, m;
          a = l.join("@"), u = s = null;
          var v = a.match(b);
          v ? (n = "", u = v[1], s = v[2] || null) : (l = a.split(":"), n = l.shift(), l.length && (s = l.join(":")));
          if (null !== s && 0 < s.length) {
            if (o = parseInt(s, 10), !/^[0-9]+$/.test(s) || o <= 0 || 65535 < o)
              return false;
          } else if (t2.require_port)
            return false;
          if (t2.host_whitelist)
            return O(n, t2.host_whitelist);
          if (!((0, y.default)(n) || (0, g.default)(n, t2) || u && (0, y.default)(u, 6)))
            return false;
          if (n = n || u, t2.host_blacklist && O(n, t2.host_blacklist))
            return false;
          return true;
        };
        var _ = i(e("./util/assertString")), g = i(e("./isFQDN")), y = i(e("./isIP")), E = i(e("./util/merge"));
        function i(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function A(e2, t2) {
          (null == t2 || t2 > e2.length) && (t2 = e2.length);
          for (var r2 = 0, i2 = new Array(t2); r2 < t2; r2++)
            i2[r2] = e2[r2];
          return i2;
        }
        var S = { protocols: ["http", "https", "ftp"], require_tld: true, require_protocol: false, require_host: true, require_port: false, require_valid_protocol: true, allow_underscores: false, allow_trailing_dot: false, allow_protocol_relative_urls: false, allow_fragments: true, allow_query_components: true, validate_length: true }, b = /^\[([^\]]+)\](?::([0-9]+))?$/;
        function O(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2++) {
            var i2 = t2[r2];
            if (e2 === i2 || (n = i2, "[object RegExp]" === Object.prototype.toString.call(n) && i2.test(e2)))
              return true;
          }
          var n;
          return false;
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isFQDN": 32, "./isIP": 42, "./util/assertString": 99, "./util/merge": 101 }], 82: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2);
          var r2 = a[[void 0, null].includes(t2) ? "all" : t2];
          return !!r2 && r2.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { 1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i, 2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i, 3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i, 4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i, 5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i, all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 83: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), e2 === e2.toUpperCase();
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 84: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), (0, n.default)(t2), t2 in a)
            return a[t2].test(e2);
          throw new Error("Invalid country code: '".concat(t2, "'"));
        }, r.vatMatchers = void 0;
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        var a = { GB: /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/, IT: /^(IT)?[0-9]{11}$/, NL: /^(NL)?[0-9]{9}B[0-9]{2}$/ };
        r.vatMatchers = a;
      }, { "./util/assertString": 99 }], 85: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), a.fullWidth.test(e2) && o.halfWidth.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i }, a = e("./isFullWidth"), o = e("./isHalfWidth");
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isFullWidth": 34, "./isHalfWidth": 36, "./util/assertString": 99 }], 86: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2);
          for (var r2 = e2.length - 1; 0 <= r2; r2--)
            if (-1 === t2.indexOf(e2[r2]))
              return false;
          return true;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 87: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, n.default)(e2);
          var r2 = t2 ? new RegExp("^[".concat(t2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+"), "g") : /^\s+/g;
          return e2.replace(r2, "");
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 88: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2, r2) {
          (0, n.default)(e2), "[object RegExp]" !== Object.prototype.toString.call(t2) && (t2 = new RegExp(t2, r2));
          return t2.test(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 89: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          t2 = (0, o.default)(t2, s);
          var r2 = e2.split("@"), i2 = r2.pop(), n = [r2.join("@"), i2];
          if (n[1] = n[1].toLowerCase(), "gmail.com" === n[1] || "googlemail.com" === n[1]) {
            if (t2.gmail_remove_subaddress && (n[0] = n[0].split("+")[0]), t2.gmail_remove_dots && (n[0] = n[0].replace(/\.+/g, c)), !n[0].length)
              return false;
            (t2.all_lowercase || t2.gmail_lowercase) && (n[0] = n[0].toLowerCase()), n[1] = t2.gmail_convert_googlemaildotcom ? "gmail.com" : n[1];
          } else if (0 <= l.indexOf(n[1])) {
            if (t2.icloud_remove_subaddress && (n[0] = n[0].split("+")[0]), !n[0].length)
              return false;
            (t2.all_lowercase || t2.icloud_lowercase) && (n[0] = n[0].toLowerCase());
          } else if (0 <= u.indexOf(n[1])) {
            if (t2.outlookdotcom_remove_subaddress && (n[0] = n[0].split("+")[0]), !n[0].length)
              return false;
            (t2.all_lowercase || t2.outlookdotcom_lowercase) && (n[0] = n[0].toLowerCase());
          } else if (0 <= d.indexOf(n[1])) {
            if (t2.yahoo_remove_subaddress) {
              var a = n[0].split("-");
              n[0] = 1 < a.length ? a.slice(0, -1).join("-") : a[0];
            }
            if (!n[0].length)
              return false;
            (t2.all_lowercase || t2.yahoo_lowercase) && (n[0] = n[0].toLowerCase());
          } else
            0 <= f.indexOf(n[1]) ? ((t2.all_lowercase || t2.yandex_lowercase) && (n[0] = n[0].toLowerCase()), n[1] = "yandex.ru") : t2.all_lowercase && (n[0] = n[0].toLowerCase());
          return n.join("@");
        };
        var i, o = (i = e("./util/merge")) && i.__esModule ? i : { default: i };
        var s = { all_lowercase: true, gmail_lowercase: true, gmail_remove_dots: true, gmail_remove_subaddress: true, gmail_convert_googlemaildotcom: true, outlookdotcom_lowercase: true, outlookdotcom_remove_subaddress: true, yahoo_lowercase: true, yahoo_remove_subaddress: true, yandex_lowercase: true, icloud_lowercase: true, icloud_remove_subaddress: true }, l = ["icloud.com", "me.com"], u = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"], d = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"], f = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];
        function c(e2) {
          return 1 < e2.length ? e2 : "";
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/merge": 101 }], 90: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), t2) {
            var r2 = new RegExp("[".concat(t2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+$"), "g");
            return e2.replace(r2, "");
          }
          var i2 = e2.length - 1;
          for (; /\s/.test(e2.charAt(i2)); )
            i2 -= 1;
          return e2.slice(0, i2 + 1);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 91: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          (0, i.default)(e2);
          var r2 = t2 ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
          return (0, n.default)(e2, r2);
        };
        var i = a(e("./util/assertString")), n = a(e("./blacklist"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./blacklist": 6, "./util/assertString": 99 }], 92: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          if ((0, n.default)(e2), t2)
            return "1" === e2 || /^true$/i.test(e2);
          return "0" !== e2 && !/^false$/i.test(e2) && "" !== e2;
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 93: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), e2 = Date.parse(e2), isNaN(e2) ? null : new Date(e2);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 94: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2) ? parseFloat(e2) : NaN;
        };
        var i, n = (i = e("./isFloat")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./isFloat": 33 }], 95: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), parseInt(e2, t2 || 10);
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 96: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, i.default)((0, n.default)(e2, t2), t2);
        };
        var i = a(e("./rtrim")), n = a(e("./ltrim"));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.exports = r.default, t.exports.default = r.default;
      }, { "./ltrim": 87, "./rtrim": 90 }], 97: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          return (0, n.default)(e2), e2.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#x5C;/g, "\\").replace(/&#96;/g, "`").replace(/&amp;/g, "&");
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 98: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.iso7064Check = function(e2) {
          for (var t2 = 10, r2 = 0; r2 < e2.length - 1; r2++)
            t2 = (parseInt(e2[r2], 10) + t2) % 10 == 0 ? 9 : (parseInt(e2[r2], 10) + t2) % 10 * 2 % 11;
          return (t2 = 1 === t2 ? 0 : 11 - t2) === parseInt(e2[10], 10);
        }, r.luhnCheck = function(e2) {
          for (var t2 = 0, r2 = false, i = e2.length - 1; 0 <= i; i--) {
            if (r2) {
              var n = 2 * parseInt(e2[i], 10);
              t2 += 9 < n ? n.toString().split("").map(function(e3) {
                return parseInt(e3, 10);
              }).reduce(function(e3, t3) {
                return e3 + t3;
              }, 0) : n;
            } else
              t2 += parseInt(e2[i], 10);
            r2 = !r2;
          }
          return t2 % 10 == 0;
        }, r.reverseMultiplyAndSum = function(e2, t2) {
          for (var r2 = 0, i = 0; i < e2.length; i++)
            r2 += e2[i] * (t2 - i);
          return r2;
        }, r.verhoeffCheck = function(e2) {
          for (var t2 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]], r2 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]], i = e2.split("").reverse().join(""), n = 0, a = 0; a < i.length; a++)
            n = t2[n][r2[a % 8][parseInt(i[a], 10)]];
          return 0 === n;
        };
      }, {}], 99: [function(e, t, r) {
        "use strict";
        function i(e2) {
          return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          if (!("string" == typeof e2 || e2 instanceof String)) {
            var t2 = i(e2);
            throw null === e2 ? t2 = "null" : "object" === t2 && (t2 = e2.constructor.name), new TypeError("Expected a string but received a ".concat(t2));
          }
        }, t.exports = r.default, t.exports.default = r.default;
      }, {}], 100: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var i = function(e2, t2) {
          return e2.some(function(e3) {
            return t2 === e3;
          });
        };
        r.default = i, t.exports = r.default, t.exports.default = r.default;
      }, {}], 101: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function() {
          var e2 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}, t2 = 1 < arguments.length ? arguments[1] : void 0;
          for (var r2 in t2)
            void 0 === e2[r2] && (e2[r2] = t2[r2]);
          return e2;
        }, t.exports = r.default, t.exports.default = r.default;
      }, {}], 102: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          var r2 = e2.join("");
          return new RegExp(r2, t2);
        }, t.exports = r.default, t.exports.default = r.default;
      }, {}], 103: [function(e, t, r) {
        "use strict";
        function i(e2) {
          return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2) {
          "object" === i(e2) && null !== e2 ? e2 = "function" == typeof e2.toString ? e2.toString() : "[object Object]" : (null == e2 || isNaN(e2) && !e2.length) && (e2 = "");
          return String(e2);
        }, t.exports = r.default, t.exports.default = r.default;
      }, {}], 104: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t2) {
          return (0, n.default)(e2), e2.replace(new RegExp("[^".concat(t2, "]+"), "g"), "");
        };
        var i, n = (i = e("./util/assertString")) && i.__esModule ? i : { default: i };
        t.exports = r.default, t.exports.default = r.default;
      }, { "./util/assertString": 99 }], 105: [function(e, t, r) {
        "use strict";
        t.exports = { INVALID_TYPE: "Expected type {0} but found type {1}", INVALID_FORMAT: "Object didn't pass validation for format {0}: {1}", ENUM_MISMATCH: "No enum match for: {0}", ENUM_CASE_MISMATCH: "Enum does not match case for: {0}", ANY_OF_MISSING: "Data does not match any schemas from 'anyOf'", ONE_OF_MISSING: "Data does not match any schemas from 'oneOf'", ONE_OF_MULTIPLE: "Data is valid against more than one schema from 'oneOf'", NOT_PASSED: "Data matches schema from 'not'", ARRAY_LENGTH_SHORT: "Array is too short ({0}), minimum {1}", ARRAY_LENGTH_LONG: "Array is too long ({0}), maximum {1}", ARRAY_UNIQUE: "Array items are not unique (indexes {0} and {1})", ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed", MULTIPLE_OF: "Value {0} is not a multiple of {1}", MINIMUM: "Value {0} is less than minimum {1}", MINIMUM_EXCLUSIVE: "Value {0} is equal or less than exclusive minimum {1}", MAXIMUM: "Value {0} is greater than maximum {1}", MAXIMUM_EXCLUSIVE: "Value {0} is equal or greater than exclusive maximum {1}", OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({0}), minimum {1}", OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({0}), maximum {1}", OBJECT_MISSING_REQUIRED_PROPERTY: "Missing required property: {0}", OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed: {0}", OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {0} (due to key: {1})", MIN_LENGTH: "String is too short ({0} chars), minimum {1}", MAX_LENGTH: "String is too long ({0} chars), maximum {1}", PATTERN: "String does not match pattern {0}: {1}", KEYWORD_TYPE_EXPECTED: "Keyword '{0}' is expected to be of type '{1}'", KEYWORD_UNDEFINED_STRICT: "Keyword '{0}' must be defined in strict mode", KEYWORD_UNEXPECTED: "Keyword '{0}' is not expected to appear in the schema", KEYWORD_MUST_BE: "Keyword '{0}' must be {1}", KEYWORD_DEPENDENCY: "Keyword '{0}' requires keyword '{1}'", KEYWORD_PATTERN: "Keyword '{0}' is not a valid RegExp pattern: {1}", KEYWORD_VALUE_TYPE: "Each element of keyword '{0}' array must be a '{1}'", UNKNOWN_FORMAT: "There is no validation function for format '{0}'", CUSTOM_MODE_FORCE_PROPERTIES: "{0} must define at least one property if present", REF_UNRESOLVED: "Reference has not been resolved during compilation: {0}", UNRESOLVABLE_REFERENCE: "Reference could not be resolved: {0}", SCHEMA_NOT_REACHABLE: "Validator was not able to read schema with uri: {0}", SCHEMA_TYPE_EXPECTED: "Schema is expected to be of type 'object'", SCHEMA_NOT_AN_OBJECT: "Schema is not an object: {0}", ASYNC_TIMEOUT: "{0} asynchronous task(s) have timed out after {1} ms", PARENT_SCHEMA_VALIDATION_FAILED: "Schema failed to validate against its parent schema, see inner errors for details.", REMOTE_NOT_VALID: "Remote reference didn't compile successfully: {0}" };
      }, {}], 106: [function(e, t, r) {
        var i = e("validator"), n = { date: function(e2) {
          if ("string" != typeof e2)
            return true;
          var t2 = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(e2);
          return null !== t2 && !(t2[2] < "01" || "12" < t2[2] || t2[3] < "01" || "31" < t2[3]);
        }, "date-time": function(e2) {
          if ("string" != typeof e2)
            return true;
          var t2 = e2.toLowerCase().split("t");
          if (!n.date(t2[0]))
            return false;
          var r2 = /^([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?(z|([+-][0-9]{2}:[0-9]{2}))$/.exec(t2[1]);
          return null !== r2 && !("23" < r2[1] || "59" < r2[2] || "59" < r2[3]);
        }, email: function(e2) {
          return "string" != typeof e2 || i.isEmail(e2, { require_tld: true });
        }, hostname: function(e2) {
          if ("string" != typeof e2)
            return true;
          var t2 = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/.test(e2);
          if (t2) {
            if (255 < e2.length)
              return false;
            for (var r2 = e2.split("."), i2 = 0; i2 < r2.length; i2++)
              if (63 < r2[i2].length)
                return false;
          }
          return t2;
        }, "host-name": function(e2) {
          return n.hostname.call(this, e2);
        }, ipv4: function(e2) {
          return "string" != typeof e2 || i.isIP(e2, 4);
        }, ipv6: function(e2) {
          return "string" != typeof e2 || i.isIP(e2, 6);
        }, regex: function(e2) {
          try {
            return RegExp(e2), true;
          } catch (e3) {
            return false;
          }
        }, uri: function(e2) {
          return this.options.strictUris ? n["strict-uri"].apply(this, arguments) : "string" != typeof e2 || RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?").test(e2);
        }, "strict-uri": function(e2) {
          return "string" != typeof e2 || i.isURL(e2);
        } };
        t.exports = n;
      }, { validator: 4 }], 107: [function(e, t, p) {
        "use strict";
        var o = e("./FormatValidators"), s = e("./Report"), h = e("./Utils"), m = function(t2, e2) {
          return t2 && Array.isArray(t2.includeErrors) && 0 < t2.includeErrors.length && !e2.some(function(e3) {
            return t2.includeErrors.includes(e3);
          });
        }, u = { multipleOf: function(e2, t2, r) {
          if (!m(this.validateOptions, ["MULTIPLE_OF"]) && "number" == typeof r) {
            var i = String(t2.multipleOf), n = Math.pow(10, i.length - i.indexOf(".") - 1);
            "integer" !== h.whatIs(r * n / (t2.multipleOf * n)) && e2.addError("MULTIPLE_OF", [r, t2.multipleOf], null, t2);
          }
        }, maximum: function(e2, t2, r) {
          m(this.validateOptions, ["MAXIMUM", "MAXIMUM_EXCLUSIVE"]) || "number" == typeof r && (true !== t2.exclusiveMaximum ? r > t2.maximum && e2.addError("MAXIMUM", [r, t2.maximum], null, t2) : r >= t2.maximum && e2.addError("MAXIMUM_EXCLUSIVE", [r, t2.maximum], null, t2));
        }, exclusiveMaximum: function() {
        }, minimum: function(e2, t2, r) {
          m(this.validateOptions, ["MINIMUM", "MINIMUM_EXCLUSIVE"]) || "number" == typeof r && (true !== t2.exclusiveMinimum ? r < t2.minimum && e2.addError("MINIMUM", [r, t2.minimum], null, t2) : r <= t2.minimum && e2.addError("MINIMUM_EXCLUSIVE", [r, t2.minimum], null, t2));
        }, exclusiveMinimum: function() {
        }, maxLength: function(e2, t2, r) {
          m(this.validateOptions, ["MAX_LENGTH"]) || "string" == typeof r && h.ucs2decode(r).length > t2.maxLength && e2.addError("MAX_LENGTH", [r.length, t2.maxLength], null, t2);
        }, minLength: function(e2, t2, r) {
          m(this.validateOptions, ["MIN_LENGTH"]) || "string" == typeof r && h.ucs2decode(r).length < t2.minLength && e2.addError("MIN_LENGTH", [r.length, t2.minLength], null, t2);
        }, pattern: function(e2, t2, r) {
          m(this.validateOptions, ["PATTERN"]) || "string" == typeof r && false === RegExp(t2.pattern).test(r) && e2.addError("PATTERN", [t2.pattern, r], null, t2);
        }, additionalItems: function(e2, t2, r) {
          m(this.validateOptions, ["ARRAY_ADDITIONAL_ITEMS"]) || Array.isArray(r) && false === t2.additionalItems && Array.isArray(t2.items) && r.length > t2.items.length && e2.addError("ARRAY_ADDITIONAL_ITEMS", null, null, t2);
        }, items: function() {
        }, maxItems: function(e2, t2, r) {
          m(this.validateOptions, ["ARRAY_LENGTH_LONG"]) || Array.isArray(r) && r.length > t2.maxItems && e2.addError("ARRAY_LENGTH_LONG", [r.length, t2.maxItems], null, t2);
        }, minItems: function(e2, t2, r) {
          m(this.validateOptions, ["ARRAY_LENGTH_SHORT"]) || Array.isArray(r) && r.length < t2.minItems && e2.addError("ARRAY_LENGTH_SHORT", [r.length, t2.minItems], null, t2);
        }, uniqueItems: function(e2, t2, r) {
          if (!m(this.validateOptions, ["ARRAY_UNIQUE"]) && Array.isArray(r) && true === t2.uniqueItems) {
            var i = [];
            false === h.isUniqueArray(r, i) && e2.addError("ARRAY_UNIQUE", i, null, t2);
          }
        }, maxProperties: function(e2, t2, r) {
          if (!m(this.validateOptions, ["OBJECT_PROPERTIES_MAXIMUM"]) && "object" === h.whatIs(r)) {
            var i = Object.keys(r).length;
            i > t2.maxProperties && e2.addError("OBJECT_PROPERTIES_MAXIMUM", [i, t2.maxProperties], null, t2);
          }
        }, minProperties: function(e2, t2, r) {
          if (!m(this.validateOptions, ["OBJECT_PROPERTIES_MINIMUM"]) && "object" === h.whatIs(r)) {
            var i = Object.keys(r).length;
            i < t2.minProperties && e2.addError("OBJECT_PROPERTIES_MINIMUM", [i, t2.minProperties], null, t2);
          }
        }, required: function(e2, t2, r) {
          if (!m(this.validateOptions, ["OBJECT_MISSING_REQUIRED_PROPERTY"]) && "object" === h.whatIs(r))
            for (var i = t2.required.length; i--; ) {
              var n = t2.required[i];
              void 0 === r[n] && e2.addError("OBJECT_MISSING_REQUIRED_PROPERTY", [n], null, t2);
            }
        }, additionalProperties: function(e2, t2, r) {
          if (void 0 === t2.properties && void 0 === t2.patternProperties)
            return u.properties.call(this, e2, t2, r);
        }, patternProperties: function(e2, t2, r) {
          if (void 0 === t2.properties)
            return u.properties.call(this, e2, t2, r);
        }, properties: function(e2, t2, r) {
          if (!m(this.validateOptions, ["OBJECT_ADDITIONAL_PROPERTIES"]) && "object" === h.whatIs(r)) {
            var i = void 0 !== t2.properties ? t2.properties : {}, n = void 0 !== t2.patternProperties ? t2.patternProperties : {};
            if (false === t2.additionalProperties) {
              var a = Object.keys(r), o2 = Object.keys(i), s2 = Object.keys(n);
              a = h.difference(a, o2);
              for (var l = s2.length; l--; )
                for (var u2 = RegExp(s2[l]), d = a.length; d--; )
                  true === u2.test(a[d]) && a.splice(d, 1);
              if (0 < a.length) {
                var f = this.options.assumeAdditional.length;
                if (f)
                  for (; f--; ) {
                    var c = a.indexOf(this.options.assumeAdditional[f]);
                    -1 !== c && a.splice(c, 1);
                  }
                var p2 = a.length;
                if (p2)
                  for (; p2--; )
                    e2.addError("OBJECT_ADDITIONAL_PROPERTIES", [a[p2]], null, t2);
              }
            }
          }
        }, dependencies: function(e2, t2, r) {
          if (!m(this.validateOptions, ["OBJECT_DEPENDENCY_KEY"]) && "object" === h.whatIs(r))
            for (var i = Object.keys(t2.dependencies), n = i.length; n--; ) {
              var a = i[n];
              if (r[a]) {
                var o2 = t2.dependencies[a];
                if ("object" === h.whatIs(o2))
                  p.validate.call(this, e2, o2, r);
                else
                  for (var s2 = o2.length; s2--; ) {
                    var l = o2[s2];
                    void 0 === r[l] && e2.addError("OBJECT_DEPENDENCY_KEY", [l, a], null, t2);
                  }
              }
            }
        }, enum: function(e2, t2, r) {
          if (!m(this.validateOptions, ["ENUM_CASE_MISMATCH", "ENUM_MISMATCH"])) {
            for (var i = false, n = false, a = t2.enum.length; a--; ) {
              if (h.areEqual(r, t2.enum[a])) {
                i = true;
                break;
              }
              h.areEqual(r, t2.enum[a]), n = true;
            }
            if (false === i) {
              var o2 = n && this.options.enumCaseInsensitiveComparison ? "ENUM_CASE_MISMATCH" : "ENUM_MISMATCH";
              e2.addError(o2, [r], null, t2);
            }
          }
        }, type: function(e2, t2, r) {
          if (!m(this.validateOptions, ["INVALID_TYPE"])) {
            var i = h.whatIs(r);
            "string" == typeof t2.type ? i === t2.type || "integer" === i && "number" === t2.type || e2.addError("INVALID_TYPE", [t2.type, i], null, t2) : -1 !== t2.type.indexOf(i) || "integer" === i && -1 !== t2.type.indexOf("number") || e2.addError("INVALID_TYPE", [t2.type, i], null, t2);
          }
        }, allOf: function(e2, t2, r) {
          for (var i = t2.allOf.length; i--; ) {
            var n = p.validate.call(this, e2, t2.allOf[i], r);
            if (this.options.breakOnFirstError && false === n)
              break;
          }
        }, anyOf: function(e2, t2, r) {
          for (var i = [], n = false, a = t2.anyOf.length; a-- && false === n; ) {
            var o2 = new s(e2);
            i.push(o2), n = p.validate.call(this, o2, t2.anyOf[a], r);
          }
          false === n && e2.addError("ANY_OF_MISSING", void 0, i, t2);
        }, oneOf: function(e2, t2, r) {
          for (var i = 0, n = [], a = t2.oneOf.length; a--; ) {
            var o2 = new s(e2, { maxErrors: 1 });
            n.push(o2), true === p.validate.call(this, o2, t2.oneOf[a], r) && i++;
          }
          0 === i ? e2.addError("ONE_OF_MISSING", void 0, n, t2) : 1 < i && e2.addError("ONE_OF_MULTIPLE", null, null, t2);
        }, not: function(e2, t2, r) {
          var i = new s(e2);
          true === p.validate.call(this, i, t2.not, r) && e2.addError("NOT_PASSED", null, null, t2);
        }, definitions: function() {
        }, format: function(r, i, n) {
          var e2 = o[i.format];
          if ("function" == typeof e2) {
            if (m(this.validateOptions, ["INVALID_FORMAT"]))
              return;
            if (2 === e2.length) {
              var a = h.clone(r.path);
              r.addAsyncTask(e2, [n], function(e3) {
                if (true !== e3) {
                  var t2 = r.path;
                  r.path = a, r.addError("INVALID_FORMAT", [i.format, n], null, i), r.path = t2;
                }
              });
            } else
              true !== e2.call(this, n) && r.addError("INVALID_FORMAT", [i.format, n], null, i);
          } else
            true !== this.options.ignoreUnknownFormats && r.addError("UNKNOWN_FORMAT", [i.format], null, i);
        } };
        p.JsonValidators = u, p.validate = function(e2, t2, r) {
          e2.commonErrorMessage = "JSON_OBJECT_VALIDATION_FAILED";
          var i = h.whatIs(t2);
          if ("object" !== i)
            return e2.addError("SCHEMA_NOT_AN_OBJECT", [i], null, t2), false;
          var n = Object.keys(t2);
          if (0 === n.length)
            return true;
          var a = false;
          if (e2.rootSchema || (e2.rootSchema = t2, a = true), void 0 !== t2.$ref) {
            for (var o2 = 99; t2.$ref && 0 < o2; ) {
              if (!t2.__$refResolved) {
                e2.addError("REF_UNRESOLVED", [t2.$ref], null, t2);
                break;
              }
              if (t2.__$refResolved === t2)
                break;
              t2 = t2.__$refResolved, n = Object.keys(t2), o2--;
            }
            if (0 === o2)
              throw new Error("Circular dependency by $ref references!");
          }
          var s2 = h.whatIs(r);
          if (t2.type && (n.splice(n.indexOf("type"), 1), u.type.call(this, e2, t2, r), e2.errors.length && this.options.breakOnFirstError))
            return false;
          for (var l = n.length; l-- && !(u[n[l]] && (u[n[l]].call(this, e2, t2, r), e2.errors.length && this.options.breakOnFirstError)); )
            ;
          return 0 !== e2.errors.length && false !== this.options.breakOnFirstError || ("array" === s2 ? function(e3, t3, r2) {
            var i2 = r2.length;
            if (Array.isArray(t3.items))
              for (; i2--; )
                i2 < t3.items.length ? (e3.path.push(i2), p.validate.call(this, e3, t3.items[i2], r2[i2]), e3.path.pop()) : "object" == typeof t3.additionalItems && (e3.path.push(i2), p.validate.call(this, e3, t3.additionalItems, r2[i2]), e3.path.pop());
            else if ("object" == typeof t3.items)
              for (; i2--; )
                e3.path.push(i2), p.validate.call(this, e3, t3.items, r2[i2]), e3.path.pop();
          }.call(this, e2, t2, r) : "object" === s2 && function(e3, t3, r2) {
            var i2 = t3.additionalProperties;
            true !== i2 && void 0 !== i2 || (i2 = {});
            for (var n2 = t3.properties ? Object.keys(t3.properties) : [], a2 = t3.patternProperties ? Object.keys(t3.patternProperties) : [], o3 = Object.keys(r2), s3 = o3.length; s3--; ) {
              var l2 = o3[s3], u2 = r2[l2], d = [];
              -1 !== n2.indexOf(l2) && d.push(t3.properties[l2]);
              for (var f = a2.length; f--; ) {
                var c = a2[f];
                true === RegExp(c).test(l2) && d.push(t3.patternProperties[c]);
              }
              for (0 === d.length && false !== i2 && d.push(i2), f = d.length; f--; )
                e3.path.push(l2), p.validate.call(this, e3, d[f], u2), e3.path.pop();
            }
          }.call(this, e2, t2, r)), "function" == typeof this.options.customValidator && this.options.customValidator.call(this, e2, t2, r), a && (e2.rootSchema = void 0), 0 === e2.errors.length;
        };
      }, { "./FormatValidators": 106, "./Report": 109, "./Utils": 113 }], 108: [function(e, t, r) {
        "function" != typeof Number.isFinite && (Number.isFinite = function(e2) {
          return "number" == typeof e2 && (e2 == e2 && e2 !== 1 / 0 && e2 !== -1 / 0);
        });
      }, {}], 109: [function(e, t, r) {
        (function(d) {
          (function() {
            "use strict";
            var r2 = e("lodash.get"), n = e("./Errors"), f = e("./Utils");
            function i(e2, t2) {
              this.parentReport = e2 instanceof i ? e2 : void 0, this.options = e2 instanceof i ? e2.options : e2 || {}, this.reportOptions = t2 || {}, this.errors = [], this.path = [], this.asyncTasks = [], this.rootSchema = void 0, this.commonErrorMessage = void 0, this.json = void 0;
            }
            i.prototype.isValid = function() {
              if (0 < this.asyncTasks.length)
                throw new Error("Async tasks pending, can't answer isValid");
              return 0 === this.errors.length;
            }, i.prototype.addAsyncTask = function(e2, t2, r3) {
              this.asyncTasks.push([e2, t2, r3]);
            }, i.prototype.getAncestor = function(e2) {
              if (this.parentReport)
                return this.parentReport.getSchemaId() === e2 ? this.parentReport : this.parentReport.getAncestor(e2);
            }, i.prototype.processAsyncTasks = function(e2, r3) {
              var t2 = e2 || 2e3, i2 = this.asyncTasks.length, n2 = i2, a = false, o = this;
              function s() {
                d.nextTick(function() {
                  var e3 = 0 === o.errors.length, t3 = e3 ? null : o.errors;
                  r3(t3, e3);
                });
              }
              function l(t3) {
                return function(e3) {
                  a || (t3(e3), 0 == --i2 && s());
                };
              }
              if (0 === i2 || 0 < this.errors.length && this.options.breakOnFirstError)
                s();
              else {
                for (; n2--; ) {
                  var u = this.asyncTasks[n2];
                  u[0].apply(null, u[1].concat(l(u[2])));
                }
                setTimeout(function() {
                  0 < i2 && (a = true, o.addError("ASYNC_TIMEOUT", [i2, t2]), r3(o.errors, false));
                }, t2);
              }
            }, i.prototype.getPath = function(e2) {
              var t2 = [];
              return this.parentReport && (t2 = t2.concat(this.parentReport.path)), t2 = t2.concat(this.path), true !== e2 && (t2 = "#/" + t2.map(function(e3) {
                return e3 = e3.toString(), f.isAbsoluteUri(e3) ? "uri(" + e3 + ")" : e3.replace(/\~/g, "~0").replace(/\//g, "~1");
              }).join("/")), t2;
            }, i.prototype.getSchemaId = function() {
              if (!this.rootSchema)
                return null;
              var e2 = [];
              for (this.parentReport && (e2 = e2.concat(this.parentReport.path)), e2 = e2.concat(this.path); 0 < e2.length; ) {
                var t2 = r2(this.rootSchema, e2);
                if (t2 && t2.id)
                  return t2.id;
                e2.pop();
              }
              return this.rootSchema.id;
            }, i.prototype.hasError = function(e2, t2) {
              for (var r3 = this.errors.length; r3--; )
                if (this.errors[r3].code === e2) {
                  for (var i2 = true, n2 = this.errors[r3].params.length; n2--; )
                    this.errors[r3].params[n2] !== t2[n2] && (i2 = false);
                  if (i2)
                    return i2;
                }
              return false;
            }, i.prototype.addError = function(e2, t2, r3, i2) {
              if (!e2)
                throw new Error("No errorCode passed into addError()");
              this.addCustomError(e2, n[e2], t2, r3, i2);
            }, i.prototype.getJson = function() {
              for (var e2 = this; void 0 === e2.json; )
                if (void 0 === (e2 = e2.parentReport))
                  return;
              return e2.json;
            }, i.prototype.addCustomError = function(e2, t2, r3, i2, n2) {
              if (!(this.errors.length >= this.reportOptions.maxErrors)) {
                if (!t2)
                  throw new Error("No errorMessage known for code " + e2);
                for (var a = (r3 = r3 || []).length; a--; ) {
                  var o = f.whatIs(r3[a]), s = "object" === o || "null" === o ? JSON.stringify(r3[a]) : r3[a];
                  t2 = t2.replace("{" + a + "}", s);
                }
                var l = { code: e2, params: r3, message: t2, path: this.getPath(this.options.reportPathAsArray), schemaId: this.getSchemaId() };
                if (l[f.schemaSymbol] = n2, l[f.jsonSymbol] = this.getJson(), n2 && "string" == typeof n2 ? l.description = n2 : n2 && "object" == typeof n2 && (n2.title && (l.title = n2.title), n2.description && (l.description = n2.description)), null != i2) {
                  for (Array.isArray(i2) || (i2 = [i2]), l.inner = [], a = i2.length; a--; )
                    for (var u = i2[a], d2 = u.errors.length; d2--; )
                      l.inner.push(u.errors[d2]);
                  0 === l.inner.length && (l.inner = void 0);
                }
                this.errors.push(l);
              }
            }, t.exports = i;
          }).call(this);
        }).call(this, e("_process"));
      }, { "./Errors": 105, "./Utils": 113, _process: 3, "lodash.get": 1 }], 110: [function(e, t, r) {
        "use strict";
        var n = e("lodash.isequal"), _ = e("./Report"), g = e("./SchemaCompilation"), y = e("./SchemaValidation"), a = e("./Utils");
        function E(e2) {
          var t2 = e2.indexOf("#");
          return -1 === t2 ? e2 : e2.slice(0, t2);
        }
        function A(e2, t2) {
          if ("object" == typeof e2 && null !== e2) {
            if (!t2)
              return e2;
            if (e2.id && (e2.id === t2 || "#" === e2.id[0] && e2.id.substring(1) === t2))
              return e2;
            var r2, i;
            if (Array.isArray(e2)) {
              for (r2 = e2.length; r2--; )
                if (i = A(e2[r2], t2))
                  return i;
            } else {
              var n2 = Object.keys(e2);
              for (r2 = n2.length; r2--; ) {
                var a2 = n2[r2];
                if (0 !== a2.indexOf("__$") && (i = A(e2[a2], t2)))
                  return i;
              }
            }
          }
        }
        r.cacheSchemaByUri = function(e2, t2) {
          var r2 = E(e2);
          r2 && (this.cache[r2] = t2);
        }, r.removeFromCacheByUri = function(e2) {
          var t2 = E(e2);
          t2 && delete this.cache[t2];
        }, r.checkCacheForUri = function(e2) {
          var t2 = E(e2);
          return !!t2 && null != this.cache[t2];
        }, r.getSchema = function(e2, t2) {
          return "object" == typeof t2 && (t2 = r.getSchemaByReference.call(this, e2, t2)), "string" == typeof t2 && (t2 = r.getSchemaByUri.call(this, e2, t2)), t2;
        }, r.getSchemaByReference = function(e2, t2) {
          for (var r2 = this.referenceCache.length; r2--; )
            if (n(this.referenceCache[r2][0], t2))
              return this.referenceCache[r2][1];
          var i = a.cloneDeep(t2);
          return this.referenceCache.push([t2, i]), i;
        }, r.getSchemaByUri = function(e2, t2, r2) {
          var i, n2, a2, o = E(t2), s = -1 === (n2 = (i = t2).indexOf("#")) ? void 0 : i.slice(n2 + 1), l = o ? this.cache[o] : r2;
          if (l && o && l !== r2) {
            var u;
            e2.path.push(o);
            var d = e2.getAncestor(l.id);
            if (d)
              u = d;
            else if (u = new _(e2), g.compileSchema.call(this, u, l)) {
              var f = this.options;
              try {
                this.options = l.__$validationOptions || this.options, y.validateSchema.call(this, u, l);
              } finally {
                this.options = f;
              }
            }
            var c = u.isValid();
            if (c || e2.addError("REMOTE_NOT_VALID", [t2], u), e2.path.pop(), !c)
              return;
          }
          if (l && s)
            for (var p = s.split("/"), h = 0, m = p.length; l && h < m; h++) {
              var v = (a2 = p[h], decodeURIComponent(a2).replace(/~[0-1]/g, function(e3) {
                return "~1" === e3 ? "/" : "~";
              }));
              l = 0 === h ? A(l, v) : l[v];
            }
          return l;
        }, r.getRemotePath = E;
      }, { "./Report": 109, "./SchemaCompilation": 111, "./SchemaValidation": 112, "./Utils": 113, "lodash.isequal": 2 }], 111: [function(e, t, _) {
        "use strict";
        var g = e("./Report"), y = e("./SchemaCache"), E = e("./Utils");
        function A(e2, t2) {
          if (E.isAbsoluteUri(t2))
            return t2;
          var r, i = e2.join(""), n = E.isAbsoluteUri(i), a = E.isRelativeUri(i), o = E.isRelativeUri(t2);
          n && o ? (r = i.match(/\/[^\/]*$/)) && (i = i.slice(0, r.index + 1)) : a && o ? i = "" : (r = i.match(/[^#/]+$/)) && (i = i.slice(0, r.index));
          var s = i + t2;
          return s = s.replace(/##/, "#");
        }
        var S = function(e2, t2) {
          for (var r = t2.length, i = 0; r--; ) {
            var n = new g(e2);
            _.compileSchema.call(this, n, t2[r]) && i++, e2.errors = e2.errors.concat(n.errors);
          }
          return i;
        };
        function b(e2, t2) {
          for (var r = e2.length; r--; )
            if (e2[r].id === t2)
              return e2[r];
          return null;
        }
        _.compileSchema = function(e2, t2) {
          if (e2.commonErrorMessage = "SCHEMA_COMPILATION_FAILED", "string" == typeof t2) {
            var r = y.getSchemaByUri.call(this, e2, t2);
            if (!r)
              return e2.addError("SCHEMA_NOT_REACHABLE", [t2]), false;
            t2 = r;
          }
          if (Array.isArray(t2))
            return function(e3, t3) {
              var r2, i2 = 0;
              do {
                for (var n2 = e3.errors.length; n2--; )
                  "UNRESOLVABLE_REFERENCE" === e3.errors[n2].code && e3.errors.splice(n2, 1);
                for (r2 = i2, i2 = S.call(this, e3, t3), n2 = t3.length; n2--; ) {
                  var a2 = t3[n2];
                  if (a2.__$missingReferences) {
                    for (var o2 = a2.__$missingReferences.length; o2--; ) {
                      var s2 = a2.__$missingReferences[o2], l2 = b(t3, s2.ref);
                      l2 && (s2.obj["__" + s2.key + "Resolved"] = l2, a2.__$missingReferences.splice(o2, 1));
                    }
                    0 === a2.__$missingReferences.length && delete a2.__$missingReferences;
                  }
                }
              } while (i2 !== t3.length && i2 !== r2);
              return e3.isValid();
            }.call(this, e2, t2);
          if (t2.__$compiled && t2.id && false === y.checkCacheForUri.call(this, t2.id) && (t2.__$compiled = void 0), t2.__$compiled)
            return true;
          t2.id && "string" == typeof t2.id && y.cacheSchemaByUri.call(this, t2.id, t2);
          var i = false;
          e2.rootSchema || (e2.rootSchema = t2, i = true);
          var n = e2.isValid();
          delete t2.__$missingReferences;
          for (var a = function e3(t3, r2, i2, n2) {
            if (r2 = r2 || [], i2 = i2 || [], n2 = n2 || [], "object" != typeof t3 || null === t3)
              return r2;
            var a2;
            if ("string" == typeof t3.id && i2.push(t3.id), "string" == typeof t3.$ref && void 0 === t3.__$refResolved && r2.push({ ref: A(i2, t3.$ref), key: "$ref", obj: t3, path: n2.slice(0) }), "string" == typeof t3.$schema && void 0 === t3.__$schemaResolved && r2.push({ ref: A(i2, t3.$schema), key: "$schema", obj: t3, path: n2.slice(0) }), Array.isArray(t3))
              for (a2 = t3.length; a2--; )
                n2.push(a2.toString()), e3(t3[a2], r2, i2, n2), n2.pop();
            else {
              var o2 = Object.keys(t3);
              for (a2 = o2.length; a2--; )
                0 !== o2[a2].indexOf("__$") && (n2.push(o2[a2]), e3(t3[o2[a2]], r2, i2, n2), n2.pop());
            }
            return "string" == typeof t3.id && i2.pop(), r2;
          }.call(this, t2), o = a.length; o--; ) {
            var s = a[o], l = y.getSchemaByUri.call(this, e2, s.ref, t2);
            if (!l) {
              var u = this.getSchemaReader();
              if (u) {
                var d = u(s.ref);
                if (d) {
                  d.id = s.ref;
                  var f = new g(e2);
                  _.compileSchema.call(this, f, d) ? l = y.getSchemaByUri.call(this, e2, s.ref, t2) : e2.errors = e2.errors.concat(f.errors);
                }
              }
            }
            if (!l) {
              var c = e2.hasError("REMOTE_NOT_VALID", [s.ref]), p = E.isAbsoluteUri(s.ref), h = false, m = true === this.options.ignoreUnresolvableReferences;
              p && (h = y.checkCacheForUri.call(this, s.ref)), c || m && p || h || (Array.prototype.push.apply(e2.path, s.path), e2.addError("UNRESOLVABLE_REFERENCE", [s.ref]), e2.path = e2.path.slice(0, -s.path.length), n && (t2.__$missingReferences = t2.__$missingReferences || [], t2.__$missingReferences.push(s)));
            }
            s.obj["__" + s.key + "Resolved"] = l;
          }
          var v = e2.isValid();
          return v ? t2.__$compiled = true : t2.id && "string" == typeof t2.id && y.removeFromCacheByUri.call(this, t2.id), i && (e2.rootSchema = void 0), v;
        };
      }, { "./Report": 109, "./SchemaCache": 110, "./Utils": 113 }], 112: [function(e, t, d) {
        "use strict";
        var r = e("./FormatValidators"), f = e("./JsonValidation"), c = e("./Report"), p = e("./Utils"), h = { $ref: function(e2, t2) {
          "string" != typeof t2.$ref && e2.addError("KEYWORD_TYPE_EXPECTED", ["$ref", "string"]);
        }, $schema: function(e2, t2) {
          "string" != typeof t2.$schema && e2.addError("KEYWORD_TYPE_EXPECTED", ["$schema", "string"]);
        }, multipleOf: function(e2, t2) {
          "number" != typeof t2.multipleOf ? e2.addError("KEYWORD_TYPE_EXPECTED", ["multipleOf", "number"]) : t2.multipleOf <= 0 && e2.addError("KEYWORD_MUST_BE", ["multipleOf", "strictly greater than 0"]);
        }, maximum: function(e2, t2) {
          "number" != typeof t2.maximum && e2.addError("KEYWORD_TYPE_EXPECTED", ["maximum", "number"]);
        }, exclusiveMaximum: function(e2, t2) {
          "boolean" != typeof t2.exclusiveMaximum ? e2.addError("KEYWORD_TYPE_EXPECTED", ["exclusiveMaximum", "boolean"]) : void 0 === t2.maximum && e2.addError("KEYWORD_DEPENDENCY", ["exclusiveMaximum", "maximum"]);
        }, minimum: function(e2, t2) {
          "number" != typeof t2.minimum && e2.addError("KEYWORD_TYPE_EXPECTED", ["minimum", "number"]);
        }, exclusiveMinimum: function(e2, t2) {
          "boolean" != typeof t2.exclusiveMinimum ? e2.addError("KEYWORD_TYPE_EXPECTED", ["exclusiveMinimum", "boolean"]) : void 0 === t2.minimum && e2.addError("KEYWORD_DEPENDENCY", ["exclusiveMinimum", "minimum"]);
        }, maxLength: function(e2, t2) {
          "integer" !== p.whatIs(t2.maxLength) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["maxLength", "integer"]) : t2.maxLength < 0 && e2.addError("KEYWORD_MUST_BE", ["maxLength", "greater than, or equal to 0"]);
        }, minLength: function(e2, t2) {
          "integer" !== p.whatIs(t2.minLength) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["minLength", "integer"]) : t2.minLength < 0 && e2.addError("KEYWORD_MUST_BE", ["minLength", "greater than, or equal to 0"]);
        }, pattern: function(t2, r2) {
          if ("string" != typeof r2.pattern)
            t2.addError("KEYWORD_TYPE_EXPECTED", ["pattern", "string"]);
          else
            try {
              RegExp(r2.pattern);
            } catch (e2) {
              t2.addError("KEYWORD_PATTERN", ["pattern", r2.pattern]);
            }
        }, additionalItems: function(e2, t2) {
          var r2 = p.whatIs(t2.additionalItems);
          "boolean" !== r2 && "object" !== r2 ? e2.addError("KEYWORD_TYPE_EXPECTED", ["additionalItems", ["boolean", "object"]]) : "object" === r2 && (e2.path.push("additionalItems"), d.validateSchema.call(this, e2, t2.additionalItems), e2.path.pop());
        }, items: function(e2, t2) {
          var r2 = p.whatIs(t2.items);
          if ("object" === r2)
            e2.path.push("items"), d.validateSchema.call(this, e2, t2.items), e2.path.pop();
          else if ("array" === r2)
            for (var i = t2.items.length; i--; )
              e2.path.push("items"), e2.path.push(i.toString()), d.validateSchema.call(this, e2, t2.items[i]), e2.path.pop(), e2.path.pop();
          else
            e2.addError("KEYWORD_TYPE_EXPECTED", ["items", ["array", "object"]]);
          true === this.options.forceAdditional && void 0 === t2.additionalItems && Array.isArray(t2.items) && e2.addError("KEYWORD_UNDEFINED_STRICT", ["additionalItems"]), this.options.assumeAdditional && void 0 === t2.additionalItems && Array.isArray(t2.items) && (t2.additionalItems = false);
        }, maxItems: function(e2, t2) {
          "number" != typeof t2.maxItems ? e2.addError("KEYWORD_TYPE_EXPECTED", ["maxItems", "integer"]) : t2.maxItems < 0 && e2.addError("KEYWORD_MUST_BE", ["maxItems", "greater than, or equal to 0"]);
        }, minItems: function(e2, t2) {
          "integer" !== p.whatIs(t2.minItems) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["minItems", "integer"]) : t2.minItems < 0 && e2.addError("KEYWORD_MUST_BE", ["minItems", "greater than, or equal to 0"]);
        }, uniqueItems: function(e2, t2) {
          "boolean" != typeof t2.uniqueItems && e2.addError("KEYWORD_TYPE_EXPECTED", ["uniqueItems", "boolean"]);
        }, maxProperties: function(e2, t2) {
          "integer" !== p.whatIs(t2.maxProperties) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["maxProperties", "integer"]) : t2.maxProperties < 0 && e2.addError("KEYWORD_MUST_BE", ["maxProperties", "greater than, or equal to 0"]);
        }, minProperties: function(e2, t2) {
          "integer" !== p.whatIs(t2.minProperties) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["minProperties", "integer"]) : t2.minProperties < 0 && e2.addError("KEYWORD_MUST_BE", ["minProperties", "greater than, or equal to 0"]);
        }, required: function(e2, t2) {
          if ("array" !== p.whatIs(t2.required))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["required", "array"]);
          else if (0 === t2.required.length)
            e2.addError("KEYWORD_MUST_BE", ["required", "an array with at least one element"]);
          else {
            for (var r2 = t2.required.length; r2--; )
              "string" != typeof t2.required[r2] && e2.addError("KEYWORD_VALUE_TYPE", ["required", "string"]);
            false === p.isUniqueArray(t2.required) && e2.addError("KEYWORD_MUST_BE", ["required", "an array with unique items"]);
          }
        }, additionalProperties: function(e2, t2) {
          var r2 = p.whatIs(t2.additionalProperties);
          "boolean" !== r2 && "object" !== r2 ? e2.addError("KEYWORD_TYPE_EXPECTED", ["additionalProperties", ["boolean", "object"]]) : "object" === r2 && (e2.path.push("additionalProperties"), d.validateSchema.call(this, e2, t2.additionalProperties), e2.path.pop());
        }, properties: function(e2, t2) {
          if ("object" === p.whatIs(t2.properties)) {
            for (var r2 = Object.keys(t2.properties), i = r2.length; i--; ) {
              var n = r2[i], a = t2.properties[n];
              e2.path.push("properties"), e2.path.push(n), d.validateSchema.call(this, e2, a), e2.path.pop(), e2.path.pop();
            }
            true === this.options.forceAdditional && void 0 === t2.additionalProperties && e2.addError("KEYWORD_UNDEFINED_STRICT", ["additionalProperties"]), this.options.assumeAdditional && void 0 === t2.additionalProperties && (t2.additionalProperties = false), true === this.options.forceProperties && 0 === r2.length && e2.addError("CUSTOM_MODE_FORCE_PROPERTIES", ["properties"]);
          } else
            e2.addError("KEYWORD_TYPE_EXPECTED", ["properties", "object"]);
        }, patternProperties: function(t2, e2) {
          if ("object" === p.whatIs(e2.patternProperties)) {
            for (var r2 = Object.keys(e2.patternProperties), i = r2.length; i--; ) {
              var n = r2[i], a = e2.patternProperties[n];
              try {
                RegExp(n);
              } catch (e3) {
                t2.addError("KEYWORD_PATTERN", ["patternProperties", n]);
              }
              t2.path.push("patternProperties"), t2.path.push(n.toString()), d.validateSchema.call(this, t2, a), t2.path.pop(), t2.path.pop();
            }
            true === this.options.forceProperties && 0 === r2.length && t2.addError("CUSTOM_MODE_FORCE_PROPERTIES", ["patternProperties"]);
          } else
            t2.addError("KEYWORD_TYPE_EXPECTED", ["patternProperties", "object"]);
        }, dependencies: function(e2, t2) {
          if ("object" !== p.whatIs(t2.dependencies))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["dependencies", "object"]);
          else
            for (var r2 = Object.keys(t2.dependencies), i = r2.length; i--; ) {
              var n = r2[i], a = t2.dependencies[n], o = p.whatIs(a);
              if ("object" === o)
                e2.path.push("dependencies"), e2.path.push(n), d.validateSchema.call(this, e2, a), e2.path.pop(), e2.path.pop();
              else if ("array" === o) {
                var s = a.length;
                for (0 === s && e2.addError("KEYWORD_MUST_BE", ["dependencies", "not empty array"]); s--; )
                  "string" != typeof a[s] && e2.addError("KEYWORD_VALUE_TYPE", ["dependensices", "string"]);
                false === p.isUniqueArray(a) && e2.addError("KEYWORD_MUST_BE", ["dependencies", "an array with unique items"]);
              } else
                e2.addError("KEYWORD_VALUE_TYPE", ["dependencies", "object or array"]);
            }
        }, enum: function(e2, t2) {
          false === Array.isArray(t2.enum) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["enum", "array"]) : 0 === t2.enum.length ? e2.addError("KEYWORD_MUST_BE", ["enum", "an array with at least one element"]) : false === p.isUniqueArray(t2.enum) && e2.addError("KEYWORD_MUST_BE", ["enum", "an array with unique elements"]);
        }, type: function(e2, t2) {
          var r2 = ["array", "boolean", "integer", "number", "null", "object", "string"], i = r2.join(","), n = Array.isArray(t2.type);
          if (n) {
            for (var a = t2.type.length; a--; )
              -1 === r2.indexOf(t2.type[a]) && e2.addError("KEYWORD_TYPE_EXPECTED", ["type", i]);
            false === p.isUniqueArray(t2.type) && e2.addError("KEYWORD_MUST_BE", ["type", "an object with unique properties"]);
          } else
            "string" == typeof t2.type ? -1 === r2.indexOf(t2.type) && e2.addError("KEYWORD_TYPE_EXPECTED", ["type", i]) : e2.addError("KEYWORD_TYPE_EXPECTED", ["type", ["string", "array"]]);
          true === this.options.noEmptyStrings && ("string" === t2.type || n && -1 !== t2.type.indexOf("string")) && void 0 === t2.minLength && void 0 === t2.enum && void 0 === t2.format && (t2.minLength = 1), true === this.options.noEmptyArrays && ("array" === t2.type || n && -1 !== t2.type.indexOf("array")) && void 0 === t2.minItems && (t2.minItems = 1), true === this.options.forceProperties && ("object" === t2.type || n && -1 !== t2.type.indexOf("object")) && void 0 === t2.properties && void 0 === t2.patternProperties && e2.addError("KEYWORD_UNDEFINED_STRICT", ["properties"]), true === this.options.forceItems && ("array" === t2.type || n && -1 !== t2.type.indexOf("array")) && void 0 === t2.items && e2.addError("KEYWORD_UNDEFINED_STRICT", ["items"]), true === this.options.forceMinItems && ("array" === t2.type || n && -1 !== t2.type.indexOf("array")) && void 0 === t2.minItems && e2.addError("KEYWORD_UNDEFINED_STRICT", ["minItems"]), true === this.options.forceMaxItems && ("array" === t2.type || n && -1 !== t2.type.indexOf("array")) && void 0 === t2.maxItems && e2.addError("KEYWORD_UNDEFINED_STRICT", ["maxItems"]), true === this.options.forceMinLength && ("string" === t2.type || n && -1 !== t2.type.indexOf("string")) && void 0 === t2.minLength && void 0 === t2.format && void 0 === t2.enum && void 0 === t2.pattern && e2.addError("KEYWORD_UNDEFINED_STRICT", ["minLength"]), true === this.options.forceMaxLength && ("string" === t2.type || n && -1 !== t2.type.indexOf("string")) && void 0 === t2.maxLength && void 0 === t2.format && void 0 === t2.enum && void 0 === t2.pattern && e2.addError("KEYWORD_UNDEFINED_STRICT", ["maxLength"]);
        }, allOf: function(e2, t2) {
          if (false === Array.isArray(t2.allOf))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["allOf", "array"]);
          else if (0 === t2.allOf.length)
            e2.addError("KEYWORD_MUST_BE", ["allOf", "an array with at least one element"]);
          else
            for (var r2 = t2.allOf.length; r2--; )
              e2.path.push("allOf"), e2.path.push(r2.toString()), d.validateSchema.call(this, e2, t2.allOf[r2]), e2.path.pop(), e2.path.pop();
        }, anyOf: function(e2, t2) {
          if (false === Array.isArray(t2.anyOf))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["anyOf", "array"]);
          else if (0 === t2.anyOf.length)
            e2.addError("KEYWORD_MUST_BE", ["anyOf", "an array with at least one element"]);
          else
            for (var r2 = t2.anyOf.length; r2--; )
              e2.path.push("anyOf"), e2.path.push(r2.toString()), d.validateSchema.call(this, e2, t2.anyOf[r2]), e2.path.pop(), e2.path.pop();
        }, oneOf: function(e2, t2) {
          if (false === Array.isArray(t2.oneOf))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["oneOf", "array"]);
          else if (0 === t2.oneOf.length)
            e2.addError("KEYWORD_MUST_BE", ["oneOf", "an array with at least one element"]);
          else
            for (var r2 = t2.oneOf.length; r2--; )
              e2.path.push("oneOf"), e2.path.push(r2.toString()), d.validateSchema.call(this, e2, t2.oneOf[r2]), e2.path.pop(), e2.path.pop();
        }, not: function(e2, t2) {
          "object" !== p.whatIs(t2.not) ? e2.addError("KEYWORD_TYPE_EXPECTED", ["not", "object"]) : (e2.path.push("not"), d.validateSchema.call(this, e2, t2.not), e2.path.pop());
        }, definitions: function(e2, t2) {
          if ("object" !== p.whatIs(t2.definitions))
            e2.addError("KEYWORD_TYPE_EXPECTED", ["definitions", "object"]);
          else
            for (var r2 = Object.keys(t2.definitions), i = r2.length; i--; ) {
              var n = r2[i], a = t2.definitions[n];
              e2.path.push("definitions"), e2.path.push(n), d.validateSchema.call(this, e2, a), e2.path.pop(), e2.path.pop();
            }
        }, format: function(e2, t2) {
          "string" != typeof t2.format ? e2.addError("KEYWORD_TYPE_EXPECTED", ["format", "string"]) : void 0 === r[t2.format] && true !== this.options.ignoreUnknownFormats && e2.addError("UNKNOWN_FORMAT", [t2.format]);
        }, id: function(e2, t2) {
          "string" != typeof t2.id && e2.addError("KEYWORD_TYPE_EXPECTED", ["id", "string"]);
        }, title: function(e2, t2) {
          "string" != typeof t2.title && e2.addError("KEYWORD_TYPE_EXPECTED", ["title", "string"]);
        }, description: function(e2, t2) {
          "string" != typeof t2.description && e2.addError("KEYWORD_TYPE_EXPECTED", ["description", "string"]);
        }, default: function() {
        } };
        d.validateSchema = function(e2, t2) {
          if (e2.commonErrorMessage = "SCHEMA_VALIDATION_FAILED", Array.isArray(t2))
            return function(e3, t3) {
              for (var r3 = t3.length; r3--; )
                d.validateSchema.call(this, e3, t3[r3]);
              return e3.isValid();
            }.call(this, e2, t2);
          if (t2.__$validated)
            return true;
          var r2 = t2.$schema && t2.id !== t2.$schema;
          if (r2)
            if (t2.__$schemaResolved && t2.__$schemaResolved !== t2) {
              var i = new c(e2);
              false === f.validate.call(this, i, t2.__$schemaResolved, t2) && e2.addError("PARENT_SCHEMA_VALIDATION_FAILED", null, i);
            } else
              true !== this.options.ignoreUnresolvableReferences && e2.addError("REF_UNRESOLVED", [t2.$schema]);
          if (true === this.options.noTypeless) {
            if (void 0 !== t2.type) {
              var n = [];
              Array.isArray(t2.anyOf) && (n = n.concat(t2.anyOf)), Array.isArray(t2.oneOf) && (n = n.concat(t2.oneOf)), Array.isArray(t2.allOf) && (n = n.concat(t2.allOf)), n.forEach(function(e3) {
                e3.type || (e3.type = t2.type);
              });
            }
            void 0 === t2.enum && void 0 === t2.type && void 0 === t2.anyOf && void 0 === t2.oneOf && void 0 === t2.not && void 0 === t2.$ref && e2.addError("KEYWORD_UNDEFINED_STRICT", ["type"]);
          }
          for (var a = Object.keys(t2), o = a.length; o--; ) {
            var s = a[o];
            0 !== s.indexOf("__") && (void 0 !== h[s] ? h[s].call(this, e2, t2) : r2 || true === this.options.noExtraKeywords && e2.addError("KEYWORD_UNEXPECTED", [s]));
          }
          if (true === this.options.pedanticCheck) {
            if (t2.enum) {
              var l = p.clone(t2);
              for (delete l.enum, delete l.default, e2.path.push("enum"), o = t2.enum.length; o--; )
                e2.path.push(o.toString()), f.validate.call(this, e2, l, t2.enum[o]), e2.path.pop();
              e2.path.pop();
            }
            t2.default && (e2.path.push("default"), f.validate.call(this, e2, t2, t2.default), e2.path.pop());
          }
          var u = e2.isValid();
          return u && (t2.__$validated = true), u;
        };
      }, { "./FormatValidators": 106, "./JsonValidation": 107, "./Report": 109, "./Utils": 113 }], 113: [function(e, t, l) {
        "use strict";
        l.jsonSymbol = Symbol.for("z-schema/json"), l.schemaSymbol = Symbol.for("z-schema/schema");
        var u = l.sortedKeys = function(e2) {
          return Object.keys(e2).sort();
        };
        l.isAbsoluteUri = function(e2) {
          return /^https?:\/\//.test(e2);
        }, l.isRelativeUri = function(e2) {
          return /.+#/.test(e2);
        }, l.whatIs = function(e2) {
          var t2 = typeof e2;
          return "object" === t2 ? null === e2 ? "null" : Array.isArray(e2) ? "array" : "object" : "number" === t2 ? Number.isFinite(e2) ? e2 % 1 == 0 ? "integer" : "number" : Number.isNaN(e2) ? "not-a-number" : "unknown-number" : t2;
        }, l.areEqual = function e2(t2, r, i) {
          var n, a, o = (i = i || {}).caseInsensitiveComparison || false;
          if (t2 === r)
            return true;
          if (true === o && "string" == typeof t2 && "string" == typeof r && t2.toUpperCase() === r.toUpperCase())
            return true;
          if (Array.isArray(t2) && Array.isArray(r)) {
            if (t2.length !== r.length)
              return false;
            for (a = t2.length, n = 0; n < a; n++)
              if (!e2(t2[n], r[n], { caseInsensitiveComparison: o }))
                return false;
            return true;
          }
          if ("object" !== l.whatIs(t2) || "object" !== l.whatIs(r))
            return false;
          var s = u(t2);
          if (!e2(s, u(r), { caseInsensitiveComparison: o }))
            return false;
          for (a = s.length, n = 0; n < a; n++)
            if (!e2(t2[s[n]], r[s[n]], { caseInsensitiveComparison: o }))
              return false;
          return true;
        }, l.isUniqueArray = function(e2, t2) {
          var r, i, n = e2.length;
          for (r = 0; r < n; r++)
            for (i = r + 1; i < n; i++)
              if (l.areEqual(e2[r], e2[i]))
                return t2 && t2.push(r, i), false;
          return true;
        }, l.difference = function(e2, t2) {
          for (var r = [], i = e2.length; i--; )
            -1 === t2.indexOf(e2[i]) && r.push(e2[i]);
          return r;
        }, l.clone = function(e2) {
          if (void 0 !== e2) {
            if ("object" != typeof e2 || null === e2)
              return e2;
            var t2, r;
            if (Array.isArray(e2))
              for (t2 = [], r = e2.length; r--; )
                t2[r] = e2[r];
            else {
              t2 = {};
              var i = Object.keys(e2);
              for (r = i.length; r--; ) {
                var n = i[r];
                t2[n] = e2[n];
              }
            }
            return t2;
          }
        }, l.cloneDeep = function(e2) {
          var s = 0, l2 = /* @__PURE__ */ new Map(), u2 = [];
          return function e3(t2) {
            if ("object" != typeof t2 || null === t2)
              return t2;
            var r, i, n;
            if (void 0 !== (n = l2.get(t2)))
              return u2[n];
            if (l2.set(t2, s++), Array.isArray(t2))
              for (r = [], u2.push(r), i = t2.length; i--; )
                r[i] = e3(t2[i]);
            else {
              r = {}, u2.push(r);
              var a = Object.keys(t2);
              for (i = a.length; i--; ) {
                var o = a[i];
                r[o] = e3(t2[o]);
              }
            }
            return r;
          }(e2);
        }, l.ucs2decode = function(e2) {
          for (var t2, r, i = [], n = 0, a = e2.length; n < a; )
            55296 <= (t2 = e2.charCodeAt(n++)) && t2 <= 56319 && n < a ? 56320 == (64512 & (r = e2.charCodeAt(n++))) ? i.push(((1023 & t2) << 10) + (1023 & r) + 65536) : (i.push(t2), n--) : i.push(t2);
          return i;
        };
      }, {}], 114: [function(e, s, t) {
        (function(g) {
          (function() {
            "use strict";
            e("./Polyfills");
            var f = e("lodash.get"), c = e("./Report"), r = e("./FormatValidators"), p = e("./JsonValidation"), h = e("./SchemaCache"), m = e("./SchemaCompilation"), v = e("./SchemaValidation"), _ = e("./Utils"), i = e("./schemas/schema.json"), n = e("./schemas/hyper-schema.json"), a = { asyncTimeout: 2e3, forceAdditional: false, assumeAdditional: false, enumCaseInsensitiveComparison: false, forceItems: false, forceMinItems: false, forceMaxItems: false, forceMinLength: false, forceMaxLength: false, forceProperties: false, ignoreUnresolvableReferences: false, noExtraKeywords: false, noTypeless: false, noEmptyStrings: false, noEmptyArrays: false, strictUris: false, strictMode: false, reportPathAsArray: false, breakOnFirstError: false, pedanticCheck: false, ignoreUnknownFormats: false, customValidator: null };
            function o(e2) {
              var t3;
              if ("object" == typeof e2) {
                for (var r2, i2 = Object.keys(e2), n2 = i2.length; n2--; )
                  if (r2 = i2[n2], void 0 === a[r2])
                    throw new Error("Unexpected option passed to constructor: " + r2);
                for (n2 = (i2 = Object.keys(a)).length; n2--; )
                  void 0 === e2[r2 = i2[n2]] && (e2[r2] = _.clone(a[r2]));
                t3 = e2;
              } else
                t3 = _.clone(a);
              return true === t3.strictMode && (t3.forceAdditional = true, t3.forceItems = true, t3.forceMaxLength = true, t3.forceProperties = true, t3.noExtraKeywords = true, t3.noTypeless = true, t3.noEmptyStrings = true, t3.noEmptyArrays = true), t3;
            }
            function t2(e2) {
              this.cache = {}, this.referenceCache = [], this.validateOptions = {}, this.options = o(e2);
              var t3 = o({});
              this.setRemoteReference("http://json-schema.org/draft-04/schema", i, t3), this.setRemoteReference("http://json-schema.org/draft-04/hyper-schema", n, t3);
            }
            t2.prototype.compileSchema = function(e2) {
              var t3 = new c(this.options);
              return e2 = h.getSchema.call(this, t3, e2), m.compileSchema.call(this, t3, e2), (this.lastReport = t3).isValid();
            }, t2.prototype.validateSchema = function(e2) {
              if (Array.isArray(e2) && 0 === e2.length)
                throw new Error(".validateSchema was called with an empty array");
              var t3 = new c(this.options);
              return e2 = h.getSchema.call(this, t3, e2), m.compileSchema.call(this, t3, e2) && v.validateSchema.call(this, t3, e2), (this.lastReport = t3).isValid();
            }, t2.prototype.validate = function(e2, t3, r2, i2) {
              "function" === _.whatIs(r2) && (i2 = r2, r2 = {}), r2 || (r2 = {}), this.validateOptions = r2;
              var n2 = _.whatIs(t3);
              if ("string" !== n2 && "object" !== n2) {
                var a2 = new Error("Invalid .validate call - schema must be a string or object but " + n2 + " was passed!");
                if (i2)
                  return void g.nextTick(function() {
                    i2(a2, false);
                  });
                throw a2;
              }
              var o2 = false, s2 = new c(this.options);
              if (s2.json = e2, "string" == typeof t3) {
                var l = t3;
                if (!(t3 = h.getSchema.call(this, s2, l)))
                  throw new Error("Schema with id '" + l + "' wasn't found in the validator cache!");
              } else
                t3 = h.getSchema.call(this, s2, t3);
              var u = false;
              o2 || (u = m.compileSchema.call(this, s2, t3)), u || (this.lastReport = s2, o2 = true);
              var d = false;
              if (o2 || (d = v.validateSchema.call(this, s2, t3)), d || (this.lastReport = s2, o2 = true), r2.schemaPath && (s2.rootSchema = t3, !(t3 = f(t3, r2.schemaPath))))
                throw new Error("Schema path '" + r2.schemaPath + "' wasn't found in the schema!");
              if (o2 || p.validate.call(this, s2, t3, e2), !i2) {
                if (0 < s2.asyncTasks.length)
                  throw new Error("This validation has async tasks and cannot be done in sync mode, please provide callback argument.");
                return (this.lastReport = s2).isValid();
              }
              s2.processAsyncTasks(this.options.asyncTimeout, i2);
            }, t2.prototype.getLastError = function() {
              if (0 === this.lastReport.errors.length)
                return null;
              var e2 = new Error();
              return e2.name = "z-schema validation error", e2.message = this.lastReport.commonErrorMessage, e2.details = this.lastReport.errors, e2;
            }, t2.prototype.getLastErrors = function() {
              return this.lastReport && 0 < this.lastReport.errors.length ? this.lastReport.errors : null;
            }, t2.prototype.getMissingReferences = function(e2) {
              for (var t3 = [], r2 = (e2 = e2 || this.lastReport.errors).length; r2--; ) {
                var i2 = e2[r2];
                if ("UNRESOLVABLE_REFERENCE" === i2.code) {
                  var n2 = i2.params[0];
                  -1 === t3.indexOf(n2) && t3.push(n2);
                }
                i2.inner && (t3 = t3.concat(this.getMissingReferences(i2.inner)));
              }
              return t3;
            }, t2.prototype.getMissingRemoteReferences = function() {
              for (var e2 = this.getMissingReferences(), t3 = [], r2 = e2.length; r2--; ) {
                var i2 = h.getRemotePath(e2[r2]);
                i2 && -1 === t3.indexOf(i2) && t3.push(i2);
              }
              return t3;
            }, t2.prototype.setRemoteReference = function(e2, t3, r2) {
              t3 = "string" == typeof t3 ? JSON.parse(t3) : _.cloneDeep(t3), r2 && (t3.__$validationOptions = o(r2)), h.cacheSchemaByUri.call(this, e2, t3);
            }, t2.prototype.getResolvedSchema = function(e2) {
              var t3 = new c(this.options);
              e2 = h.getSchema.call(this, t3, e2), e2 = _.cloneDeep(e2);
              var a2 = [], o2 = function(e3) {
                var t4, r2 = _.whatIs(e3);
                if (("object" === r2 || "array" === r2) && !e3.___$visited) {
                  if (e3.___$visited = true, a2.push(e3), e3.$ref && e3.__$refResolved) {
                    var i2 = e3.__$refResolved, n2 = e3;
                    for (t4 in delete e3.$ref, delete e3.__$refResolved, i2)
                      i2.hasOwnProperty(t4) && (n2[t4] = i2[t4]);
                  }
                  for (t4 in e3)
                    e3.hasOwnProperty(t4) && (0 === t4.indexOf("__$") ? delete e3[t4] : o2(e3[t4]));
                }
              };
              if (o2(e2), a2.forEach(function(e3) {
                delete e3.___$visited;
              }), (this.lastReport = t3).isValid())
                return e2;
              throw this.getLastError();
            }, t2.prototype.setSchemaReader = function(e2) {
              return t2.setSchemaReader(e2);
            }, t2.prototype.getSchemaReader = function() {
              return t2.schemaReader;
            }, t2.schemaReader = void 0, t2.setSchemaReader = function(e2) {
              t2.schemaReader = e2;
            }, t2.registerFormat = function(e2, t3) {
              r[e2] = t3;
            }, t2.unregisterFormat = function(e2) {
              delete r[e2];
            }, t2.getRegisteredFormats = function() {
              return Object.keys(r);
            }, t2.getDefaultOptions = function() {
              return _.cloneDeep(a);
            }, t2.schemaSymbol = _.schemaSymbol, t2.jsonSymbol = _.jsonSymbol, s.exports = t2;
          }).call(this);
        }).call(this, e("_process"));
      }, { "./FormatValidators": 106, "./JsonValidation": 107, "./Polyfills": 108, "./Report": 109, "./SchemaCache": 110, "./SchemaCompilation": 111, "./SchemaValidation": 112, "./Utils": 113, "./schemas/hyper-schema.json": 115, "./schemas/schema.json": 116, _process: 3, "lodash.get": 1 }], 115: [function(e, t, r) {
        t.exports = { $schema: "http://json-schema.org/draft-04/hyper-schema#", id: "http://json-schema.org/draft-04/hyper-schema#", title: "JSON Hyper-Schema", allOf: [{ $ref: "http://json-schema.org/draft-04/schema#" }], properties: { additionalItems: { anyOf: [{ type: "boolean" }, { $ref: "#" }] }, additionalProperties: { anyOf: [{ type: "boolean" }, { $ref: "#" }] }, dependencies: { additionalProperties: { anyOf: [{ $ref: "#" }, { type: "array" }] } }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }] }, definitions: { additionalProperties: { $ref: "#" } }, patternProperties: { additionalProperties: { $ref: "#" } }, properties: { additionalProperties: { $ref: "#" } }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" }, links: { type: "array", items: { $ref: "#/definitions/linkDescription" } }, fragmentResolution: { type: "string" }, media: { type: "object", properties: { type: { description: "A media type, as described in RFC 2046", type: "string" }, binaryEncoding: { description: "A content encoding scheme, as described in RFC 2045", type: "string" } } }, pathStart: { description: "Instances' URIs must start with this value for this schema to apply to them", type: "string", format: "uri" } }, definitions: { schemaArray: { type: "array", items: { $ref: "#" } }, linkDescription: { title: "Link Description Object", type: "object", required: ["href", "rel"], properties: { href: { description: "a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing", type: "string" }, rel: { description: "relation to the target resource of the link", type: "string" }, title: { description: "a title for the link", type: "string" }, targetSchema: { description: "JSON Schema describing the link target", $ref: "#" }, mediaType: { description: "media type (as defined by RFC 2046) describing the link target", type: "string" }, method: { description: 'method for requesting the target of the link (e.g. for HTTP this might be "GET" or "DELETE")', type: "string" }, encType: { description: "The media type in which to submit data along with the request", type: "string", default: "application/json" }, schema: { description: "Schema describing the data to submit along with the request", $ref: "#" } } } } };
      }, {}], 116: [function(e, t, r) {
        t.exports = { id: "http://json-schema.org/draft-04/schema#", $schema: "http://json-schema.org/draft-04/schema#", description: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, positiveInteger: { type: "integer", minimum: 0 }, positiveIntegerDefault0: { allOf: [{ $ref: "#/definitions/positiveInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, minItems: 1, uniqueItems: true } }, type: "object", properties: { id: { type: "string", format: "uri" }, $schema: { type: "string", format: "uri" }, title: { type: "string" }, description: { type: "string" }, default: {}, multipleOf: { type: "number", minimum: 0, exclusiveMinimum: true }, maximum: { type: "number" }, exclusiveMaximum: { type: "boolean", default: false }, minimum: { type: "number" }, exclusiveMinimum: { type: "boolean", default: false }, maxLength: { $ref: "#/definitions/positiveInteger" }, minLength: { $ref: "#/definitions/positiveIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { anyOf: [{ type: "boolean" }, { $ref: "#" }], default: {} }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: {} }, maxItems: { $ref: "#/definitions/positiveInteger" }, minItems: { $ref: "#/definitions/positiveIntegerDefault0" }, uniqueItems: { type: "boolean", default: false }, maxProperties: { $ref: "#/definitions/positiveInteger" }, minProperties: { $ref: "#/definitions/positiveIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { anyOf: [{ type: "boolean" }, { $ref: "#" }], default: {} }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, enum: { type: "array", minItems: 1, uniqueItems: true }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: true }] }, format: { type: "string" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, dependencies: { exclusiveMaximum: ["maximum"], exclusiveMinimum: ["minimum"] }, default: {} };
      }, {}] }, {}, [105, 106, 107, 108, 109, 110, 111, 112, 113, 114])(114);
    });
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/JsonSchema.js
var require_JsonSchema = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/JsonSchema.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JsonSchema = void 0;
    var os = __importStar(require("os"));
    var path = __importStar(require("path"));
    var JsonFile_1 = require_JsonFile();
    var FileSystem_1 = require_FileSystem();
    var Validator = require_ZSchema_browser_min();
    var JsonSchema = class _JsonSchema {
      constructor() {
        this._dependentSchemas = [];
        this._filename = "";
        this._validator = void 0;
        this._schemaObject = void 0;
      }
      /**
       * Registers a JsonSchema that will be loaded from a file on disk.
       * @remarks
       * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
       * until it the schema is actually used.
       */
      static fromFile(filename, options) {
        if (!FileSystem_1.FileSystem.exists(filename)) {
          throw new Error("Schema file not found: " + filename);
        }
        const schema = new _JsonSchema();
        schema._filename = filename;
        if (options) {
          schema._dependentSchemas = options.dependentSchemas || [];
        }
        return schema;
      }
      /**
       * Registers a JsonSchema that will be loaded from a file on disk.
       * @remarks
       * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
       * until it the schema is actually used.
       */
      static fromLoadedObject(schemaObject) {
        const schema = new _JsonSchema();
        schema._schemaObject = schemaObject;
        return schema;
      }
      static _collectDependentSchemas(collectedSchemas, dependentSchemas, seenObjects, seenIds) {
        for (const dependentSchema of dependentSchemas) {
          if (seenObjects.has(dependentSchema)) {
            continue;
          }
          seenObjects.add(dependentSchema);
          const schemaId = dependentSchema._ensureLoaded();
          if (schemaId === "") {
            throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced because is missing the "id" field`);
          }
          if (seenIds.has(schemaId)) {
            throw new Error(`This schema ${dependentSchema.shortName} has the same "id" as another schema in this set`);
          }
          seenIds.add(schemaId);
          collectedSchemas.push(dependentSchema);
          _JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas, seenObjects, seenIds);
        }
      }
      /**
       * Used to nicely format the ZSchema error tree.
       */
      static _formatErrorDetails(errorDetails) {
        return _JsonSchema._formatErrorDetailsHelper(errorDetails, "", "");
      }
      /**
       * Used by _formatErrorDetails.
       */
      static _formatErrorDetailsHelper(errorDetails, indent, buffer) {
        for (const errorDetail of errorDetails) {
          buffer += os.EOL + indent + `Error: ${errorDetail.path}`;
          if (errorDetail.description) {
            const MAX_LENGTH = 40;
            let truncatedDescription = errorDetail.description.trim();
            if (truncatedDescription.length > MAX_LENGTH) {
              truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3) + "...";
            }
            buffer += ` (${truncatedDescription})`;
          }
          buffer += os.EOL + indent + `       ${errorDetail.message}`;
          if (errorDetail.inner) {
            buffer = _JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + "  ", buffer);
          }
        }
        return buffer;
      }
      /**
       * Returns a short name for this schema, for use in error messages.
       * @remarks
       * If the schema was loaded from a file, then the base filename is used.  Otherwise, the "id"
       * field is used if available.
       */
      get shortName() {
        if (!this._filename) {
          if (this._schemaObject) {
            const schemaWithId = this._schemaObject;
            if (schemaWithId.id) {
              return schemaWithId.id;
            }
          }
          return "(anonymous schema)";
        } else {
          return path.basename(this._filename);
        }
      }
      /**
       * If not already done, this loads the schema from disk and compiles it.
       * @remarks
       * Any dependencies will be compiled as well.
       */
      ensureCompiled() {
        this._ensureLoaded();
        if (!this._validator) {
          const newValidator = new Validator({
            breakOnFirstError: false,
            noTypeless: true,
            noExtraKeywords: true
          });
          const anythingSchema = {
            type: ["array", "boolean", "integer", "number", "object", "string"]
          };
          newValidator.setRemoteReference("http://json-schema.org/draft-04/schema", anythingSchema);
          const collectedSchemas = [];
          const seenObjects = /* @__PURE__ */ new Set();
          const seenIds = /* @__PURE__ */ new Set();
          _JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);
          for (const collectedSchema of collectedSchemas) {
            if (!newValidator.validateSchema(collectedSchema._schemaObject)) {
              throw new Error(`Failed to validate schema "${collectedSchema.shortName}":` + os.EOL + _JsonSchema._formatErrorDetails(newValidator.getLastErrors()));
            }
          }
          this._validator = newValidator;
        }
      }
      /**
       * Validates the specified JSON object against this JSON schema.  If the validation fails,
       * an exception will be thrown.
       * @param jsonObject - The JSON data to be validated
       * @param filenameForErrors - The filename that the JSON data was available, or an empty string
       *    if not applicable
       * @param options - Other options that control the validation
       */
      validateObject(jsonObject, filenameForErrors, options) {
        this.validateObjectWithCallback(jsonObject, (errorInfo) => {
          const prefix = options && options.customErrorHeader ? options.customErrorHeader : "JSON validation failed:";
          throw new Error(prefix + os.EOL + filenameForErrors + os.EOL + errorInfo.details);
        });
      }
      /**
       * Validates the specified JSON object against this JSON schema.  If the validation fails,
       * a callback is called for each validation error.
       */
      validateObjectWithCallback(jsonObject, errorCallback) {
        this.ensureCompiled();
        if (!this._validator.validate(jsonObject, this._schemaObject)) {
          const errorDetails = _JsonSchema._formatErrorDetails(this._validator.getLastErrors());
          const args2 = {
            details: errorDetails
          };
          errorCallback(args2);
        }
      }
      _ensureLoaded() {
        if (!this._schemaObject) {
          this._schemaObject = JsonFile_1.JsonFile.load(this._filename);
        }
        return this._schemaObject.id || "";
      }
    };
    exports2.JsonSchema = JsonSchema;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/FileWriter.js
var require_FileWriter = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/FileWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileWriter = void 0;
    var Import_1 = require_Import();
    var fsx = Import_1.Import.lazy("fs-extra", require);
    var FileWriter = class _FileWriter {
      constructor(fileDescriptor, filePath) {
        this._fileDescriptor = fileDescriptor;
        this.filePath = filePath;
      }
      /**
       * Opens a new file handle to the file at the specified path and given mode.
       * Behind the scenes it uses `fs.openSync()`.
       * The behaviour of this function is platform specific.
       * See: https://nodejs.org/docs/latest-v8.x/api/fs.html#fs_fs_open_path_flags_mode_callback
       * @param filePath - The absolute or relative path to the file handle that should be opened.
       * @param flags - The flags for opening the handle
       */
      static open(filePath, flags) {
        return new _FileWriter(fsx.openSync(filePath, _FileWriter._convertFlagsForNode(flags)), filePath);
      }
      /**
       * Helper function to convert the file writer array to a Node.js style string (e.g. "wx" or "a").
       * @param flags - The flags that should be converted.
       */
      static _convertFlagsForNode(flags) {
        flags = Object.assign({ append: false, exclusive: false }, flags);
        return [flags.append ? "a" : "w", flags.exclusive ? "x" : ""].join("");
      }
      /**
       * Writes some text to the given file handle. Throws if the file handle has been closed.
       * Behind the scenes it uses `fs.writeSync()`.
       * @param text - The text to write to the file.
       */
      write(text) {
        if (!this._fileDescriptor) {
          throw new Error(`Cannot write to file, file descriptor has already been released.`);
        }
        fsx.writeSync(this._fileDescriptor, text);
      }
      /**
       * Closes the file handle permanently. No operations can be made on this file handle after calling this.
       * Behind the scenes it uses `fs.closeSync()` and releases the file descriptor to be re-used.
       *
       * @remarks
       * The `close()` method can be called more than once; additional calls are ignored.
       */
      close() {
        const fd = this._fileDescriptor;
        if (fd) {
          this._fileDescriptor = void 0;
          fsx.closeSync(fd);
        }
      }
      /**
       * Gets the statistics for the given file handle. Throws if the file handle has been closed.
       * Behind the scenes it uses `fs.statSync()`.
       */
      getStatistics() {
        if (!this._fileDescriptor) {
          throw new Error(`Cannot get file statistics, file descriptor has already been released.`);
        }
        return fsx.fstatSync(this._fileDescriptor);
      }
    };
    exports2.FileWriter = FileWriter;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/LockFile.js
var require_LockFile = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/LockFile.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LockFile = exports2.getProcessStartTime = exports2.getProcessStartTimeFromProcStat = void 0;
    var path = __importStar(require("path"));
    var child_process = __importStar(require("child_process"));
    var FileSystem_1 = require_FileSystem();
    var FileWriter_1 = require_FileWriter();
    var Async_1 = require_Async();
    var procStatStartTimePos = 22;
    function getProcessStartTimeFromProcStat(stat) {
      let values = stat.trimRight().split(" ");
      let i = values.length - 1;
      while (i >= 0 && // charAt returns an empty string if the index is out of bounds.
      values[i].charAt(values[i].length - 1) !== ")") {
        i -= 1;
      }
      if (i < 1) {
        return void 0;
      }
      const value2 = values.slice(1, i + 1).join(" ");
      values = [values[0], value2].concat(values.slice(i + 1));
      if (values.length < procStatStartTimePos) {
        return void 0;
      }
      const startTimeJiffies = values[procStatStartTimePos - 1];
      return startTimeJiffies;
    }
    exports2.getProcessStartTimeFromProcStat = getProcessStartTimeFromProcStat;
    function getProcessStartTime(pid) {
      const pidString = pid.toString();
      if (pid < 0 || pidString.indexOf("e") >= 0 || pidString.indexOf("E") >= 0) {
        throw new Error(`"pid" is negative or too large`);
      }
      let args2;
      if (process.platform === "darwin") {
        args2 = [`-p ${pidString}`, "-o lstart"];
      } else if (process.platform === "linux") {
        args2 = ["-p", pidString, "-o", "lstart"];
      } else {
        throw new Error(`Unsupported system: ${process.platform}`);
      }
      const psResult = child_process.spawnSync("ps", args2, {
        encoding: "utf8"
      });
      const psStdout = psResult.stdout;
      if (psResult.status !== 0 && !psStdout && process.platform === "linux") {
        let stat;
        try {
          stat = FileSystem_1.FileSystem.readFile(`/proc/${pidString}/stat`);
        } catch (error) {
          if (error.code !== "ENOENT") {
            throw error;
          }
          return void 0;
        }
        if (stat !== void 0) {
          const startTimeJiffies = getProcessStartTimeFromProcStat(stat);
          if (startTimeJiffies === void 0) {
            throw new Error(`Could not retrieve the start time of process ${pidString} from the OS because the contents of /proc/${pidString}/stat have an unexpected format`);
          }
          return startTimeJiffies;
        }
      }
      if (!psStdout) {
        throw new Error(`Unexpected output from "ps" command`);
      }
      const psSplit = psStdout.split("\n");
      if (psSplit[1] === "") {
        return void 0;
      }
      if (psSplit[1]) {
        const trimmed = psSplit[1].trim();
        if (trimmed.length > 10) {
          return trimmed;
        }
      }
      throw new Error(`Unexpected output from the "ps" command`);
    }
    exports2.getProcessStartTime = getProcessStartTime;
    var LockFile = class _LockFile {
      constructor(fileWriter, filePath, dirtyWhenAcquired) {
        this._fileWriter = fileWriter;
        this._filePath = filePath;
        this._dirtyWhenAcquired = dirtyWhenAcquired;
      }
      /**
       * Returns the path of the lockfile that will be created when a lock is successfully acquired.
       * @param resourceFolder - The folder where the lock file will be created
       * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
       *   the filename of the temporary file created to manage the lock.
       * @param pid - The PID for the current Node.js process (`process.pid`), which is used by the locking algorithm.
       */
      static getLockFilePath(resourceFolder, resourceName, pid = process.pid) {
        if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {
          throw new Error(`The resource name "${resourceName}" is invalid. It must be an alphanumberic string with only "-" or "." It must start with an alphanumeric character.`);
        }
        if (process.platform === "win32") {
          return path.join(path.resolve(resourceFolder), `${resourceName}.lock`);
        } else if (process.platform === "linux" || process.platform === "darwin") {
          return path.join(path.resolve(resourceFolder), `${resourceName}#${pid}.lock`);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
      }
      /**
       * Attempts to create a lockfile with the given filePath.
       * @param resourceFolder - The folder where the lock file will be created
       * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
       *   the filename of the temporary file created to manage the lock.
       * @returns If successful, returns a `LockFile` instance.  If unable to get a lock, returns `undefined`.
       */
      static tryAcquire(resourceFolder, resourceName) {
        FileSystem_1.FileSystem.ensureFolder(resourceFolder);
        if (process.platform === "win32") {
          return _LockFile._tryAcquireWindows(resourceFolder, resourceName);
        } else if (process.platform === "linux" || process.platform === "darwin") {
          return _LockFile._tryAcquireMacOrLinux(resourceFolder, resourceName);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
      }
      /**
       * Attempts to create the lockfile.  Will continue to loop at every 100ms until the lock becomes available
       * or the maxWaitMs is surpassed.
       *
       * @remarks
       * This function is subject to starvation, whereby it does not ensure that the process that has been
       * waiting the longest to acquire the lock will get it first. This means that a process could theoretically
       * wait for the lock forever, while other processes skipped it in line and acquired the lock first.
       *
       * @param resourceFolder - The folder where the lock file will be created
       * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
       *   the filename of the temporary file created to manage the lock.
       * @param maxWaitMs - The maximum number of milliseconds to wait for the lock before reporting an error
       */
      static acquire(resourceFolder, resourceName, maxWaitMs) {
        const interval = 100;
        const startTime = Date.now();
        const retryLoop = async () => {
          const lock = _LockFile.tryAcquire(resourceFolder, resourceName);
          if (lock) {
            return lock;
          }
          if (maxWaitMs && Date.now() > startTime + maxWaitMs) {
            throw new Error(`Exceeded maximum wait time to acquire lock for resource "${resourceName}"`);
          }
          await Async_1.Async.sleepAsync(interval);
          return retryLoop();
        };
        return retryLoop();
      }
      /**
       * Attempts to acquire the lock on a Linux or OSX machine
       */
      static _tryAcquireMacOrLinux(resourceFolder, resourceName) {
        let dirtyWhenAcquired = false;
        const pid = process.pid;
        const startTime = _LockFile._getStartTime(pid);
        if (!startTime) {
          throw new Error(`Unable to calculate start time for current process.`);
        }
        const pidLockFilePath = _LockFile.getLockFilePath(resourceFolder, resourceName);
        let lockFileHandle;
        let lockFile;
        try {
          lockFileHandle = FileWriter_1.FileWriter.open(pidLockFilePath);
          lockFileHandle.write(startTime);
          const currentBirthTimeMs = lockFileHandle.getStatistics().birthtime.getTime();
          let smallestBirthTimeMs = currentBirthTimeMs;
          let smallestBirthTimePid = pid.toString();
          const files = FileSystem_1.FileSystem.readFolderItemNames(resourceFolder);
          const lockFileRegExp = /^(.+)#([0-9]+)\.lock$/;
          let match;
          let otherPid;
          for (const fileInFolder of files) {
            if ((match = fileInFolder.match(lockFileRegExp)) && match[1] === resourceName && (otherPid = match[2]) !== pid.toString()) {
              const fileInFolderPath = path.join(resourceFolder, fileInFolder);
              dirtyWhenAcquired = true;
              const otherPidCurrentStartTime = _LockFile._getStartTime(parseInt(otherPid, 10));
              let otherPidOldStartTime;
              let otherBirthtimeMs;
              try {
                otherPidOldStartTime = FileSystem_1.FileSystem.readFile(fileInFolderPath);
                otherBirthtimeMs = FileSystem_1.FileSystem.getStatistics(fileInFolderPath).birthtime.getTime();
              } catch (error) {
                if (FileSystem_1.FileSystem.isNotExistError(error)) {
                  continue;
                }
              }
              if (otherPidOldStartTime === "" && otherBirthtimeMs !== void 0) {
                if (otherBirthtimeMs > currentBirthTimeMs) {
                  continue;
                } else if (otherBirthtimeMs - currentBirthTimeMs < 0 && // it was created before us AND
                otherBirthtimeMs - currentBirthTimeMs > -1e3) {
                  return void 0;
                }
              }
              if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {
                FileSystem_1.FileSystem.deleteFile(fileInFolderPath);
                continue;
              }
              if (otherBirthtimeMs !== void 0) {
                if (otherBirthtimeMs < smallestBirthTimeMs || otherBirthtimeMs === smallestBirthTimeMs && otherPid < smallestBirthTimePid) {
                  smallestBirthTimeMs = otherBirthtimeMs;
                  smallestBirthTimePid = otherPid;
                }
              }
            }
          }
          if (smallestBirthTimePid !== pid.toString()) {
            return void 0;
          }
          lockFile = new _LockFile(lockFileHandle, pidLockFilePath, dirtyWhenAcquired);
          lockFileHandle = void 0;
        } finally {
          if (lockFileHandle) {
            lockFileHandle.close();
            FileSystem_1.FileSystem.deleteFile(pidLockFilePath);
          }
        }
        return lockFile;
      }
      /**
       * Attempts to acquire the lock using Windows
       * This algorithm is much simpler since we can rely on the operating system
       */
      static _tryAcquireWindows(resourceFolder, resourceName) {
        const lockFilePath = _LockFile.getLockFilePath(resourceFolder, resourceName);
        let dirtyWhenAcquired = false;
        let fileHandle;
        let lockFile;
        try {
          if (FileSystem_1.FileSystem.exists(lockFilePath)) {
            dirtyWhenAcquired = true;
            FileSystem_1.FileSystem.deleteFile(lockFilePath);
          }
          try {
            fileHandle = FileWriter_1.FileWriter.open(lockFilePath, { exclusive: true });
          } catch (error) {
            return void 0;
          }
          lockFile = new _LockFile(fileHandle, lockFilePath, dirtyWhenAcquired);
          fileHandle = void 0;
        } finally {
          if (fileHandle) {
            fileHandle.close();
          }
        }
        return lockFile;
      }
      /**
       * Unlocks a file and optionally removes it from disk.
       * This can only be called once.
       *
       * @param deleteFile - Whether to delete the lockfile from disk. Defaults to true.
       */
      release(deleteFile = true) {
        if (this.isReleased) {
          throw new Error(`The lock for file "${path.basename(this._filePath)}" has already been released.`);
        }
        this._fileWriter.close();
        if (deleteFile) {
          FileSystem_1.FileSystem.deleteFile(this._filePath);
        }
        this._fileWriter = void 0;
      }
      /**
       * Returns the initial state of the lock.
       * This can be used to detect if the previous process was terminated before releasing the resource.
       */
      get dirtyWhenAcquired() {
        return this._dirtyWhenAcquired;
      }
      /**
       * Returns the absolute path to the lockfile
       */
      get filePath() {
        return this._filePath;
      }
      /**
       * Returns true if this lock is currently being held.
       */
      get isReleased() {
        return this._fileWriter === void 0;
      }
    };
    exports2.LockFile = LockFile;
    LockFile._getStartTime = getProcessStartTime;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/MapExtensions.js
var require_MapExtensions = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/MapExtensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapExtensions = void 0;
    var MapExtensions = class {
      /**
       * Adds all the (key, value) pairs from the source map into the target map.
       * @remarks
       * This function modifies targetMap.  Any existing keys will be overwritten.
       * @param targetMap - The map that entries will be added to
       * @param sourceMap - The map containing the entries to be added
       */
      static mergeFromMap(targetMap, sourceMap) {
        for (const pair of sourceMap.entries()) {
          targetMap.set(pair[0], pair[1]);
        }
      }
      /**
       * Converts a string-keyed map to an object.
       * @remarks
       * This function has the same effect as Object.fromEntries(map.entries())
       * in supported versions of Node (\>= 12.0.0).
       * @param map - The map that the object properties will be sourced from
       */
      static toObject(map) {
        const object = {};
        for (const [key, value] of map.entries()) {
          object[key] = value;
        }
        return object;
      }
    };
    exports2.MapExtensions = MapExtensions;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/MinimumHeap.js
var require_MinimumHeap = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/MinimumHeap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MinimumHeap = void 0;
    var MinimumHeap = class {
      /**
       * Constructs a new MinimumHeap instance.
       * @param comparator - a comparator function that determines the order of the items in the heap.
       *   If the comparator returns a value less than zero, then `a` will be considered less than `b`.
       *   If the comparator returns zero, then `a` and `b` are considered equal.
       *   Otherwise, `a` will be considered greater than `b`.
       */
      constructor(comparator) {
        this._items = [];
        this._comparator = comparator;
      }
      /**
       * Returns the number of items in the heap.
       * @returns the number of items in the heap.
       */
      get size() {
        return this._items.length;
      }
      /**
       * Retrieves the root item from the heap without removing it.
       * @returns the root item, or `undefined` if the heap is empty
       */
      peek() {
        return this._items[0];
      }
      /**
       * Retrieves and removes the root item from the heap. The next smallest item will become the new root.
       * @returns the root item, or `undefined` if the heap is empty
       */
      poll() {
        if (this.size > 0) {
          const result = this._items[0];
          const item = this._items.pop();
          const size = this.size;
          if (size === 0) {
            return result;
          }
          let index = 0;
          let smallerChildIndex = 1;
          while (smallerChildIndex < size) {
            let smallerChild = this._items[smallerChildIndex];
            const rightChildIndex = smallerChildIndex + 1;
            if (rightChildIndex < size) {
              const rightChild = this._items[rightChildIndex];
              if (this._comparator(rightChild, smallerChild) < 0) {
                smallerChildIndex = rightChildIndex;
                smallerChild = rightChild;
              }
            }
            if (this._comparator(smallerChild, item) < 0) {
              this._items[index] = smallerChild;
              index = smallerChildIndex;
              smallerChildIndex = index * 2 + 1;
            } else {
              break;
            }
          }
          this._items[index] = item;
          return result;
        }
      }
      /**
       * Pushes an item into the heap.
       * @param item - the item to push
       */
      push(item) {
        let index = this.size;
        while (index > 0) {
          const parentIndex = (index + 1 >> 1) - 1;
          const parent = this._items[parentIndex];
          if (this._comparator(item, parent) < 0) {
            this._items[index] = parent;
            index = parentIndex;
          } else {
            break;
          }
        }
        this._items[index] = item;
      }
    };
    exports2.MinimumHeap = MinimumHeap;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/ProtectableMapView.js
var require_ProtectableMapView = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/ProtectableMapView.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtectableMapView = void 0;
    var ProtectableMapView = class extends Map {
      constructor(owner, parameters) {
        super();
        this._owner = owner;
        this._parameters = parameters;
      }
      clear() {
        if (this._parameters.onClear) {
          this._parameters.onClear(this._owner);
        }
        super.clear();
      }
      delete(key) {
        if (this._parameters.onDelete) {
          this._parameters.onDelete(this._owner, key);
        }
        return super.delete(key);
      }
      set(key, value) {
        let modifiedValue = value;
        if (this._parameters.onSet) {
          modifiedValue = this._parameters.onSet(this._owner, key, modifiedValue);
        }
        super.set(key, modifiedValue);
        return this;
      }
      // INTERNAL USAGE ONLY
      _clearUnprotected() {
        super.clear();
      }
      // INTERNAL USAGE ONLY
      _deleteUnprotected(key) {
        return super.delete(key);
      }
      // INTERNAL USAGE ONLY
      _setUnprotected(key, value) {
        super.set(key, value);
      }
    };
    exports2.ProtectableMapView = ProtectableMapView;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/ProtectableMap.js
var require_ProtectableMap = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/ProtectableMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtectableMap = void 0;
    var ProtectableMapView_1 = require_ProtectableMapView();
    var ProtectableMap = class {
      constructor(parameters) {
        this._protectedView = new ProtectableMapView_1.ProtectableMapView(this, parameters);
      }
      /**
       * The owner of the protectable map should return this object via its public API.
       */
      get protectedView() {
        return this._protectedView;
      }
      // ---------------------------------------------------------------------------
      // lib.es2015.collections contract - write operations
      /**
       * Removes all entries from the map.
       * This operation does NOT invoke the ProtectableMap onClear() hook.
       */
      clear() {
        this._protectedView._clearUnprotected();
      }
      /**
       * Removes the specified key from the map.
       * This operation does NOT invoke the ProtectableMap onDelete() hook.
       */
      delete(key) {
        return this._protectedView._deleteUnprotected(key);
      }
      /**
       * Sets a value for the specified key.
       * This operation does NOT invoke the ProtectableMap onSet() hook.
       */
      set(key, value) {
        this._protectedView._setUnprotected(key, value);
        return this;
      }
      // ---------------------------------------------------------------------------
      // lib.es2015.collections contract - read operations
      /**
       * Performs an operation for each (key, value) entries in the map.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      forEach(callbackfn, thisArg) {
        this._protectedView.forEach(callbackfn);
      }
      /**
       * Retrieves the value for the specified key.
       * @returns undefined if the value is undefined OR if the key is missing;
       * otherwise returns the value associated with the key.
       */
      get(key) {
        return this._protectedView.get(key);
      }
      /**
       * Returns true if the specified key belongs to the map.
       */
      has(key) {
        return this._protectedView.has(key);
      }
      /**
       * Returns the number of (key, value) entries in the map.
       */
      get size() {
        return this._protectedView.size;
      }
    };
    exports2.ProtectableMap = ProtectableMap;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Sort.js
var require_Sort = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/Sort.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Sort = void 0;
    var Sort = class _Sort {
      /**
       * Compares `x` and `y` using the JavaScript `>` and `<` operators.  This function is suitable for usage as
       * the callback for `array.sort()`.
       *
       * @remarks
       *
       * The JavaScript ordering is generalized so that `undefined` \< `null` \< all other values.
       *
       * @returns -1 if `x` is smaller than `y`, 1 if `x` is greater than `y`, or 0 if the values are equal.
       *
       * @example
       *
       * ```ts
       * let array: number[] = [3, 6, 2];
       * array.sort(Sort.compareByValue);  // [2, 3, 6]
       * ```
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static compareByValue(x, y) {
        if (x === y) {
          return 0;
        }
        if (x === void 0) {
          return -1;
        }
        if (y === void 0) {
          return 1;
        }
        if (x === null) {
          return -1;
        }
        if (y === null) {
          return 1;
        }
        if (x < y) {
          return -1;
        }
        if (x > y) {
          return 1;
        }
        return 0;
      }
      /**
       * Sorts the array according to a key which is obtained from the array elements.
       * The result is guaranteed to be a stable sort.
       *
       * @example
       *
       * ```ts
       * let array: string[] = [ 'aaa', 'bb', 'c' ];
       * Sort.sortBy(array, x => x.length);  // [ 'c', 'bb', 'aaa' ]
       * ```
       */
      static sortBy(array, keySelector, comparer = _Sort.compareByValue) {
        array.sort((x, y) => comparer(keySelector(x), keySelector(y)));
      }
      /**
       * Returns true if the collection is already sorted.
       */
      static isSorted(collection, comparer = _Sort.compareByValue) {
        let isFirst = true;
        let previous = void 0;
        for (const element of collection) {
          if (isFirst) {
            isFirst = false;
          } else if (comparer(previous, element) > 0) {
            return false;
          }
          previous = element;
        }
        return true;
      }
      /**
       * Returns true if the collection is already sorted by the specified key.
       *
       * @example
       *
       * ```ts
       * let array: string[] = [ 'a', 'bb', 'ccc' ];
       * Sort.isSortedBy(array, x => x.length); // true
       * ```
       */
      static isSortedBy(collection, keySelector, comparer = _Sort.compareByValue) {
        let isFirst = true;
        let previousKey = void 0;
        for (const element of collection) {
          const key = keySelector(element);
          if (isFirst) {
            isFirst = false;
          } else if (comparer(previousKey, key) > 0) {
            return false;
          }
          previousKey = key;
        }
        return true;
      }
      /**
       * Sorts the entries in a Map object according to the map keys.
       * The result is guaranteed to be a stable sort.
       *
       * @example
       *
       * ```ts
       * let map: Map<string, number> = new Map<string, number>();
       * map.set('zebra', 1);
       * map.set('goose', 2);
       * map.set('aardvark', 3);
       * Sort.sortMapKeys(map);
       * console.log(JSON.stringify(Array.from(map.keys()))); // ["aardvark","goose","zebra"]
       * ```
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static sortMapKeys(map, keyComparer = _Sort.compareByValue) {
        if (_Sort.isSorted(map.keys(), keyComparer)) {
          return;
        }
        const pairs = Array.from(map.entries());
        _Sort.sortBy(pairs, (x) => x[0], keyComparer);
        map.clear();
        for (const pair of pairs) {
          map.set(pair[0], pair[1]);
        }
      }
      /**
       * Sorts the entries in a Set object according to the specified keys.
       * The result is guaranteed to be a stable sort.
       *
       * @example
       *
       * ```ts
       * let set: Set<string> = new Set<string>();
       * set.add('aaa');
       * set.add('bb');
       * set.add('c');
       * Sort.sortSetBy(set, x => x.length);
       * console.log(Array.from(set)); // ['c', 'bb', 'aaa']
       * ```
       */
      static sortSetBy(set, keySelector, keyComparer = _Sort.compareByValue) {
        if (_Sort.isSortedBy(set, keySelector, keyComparer)) {
          return;
        }
        const array = Array.from(set);
        array.sort((x, y) => keyComparer(keySelector(x), keySelector(y)));
        set.clear();
        for (const item of array) {
          set.add(item);
        }
      }
      /**
       * Sorts the entries in a Set object.  The result is guaranteed to be a stable sort.
       *
       * @example
       *
       * ```ts
       * let set: Set<string> = new Set<string>();
       * set.add('zebra');
       * set.add('goose');
       * set.add('aardvark');
       * Sort.sortSet(set);
       * console.log(Array.from(set)); // ['aardvark', 'goose', 'zebra']
       * ```
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static sortSet(set, comparer = _Sort.compareByValue) {
        if (_Sort.isSorted(set, comparer)) {
          return;
        }
        const array = Array.from(set);
        array.sort((x, y) => comparer(x, y));
        set.clear();
        for (const item of array) {
          set.add(item);
        }
      }
    };
    exports2.Sort = Sort;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/StringBuilder.js
var require_StringBuilder = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/StringBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StringBuilder = void 0;
    var StringBuilder2 = class {
      constructor() {
        this._chunks = [];
      }
      /** {@inheritDoc IStringBuilder.append} */
      append(text) {
        this._chunks.push(text);
      }
      /** {@inheritDoc IStringBuilder.toString} */
      toString() {
        if (this._chunks.length === 0) {
          return "";
        }
        if (this._chunks.length > 1) {
          const joined = this._chunks.join("");
          this._chunks.length = 1;
          this._chunks[0] = joined;
        }
        return this._chunks[0];
      }
    };
    exports2.StringBuilder = StringBuilder2;
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/SubprocessTerminator.js
var require_SubprocessTerminator = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/SubprocessTerminator.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubprocessTerminator = void 0;
    var process_1 = __importDefault(require("process"));
    var Executable_1 = require_Executable();
    var SubprocessTerminator = class _SubprocessTerminator {
      /**
       * Registers a child process so that it will be terminated automatically if the current process
       * is terminated.
       */
      static killProcessTreeOnExit(subprocess, subprocessOptions) {
        if (typeof subprocess.exitCode === "number") {
          return;
        }
        _SubprocessTerminator._validateSubprocessOptions(subprocessOptions);
        _SubprocessTerminator._ensureInitialized();
        const pid = subprocess.pid;
        if (pid === void 0) {
          return;
        }
        subprocess.on("close", (code, signal) => {
          if (_SubprocessTerminator._subprocessesByPid.delete(pid)) {
            _SubprocessTerminator._logDebug(`untracking #${pid}`);
          }
        });
        _SubprocessTerminator._subprocessesByPid.set(pid, {
          subprocess,
          subprocessOptions
        });
        _SubprocessTerminator._logDebug(`tracking #${pid}`);
      }
      /**
       * Terminate the child process and all of its children.
       */
      static killProcessTree(subprocess, subprocessOptions) {
        const pid = subprocess.pid;
        if (pid === void 0) {
          return;
        }
        if (_SubprocessTerminator._subprocessesByPid.delete(pid)) {
          _SubprocessTerminator._logDebug(`untracking #${pid} via killProcessTree()`);
        }
        _SubprocessTerminator._validateSubprocessOptions(subprocessOptions);
        if (typeof subprocess.exitCode === "number") {
          return;
        }
        _SubprocessTerminator._logDebug(`terminating #${pid}`);
        if (_SubprocessTerminator._isWindows) {
          const result = Executable_1.Executable.spawnSync("TaskKill.exe", [
            "/T",
            // "Terminates the specified process and any child processes which were started by it."
            "/F",
            // Without this, TaskKill will try to use WM_CLOSE which doesn't work with CLI tools
            "/PID",
            pid.toString()
          ]);
          if (result.status) {
            const output = result.output.join("\n");
            if (output.indexOf("not found") >= 0) {
            } else {
              throw new Error(`TaskKill.exe returned exit code ${result.status}:
` + output + "\n");
            }
          }
        } else {
          process_1.default.kill(-pid, "SIGKILL");
        }
      }
      // Install the hooks
      static _ensureInitialized() {
        if (!_SubprocessTerminator._initialized) {
          _SubprocessTerminator._initialized = true;
          _SubprocessTerminator._logDebug("initialize");
          process_1.default.prependListener("SIGTERM", _SubprocessTerminator._onTerminateSignal);
          process_1.default.prependListener("SIGINT", _SubprocessTerminator._onTerminateSignal);
          process_1.default.prependListener("exit", _SubprocessTerminator._onExit);
        }
      }
      // Uninstall the hooks and perform cleanup
      static _cleanupChildProcesses() {
        if (_SubprocessTerminator._initialized) {
          _SubprocessTerminator._initialized = false;
          process_1.default.removeListener("SIGTERM", _SubprocessTerminator._onTerminateSignal);
          process_1.default.removeListener("SIGINT", _SubprocessTerminator._onTerminateSignal);
          const trackedSubprocesses = Array.from(_SubprocessTerminator._subprocessesByPid.values());
          let firstError = void 0;
          for (const trackedSubprocess of trackedSubprocesses) {
            try {
              _SubprocessTerminator.killProcessTree(trackedSubprocess.subprocess, { detached: true });
            } catch (error) {
              if (firstError === void 0) {
                firstError = error;
              }
            }
          }
          if (firstError !== void 0) {
            console.error("\nAn unexpected error was encountered while attempting to clean up child processes:");
            console.error(firstError.toString());
            if (!process_1.default.exitCode) {
              process_1.default.exitCode = 1;
            }
          }
        }
      }
      static _validateSubprocessOptions(subprocessOptions) {
        if (!_SubprocessTerminator._isWindows) {
          if (!subprocessOptions.detached) {
            throw new Error("killProcessTree() requires detached=true on this operating system");
          }
        }
      }
      static _onExit(exitCode) {
        _SubprocessTerminator._logDebug(`received exit(${exitCode})`);
        _SubprocessTerminator._cleanupChildProcesses();
        _SubprocessTerminator._logDebug(`finished exit()`);
      }
      static _onTerminateSignal(signal) {
        _SubprocessTerminator._logDebug(`received signal ${signal}`);
        _SubprocessTerminator._cleanupChildProcesses();
        _SubprocessTerminator._logDebug(`relaying ${signal}`);
        process_1.default.kill(process_1.default.pid, signal);
      }
      // For debugging
      static _logDebug(message) {
      }
    };
    exports2.SubprocessTerminator = SubprocessTerminator;
    SubprocessTerminator._initialized = false;
    SubprocessTerminator._subprocessesByPid = /* @__PURE__ */ new Map();
    SubprocessTerminator._isWindows = process_1.default.platform === "win32";
    SubprocessTerminator.RECOMMENDED_OPTIONS = {
      detached: process_1.default.platform !== "win32"
    };
  }
});

// ../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/@rushstack+node-core-library@4.3.0_@types+node@20.12.12/node_modules/@rushstack/node-core-library/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeUuid = exports2.SubprocessTerminator = exports2.StringBuilder = exports2.LegacyAdapters = exports2.FileWriter = exports2.FileSystem = exports2.AlreadyExistsBehavior = exports2.Sort = exports2.NewlineKind = exports2.Text = exports2.Encoding = exports2.Path = exports2.PackageNameParser = exports2.PackageName = exports2.PackageJsonLookup = exports2.ProtectableMap = exports2.PosixModeBits = exports2.MinimumHeap = exports2.MapExtensions = exports2.LockFile = exports2.JsonSchema = exports2.JsonFile = exports2.JsonSyntax = exports2.InternalError = exports2.Import = exports2.FileError = exports2.Executable = exports2.EnvironmentMap = exports2.Enum = exports2.FolderConstants = exports2.FileConstants = exports2.AsyncQueue = exports2.Async = exports2.AlreadyReportedError = void 0;
    var AlreadyReportedError_1 = require_AlreadyReportedError();
    Object.defineProperty(exports2, "AlreadyReportedError", { enumerable: true, get: function() {
      return AlreadyReportedError_1.AlreadyReportedError;
    } });
    var Async_1 = require_Async();
    Object.defineProperty(exports2, "Async", { enumerable: true, get: function() {
      return Async_1.Async;
    } });
    Object.defineProperty(exports2, "AsyncQueue", { enumerable: true, get: function() {
      return Async_1.AsyncQueue;
    } });
    var Constants_1 = require_Constants();
    Object.defineProperty(exports2, "FileConstants", { enumerable: true, get: function() {
      return Constants_1.FileConstants;
    } });
    Object.defineProperty(exports2, "FolderConstants", { enumerable: true, get: function() {
      return Constants_1.FolderConstants;
    } });
    var Enum_1 = require_Enum();
    Object.defineProperty(exports2, "Enum", { enumerable: true, get: function() {
      return Enum_1.Enum;
    } });
    var EnvironmentMap_1 = require_EnvironmentMap();
    Object.defineProperty(exports2, "EnvironmentMap", { enumerable: true, get: function() {
      return EnvironmentMap_1.EnvironmentMap;
    } });
    var Executable_1 = require_Executable();
    Object.defineProperty(exports2, "Executable", { enumerable: true, get: function() {
      return Executable_1.Executable;
    } });
    var FileError_1 = require_FileError();
    Object.defineProperty(exports2, "FileError", { enumerable: true, get: function() {
      return FileError_1.FileError;
    } });
    var Import_1 = require_Import();
    Object.defineProperty(exports2, "Import", { enumerable: true, get: function() {
      return Import_1.Import;
    } });
    var InternalError_1 = require_InternalError();
    Object.defineProperty(exports2, "InternalError", { enumerable: true, get: function() {
      return InternalError_1.InternalError;
    } });
    var JsonFile_1 = require_JsonFile();
    Object.defineProperty(exports2, "JsonSyntax", { enumerable: true, get: function() {
      return JsonFile_1.JsonSyntax;
    } });
    Object.defineProperty(exports2, "JsonFile", { enumerable: true, get: function() {
      return JsonFile_1.JsonFile;
    } });
    var JsonSchema_1 = require_JsonSchema();
    Object.defineProperty(exports2, "JsonSchema", { enumerable: true, get: function() {
      return JsonSchema_1.JsonSchema;
    } });
    var LockFile_1 = require_LockFile();
    Object.defineProperty(exports2, "LockFile", { enumerable: true, get: function() {
      return LockFile_1.LockFile;
    } });
    var MapExtensions_1 = require_MapExtensions();
    Object.defineProperty(exports2, "MapExtensions", { enumerable: true, get: function() {
      return MapExtensions_1.MapExtensions;
    } });
    var MinimumHeap_1 = require_MinimumHeap();
    Object.defineProperty(exports2, "MinimumHeap", { enumerable: true, get: function() {
      return MinimumHeap_1.MinimumHeap;
    } });
    var PosixModeBits_1 = require_PosixModeBits();
    Object.defineProperty(exports2, "PosixModeBits", { enumerable: true, get: function() {
      return PosixModeBits_1.PosixModeBits;
    } });
    var ProtectableMap_1 = require_ProtectableMap();
    Object.defineProperty(exports2, "ProtectableMap", { enumerable: true, get: function() {
      return ProtectableMap_1.ProtectableMap;
    } });
    var PackageJsonLookup_1 = require_PackageJsonLookup();
    Object.defineProperty(exports2, "PackageJsonLookup", { enumerable: true, get: function() {
      return PackageJsonLookup_1.PackageJsonLookup;
    } });
    var PackageName_1 = require_PackageName();
    Object.defineProperty(exports2, "PackageName", { enumerable: true, get: function() {
      return PackageName_1.PackageName;
    } });
    Object.defineProperty(exports2, "PackageNameParser", { enumerable: true, get: function() {
      return PackageName_1.PackageNameParser;
    } });
    var Path_1 = require_Path();
    Object.defineProperty(exports2, "Path", { enumerable: true, get: function() {
      return Path_1.Path;
    } });
    var Text_1 = require_Text();
    Object.defineProperty(exports2, "Encoding", { enumerable: true, get: function() {
      return Text_1.Encoding;
    } });
    Object.defineProperty(exports2, "Text", { enumerable: true, get: function() {
      return Text_1.Text;
    } });
    Object.defineProperty(exports2, "NewlineKind", { enumerable: true, get: function() {
      return Text_1.NewlineKind;
    } });
    var Sort_1 = require_Sort();
    Object.defineProperty(exports2, "Sort", { enumerable: true, get: function() {
      return Sort_1.Sort;
    } });
    var FileSystem_1 = require_FileSystem();
    Object.defineProperty(exports2, "AlreadyExistsBehavior", { enumerable: true, get: function() {
      return FileSystem_1.AlreadyExistsBehavior;
    } });
    Object.defineProperty(exports2, "FileSystem", { enumerable: true, get: function() {
      return FileSystem_1.FileSystem;
    } });
    var FileWriter_1 = require_FileWriter();
    Object.defineProperty(exports2, "FileWriter", { enumerable: true, get: function() {
      return FileWriter_1.FileWriter;
    } });
    var LegacyAdapters_1 = require_LegacyAdapters();
    Object.defineProperty(exports2, "LegacyAdapters", { enumerable: true, get: function() {
      return LegacyAdapters_1.LegacyAdapters;
    } });
    var StringBuilder_1 = require_StringBuilder();
    Object.defineProperty(exports2, "StringBuilder", { enumerable: true, get: function() {
      return StringBuilder_1.StringBuilder;
    } });
    var SubprocessTerminator_1 = require_SubprocessTerminator();
    Object.defineProperty(exports2, "SubprocessTerminator", { enumerable: true, get: function() {
      return SubprocessTerminator_1.SubprocessTerminator;
    } });
    var TypeUuid_1 = require_TypeUuid();
    Object.defineProperty(exports2, "TypeUuid", { enumerable: true, get: function() {
      return TypeUuid_1.TypeUuid;
    } });
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiParameterListMixin.js
var require_ApiParameterListMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiParameterListMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiParameterListMixin = void 0;
    var Parameter_1 = require_Parameter();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var node_core_library_1 = require_lib2();
    var _overloadIndex = Symbol("ApiParameterListMixin._overloadIndex");
    var _parameters = Symbol("ApiParameterListMixin._parameters");
    function ApiParameterListMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          this[_overloadIndex] = options.overloadIndex;
          this[_parameters] = [];
          if (this instanceof ApiDeclaredItem_1.ApiDeclaredItem) {
            if (options.parameters) {
              for (const parameterOptions of options.parameters) {
                const parameter = new Parameter_1.Parameter({
                  name: parameterOptions.parameterName,
                  parameterTypeExcerpt: this.buildExcerpt(parameterOptions.parameterTypeTokenRange),
                  // Prior to ApiJsonSchemaVersion.V_1005 this input will be undefined
                  isOptional: !!parameterOptions.isOptional,
                  parent: this
                });
                this[_parameters].push(parameter);
              }
            }
          } else {
            throw new node_core_library_1.InternalError("ApiReturnTypeMixin expects a base class that inherits from ApiDeclaredItem");
          }
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          options.overloadIndex = jsonObject.overloadIndex;
          options.parameters = jsonObject.parameters || [];
        }
        get overloadIndex() {
          return this[_overloadIndex];
        }
        get parameters() {
          return this[_parameters];
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          jsonObject.overloadIndex = this.overloadIndex;
          const parameterObjects = [];
          for (const parameter of this.parameters) {
            parameterObjects.push({
              parameterName: parameter.name,
              parameterTypeTokenRange: parameter.parameterTypeExcerpt.tokenRange,
              isOptional: parameter.isOptional
            });
          }
          jsonObject.parameters = parameterObjects;
        }
      }
      return MixedClass;
    }
    exports2.ApiParameterListMixin = ApiParameterListMixin;
    (function(ApiParameterListMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_parameters);
      }
      ApiParameterListMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiParameterListMixin || (exports2.ApiParameterListMixin = ApiParameterListMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiNameMixin.js
var require_ApiNameMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiNameMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiNameMixin = void 0;
    var _name = Symbol("ApiNameMixin._name");
    function ApiNameMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          this[_name] = options.name;
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          options.name = jsonObject.name;
        }
        get name() {
          return this[_name];
        }
        /** @override */
        get displayName() {
          return this[_name];
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          jsonObject.name = this.name;
        }
      }
      return MixedClass;
    }
    exports2.ApiNameMixin = ApiNameMixin;
    (function(ApiNameMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_name);
      }
      ApiNameMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiNameMixin || (exports2.ApiNameMixin = ApiNameMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/Excerpt.js
var require_Excerpt = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/Excerpt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Excerpt = exports2.ExcerptToken = exports2.ExcerptTokenKind = void 0;
    var node_core_library_1 = require_lib2();
    var ExcerptTokenKind;
    (function(ExcerptTokenKind2) {
      ExcerptTokenKind2["Content"] = "Content";
      ExcerptTokenKind2["Reference"] = "Reference";
    })(ExcerptTokenKind || (exports2.ExcerptTokenKind = ExcerptTokenKind = {}));
    var ExcerptToken = class {
      constructor(kind, text, canonicalReference) {
        this._kind = kind;
        this._text = node_core_library_1.Text.convertToLf(text);
        this._canonicalReference = canonicalReference;
      }
      /**
       * Indicates the kind of token.
       */
      get kind() {
        return this._kind;
      }
      /**
       * The text fragment.
       */
      get text() {
        return this._text;
      }
      /**
       * The hyperlink target for a token whose type is `ExcerptTokenKind.Reference`.  For other token types,
       * this property will be `undefined`.
       */
      get canonicalReference() {
        return this._canonicalReference;
      }
    };
    exports2.ExcerptToken = ExcerptToken;
    var Excerpt = class {
      constructor(tokens, tokenRange) {
        this.tokens = tokens;
        this.tokenRange = tokenRange;
        if (this.tokenRange.startIndex < 0 || this.tokenRange.endIndex > this.tokens.length || this.tokenRange.startIndex > this.tokenRange.endIndex) {
          throw new Error("Invalid token range");
        }
        this.spannedTokens = this.tokens.slice(this.tokenRange.startIndex, this.tokenRange.endIndex);
      }
      /**
       * The excerpted text, formed by concatenating the text of the `spannedTokens` strings.
       */
      get text() {
        if (this._text === void 0) {
          this._text = this.spannedTokens.map((x) => x.text).join("");
        }
        return this._text;
      }
      /**
       * Returns true if the excerpt is an empty range.
       */
      get isEmpty() {
        return this.tokenRange.startIndex === this.tokenRange.endIndex;
      }
    };
    exports2.Excerpt = Excerpt;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/IFindApiItemsResult.js
var require_IFindApiItemsResult = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/IFindApiItemsResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FindApiItemsMessageId = void 0;
    var FindApiItemsMessageId;
    (function(FindApiItemsMessageId2) {
      FindApiItemsMessageId2["DeclarationResolutionFailed"] = "declaration-resolution-failed";
      FindApiItemsMessageId2["ExtendsClauseMissingReference"] = "extends-clause-missing-reference";
      FindApiItemsMessageId2["NoAssociatedApiModel"] = "no-associated-api-model";
      FindApiItemsMessageId2["UnsupportedKind"] = "unsupported-kind";
    })(FindApiItemsMessageId || (exports2.FindApiItemsMessageId = FindApiItemsMessageId = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiItemContainerMixin.js
var require_ApiItemContainerMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiItemContainerMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiItemContainerMixin = void 0;
    var ApiItem_1 = require_ApiItem();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var Excerpt_1 = require_Excerpt();
    var IFindApiItemsResult_1 = require_IFindApiItemsResult();
    var node_core_library_1 = require_lib2();
    var _members = Symbol("ApiItemContainerMixin._members");
    var _membersSorted = Symbol("ApiItemContainerMixin._membersSorted");
    var _membersByContainerKey = Symbol("ApiItemContainerMixin._membersByContainerKey");
    var _membersByName = Symbol("ApiItemContainerMixin._membersByName");
    var _membersByKind = Symbol("ApiItemContainerMixin._membersByKind");
    var _preserveMemberOrder = Symbol("ApiItemContainerMixin._preserveMemberOrder");
    function ApiItemContainerMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          var _a;
          super(...args2);
          const options = args2[0];
          this[_members] = [];
          this[_membersSorted] = false;
          this[_membersByContainerKey] = /* @__PURE__ */ new Map();
          this[_preserveMemberOrder] = (_a = options.preserveMemberOrder) !== null && _a !== void 0 ? _a : false;
          if (options.members) {
            for (const member of options.members) {
              this.addMember(member);
            }
          }
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          options.preserveMemberOrder = jsonObject.preserveMemberOrder;
          options.members = [];
          for (const memberObject of jsonObject.members) {
            options.members.push(ApiItem_1.ApiItem.deserialize(memberObject, context));
          }
        }
        /** @override */
        get members() {
          if (!this[_membersSorted] && !this[_preserveMemberOrder]) {
            this[_members].sort((x, y) => x.getSortKey().localeCompare(y.getSortKey()));
            this[_membersSorted] = true;
          }
          return this[_members];
        }
        get preserveMemberOrder() {
          return this[_preserveMemberOrder];
        }
        addMember(member) {
          if (this[_membersByContainerKey].has(member.containerKey)) {
            throw new Error(`Another member has already been added with the same name (${member.displayName}) and containerKey (${member.containerKey})`);
          }
          const existingParent = member.parent;
          if (existingParent !== void 0) {
            throw new Error(`This item has already been added to another container: "${existingParent.displayName}"`);
          }
          this[_members].push(member);
          this[_membersByName] = void 0;
          this[_membersByKind] = void 0;
          this[_membersSorted] = false;
          this[_membersByContainerKey].set(member.containerKey, member);
          member[ApiItem_1.apiItem_onParentChanged](this);
        }
        tryGetMemberByKey(containerKey) {
          return this[_membersByContainerKey].get(containerKey);
        }
        findMembersByName(name) {
          this._ensureMemberMaps();
          return this[_membersByName].get(name) || [];
        }
        findMembersWithInheritance() {
          const messages = [];
          let maybeIncompleteResult = false;
          switch (this.kind) {
            case ApiItem_1.ApiItemKind.Class:
            case ApiItem_1.ApiItemKind.Interface:
              break;
            default: {
              return {
                items: this.members.concat(),
                messages,
                maybeIncompleteResult
              };
            }
          }
          const membersByName = /* @__PURE__ */ new Map();
          const membersByKind = /* @__PURE__ */ new Map();
          const toVisit = [];
          let next = this;
          while (next) {
            const membersToAdd = [];
            for (const member of next.members) {
              if (ApiNameMixin_1.ApiNameMixin.isBaseClassOf(member)) {
                if (!membersByName.has(member.name)) {
                  membersToAdd.push(member);
                }
              } else {
                if (!membersByKind.has(member.kind)) {
                  membersToAdd.push(member);
                }
              }
            }
            for (const member of membersToAdd) {
              if (ApiNameMixin_1.ApiNameMixin.isBaseClassOf(member)) {
                const members = membersByName.get(member.name) || [];
                members.push(member);
                membersByName.set(member.name, members);
              } else {
                const members = membersByKind.get(member.kind) || [];
                members.push(member);
                membersByKind.set(member.kind, members);
              }
            }
            const extendedItems = [];
            let extendsTypes;
            switch (next.kind) {
              case ApiItem_1.ApiItemKind.Class: {
                const apiClass = next;
                extendsTypes = apiClass.extendsType ? [apiClass.extendsType] : [];
                break;
              }
              case ApiItem_1.ApiItemKind.Interface: {
                const apiInterface = next;
                extendsTypes = apiInterface.extendsTypes;
                break;
              }
            }
            if (extendsTypes === void 0) {
              messages.push({
                messageId: IFindApiItemsResult_1.FindApiItemsMessageId.UnsupportedKind,
                text: `Unable to analyze references of API item ${next.displayName} because it is of unsupported kind ${next.kind}`
              });
              maybeIncompleteResult = true;
              next = toVisit.shift();
              continue;
            }
            for (const extendsType of extendsTypes) {
              const firstReferenceToken = extendsType.excerpt.spannedTokens.find((token) => {
                return token.kind === Excerpt_1.ExcerptTokenKind.Reference && token.canonicalReference;
              });
              if (!firstReferenceToken) {
                messages.push({
                  messageId: IFindApiItemsResult_1.FindApiItemsMessageId.ExtendsClauseMissingReference,
                  text: `Unable to analyze extends clause ${extendsType.excerpt.text} of API item ${next.displayName} because no canonical reference was found`
                });
                maybeIncompleteResult = true;
                continue;
              }
              const apiModel2 = this.getAssociatedModel();
              if (!apiModel2) {
                messages.push({
                  messageId: IFindApiItemsResult_1.FindApiItemsMessageId.NoAssociatedApiModel,
                  text: `Unable to analyze references of API item ${next.displayName} because it is not associated with an ApiModel`
                });
                maybeIncompleteResult = true;
                continue;
              }
              const canonicalReference = firstReferenceToken.canonicalReference;
              const apiItemResult = apiModel2.resolveDeclarationReference(canonicalReference, void 0);
              const apiItem = apiItemResult.resolvedApiItem;
              if (!apiItem) {
                messages.push({
                  messageId: IFindApiItemsResult_1.FindApiItemsMessageId.DeclarationResolutionFailed,
                  text: `Unable to resolve declaration reference within API item ${next.displayName}: ${apiItemResult.errorMessage}`
                });
                maybeIncompleteResult = true;
                continue;
              }
              extendedItems.push(apiItem);
            }
            extendedItems.sort((x, y) => x.getSortKey().localeCompare(y.getSortKey()));
            toVisit.push(...extendedItems);
            next = toVisit.shift();
          }
          const items = [];
          for (const members of membersByName.values()) {
            items.push(...members);
          }
          for (const members of membersByKind.values()) {
            items.push(...members);
          }
          items.sort((x, y) => x.getSortKey().localeCompare(y.getSortKey()));
          return {
            items,
            messages,
            maybeIncompleteResult
          };
        }
        /** @internal */
        _getMergedSiblingsForMember(memberApiItem) {
          this._ensureMemberMaps();
          let result;
          if (ApiNameMixin_1.ApiNameMixin.isBaseClassOf(memberApiItem)) {
            result = this[_membersByName].get(memberApiItem.name);
          } else {
            result = this[_membersByKind].get(memberApiItem.kind);
          }
          if (!result) {
            throw new node_core_library_1.InternalError("Item was not found in the _membersByName/_membersByKind lookup");
          }
          return result;
        }
        /** @internal */
        _ensureMemberMaps() {
          if (this[_membersByName] === void 0) {
            const membersByName = /* @__PURE__ */ new Map();
            const membersByKind = /* @__PURE__ */ new Map();
            for (const member of this[_members]) {
              let map;
              let key;
              if (ApiNameMixin_1.ApiNameMixin.isBaseClassOf(member)) {
                map = membersByName;
                key = member.name;
              } else {
                map = membersByKind;
                key = member.kind;
              }
              let list = map.get(key);
              if (list === void 0) {
                list = [];
                map.set(key, list);
              }
              list.push(member);
            }
            this[_membersByName] = membersByName;
            this[_membersByKind] = membersByKind;
          }
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          const memberObjects = [];
          for (const member of this.members) {
            const memberJsonObject = {};
            member.serializeInto(memberJsonObject);
            memberObjects.push(memberJsonObject);
          }
          jsonObject.preserveMemberOrder = this.preserveMemberOrder;
          jsonObject.members = memberObjects;
        }
      }
      return MixedClass;
    }
    exports2.ApiItemContainerMixin = ApiItemContainerMixin;
    (function(ApiItemContainerMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_members);
      }
      ApiItemContainerMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiItemContainerMixin || (exports2.ApiItemContainerMixin = ApiItemContainerMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiReleaseTagMixin.js
var require_ApiReleaseTagMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiReleaseTagMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiReleaseTagMixin = void 0;
    var node_core_library_1 = require_lib2();
    var ReleaseTag_1 = require_ReleaseTag();
    var _releaseTag = Symbol("ApiReleaseTagMixin._releaseTag");
    function ApiReleaseTagMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          this[_releaseTag] = options.releaseTag;
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          const deserializedReleaseTag = node_core_library_1.Enum.tryGetValueByKey(
            ReleaseTag_1.ReleaseTag,
            // eslint-disable-line
            jsonObject.releaseTag
          );
          if (deserializedReleaseTag === void 0) {
            throw new Error(`Failed to deserialize release tag ${JSON.stringify(jsonObject.releaseTag)}`);
          }
          options.releaseTag = deserializedReleaseTag;
        }
        get releaseTag() {
          return this[_releaseTag];
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          jsonObject.releaseTag = ReleaseTag_1.ReleaseTag[this.releaseTag];
        }
      }
      return MixedClass;
    }
    exports2.ApiReleaseTagMixin = ApiReleaseTagMixin;
    (function(ApiReleaseTagMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_releaseTag);
      }
      ApiReleaseTagMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiReleaseTagMixin || (exports2.ApiReleaseTagMixin = ApiReleaseTagMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/HeritageType.js
var require_HeritageType = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/HeritageType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HeritageType = void 0;
    var HeritageType = class {
      constructor(excerpt) {
        this.excerpt = excerpt;
      }
    };
    exports2.HeritageType = HeritageType;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/TypeParameter.js
var require_TypeParameter = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/TypeParameter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeParameter = void 0;
    var ApiDocumentedItem_1 = require_ApiDocumentedItem();
    var TypeParameter = class {
      constructor(options) {
        this.name = options.name;
        this.constraintExcerpt = options.constraintExcerpt;
        this.defaultTypeExcerpt = options.defaultTypeExcerpt;
        this.isOptional = options.isOptional;
        this._parent = options.parent;
      }
      /**
       * Returns the `@typeParam` documentation for this parameter, if present.
       */
      get tsdocTypeParamBlock() {
        if (this._parent instanceof ApiDocumentedItem_1.ApiDocumentedItem) {
          if (this._parent.tsdocComment) {
            return this._parent.tsdocComment.typeParams.tryGetBlockByName(this.name);
          }
        }
      }
    };
    exports2.TypeParameter = TypeParameter;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiTypeParameterListMixin.js
var require_ApiTypeParameterListMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiTypeParameterListMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiTypeParameterListMixin = void 0;
    var TypeParameter_1 = require_TypeParameter();
    var node_core_library_1 = require_lib2();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var _typeParameters = Symbol("ApiTypeParameterListMixin._typeParameters");
    function ApiTypeParameterListMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          this[_typeParameters] = [];
          if (this instanceof ApiDeclaredItem_1.ApiDeclaredItem) {
            if (options.typeParameters) {
              for (const typeParameterOptions of options.typeParameters) {
                const defaultTypeExcerpt = this.buildExcerpt(typeParameterOptions.defaultTypeTokenRange);
                const typeParameter = new TypeParameter_1.TypeParameter({
                  name: typeParameterOptions.typeParameterName,
                  constraintExcerpt: this.buildExcerpt(typeParameterOptions.constraintTokenRange),
                  defaultTypeExcerpt,
                  isOptional: !defaultTypeExcerpt.isEmpty,
                  parent: this
                });
                this[_typeParameters].push(typeParameter);
              }
            }
          } else {
            throw new node_core_library_1.InternalError("ApiTypeParameterListMixin expects a base class that inherits from ApiDeclaredItem");
          }
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          options.typeParameters = jsonObject.typeParameters || [];
        }
        get typeParameters() {
          return this[_typeParameters];
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          const typeParameterObjects = [];
          for (const typeParameter of this.typeParameters) {
            typeParameterObjects.push({
              typeParameterName: typeParameter.name,
              constraintTokenRange: typeParameter.constraintExcerpt.tokenRange,
              defaultTypeTokenRange: typeParameter.defaultTypeExcerpt.tokenRange
            });
          }
          if (typeParameterObjects.length > 0) {
            jsonObject.typeParameters = typeParameterObjects;
          }
        }
      }
      return MixedClass;
    }
    exports2.ApiTypeParameterListMixin = ApiTypeParameterListMixin;
    (function(ApiTypeParameterListMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_typeParameters);
      }
      ApiTypeParameterListMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiTypeParameterListMixin || (exports2.ApiTypeParameterListMixin = ApiTypeParameterListMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiExportedMixin.js
var require_ApiExportedMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiExportedMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiExportedMixin = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var _isExported = Symbol("ApiExportedMixin._isExported");
    function ApiExportedMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          this[_isExported] = options.isExported;
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          const declarationReference = DeclarationReference_1.DeclarationReference.parse(jsonObject.canonicalReference);
          options.isExported = declarationReference.navigation === ".";
        }
        get isExported() {
          return this[_isExported];
        }
        /**
         * The `isExported` property is intentionally not serialized because the information is already present
         * in the item's `canonicalReference`.
         * @override
         */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
        }
      }
      return MixedClass;
    }
    exports2.ApiExportedMixin = ApiExportedMixin;
    (function(ApiExportedMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_isExported);
      }
      ApiExportedMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiExportedMixin || (exports2.ApiExportedMixin = ApiExportedMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiAbstractMixin.js
var require_ApiAbstractMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiAbstractMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiAbstractMixin = void 0;
    var _isAbstract = Symbol("ApiAbstractMixin._isAbstract");
    function ApiAbstractMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          this[_isAbstract] = options.isAbstract;
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          options.isAbstract = jsonObject.isAbstract || false;
        }
        get isAbstract() {
          return this[_isAbstract];
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          jsonObject.isAbstract = this.isAbstract;
        }
      }
      return MixedClass;
    }
    exports2.ApiAbstractMixin = ApiAbstractMixin;
    (function(ApiAbstractMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_isAbstract);
      }
      ApiAbstractMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiAbstractMixin || (exports2.ApiAbstractMixin = ApiAbstractMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiClass.js
var require_ApiClass = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiClass.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiClass = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiItemContainerMixin_1 = require_ApiItemContainerMixin();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var HeritageType_1 = require_HeritageType();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiTypeParameterListMixin_1 = require_ApiTypeParameterListMixin();
    var ApiExportedMixin_1 = require_ApiExportedMixin();
    var ApiAbstractMixin_1 = require_ApiAbstractMixin();
    var ApiClass = class _ApiClass extends (0, ApiItemContainerMixin_1.ApiItemContainerMixin)((0, ApiNameMixin_1.ApiNameMixin)((0, ApiAbstractMixin_1.ApiAbstractMixin)((0, ApiTypeParameterListMixin_1.ApiTypeParameterListMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiExportedMixin_1.ApiExportedMixin)(ApiDeclaredItem_1.ApiDeclaredItem)))))) {
      constructor(options) {
        super(options);
        this._implementsTypes = [];
        if (options.extendsTokenRange) {
          this.extendsType = new HeritageType_1.HeritageType(this.buildExcerpt(options.extendsTokenRange));
        } else {
          this.extendsType = void 0;
        }
        for (const implementsTokenRange of options.implementsTokenRanges) {
          this._implementsTypes.push(new HeritageType_1.HeritageType(this.buildExcerpt(implementsTokenRange)));
        }
      }
      static getContainerKey(name) {
        return `${name}|${ApiItem_1.ApiItemKind.Class}`;
      }
      /** @override */
      static onDeserializeInto(options, context, jsonObject) {
        super.onDeserializeInto(options, context, jsonObject);
        options.extendsTokenRange = jsonObject.extendsTokenRange;
        options.implementsTokenRanges = jsonObject.implementsTokenRanges;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.Class;
      }
      /** @override */
      get containerKey() {
        return _ApiClass.getContainerKey(this.name);
      }
      /**
       * The list of interfaces that this class implements using the `implements` keyword.
       */
      get implementsTypes() {
        return this._implementsTypes;
      }
      /** @override */
      serializeInto(jsonObject) {
        super.serializeInto(jsonObject);
        if (this.extendsType) {
          jsonObject.extendsTokenRange = this.extendsType.excerpt.tokenRange;
        }
        jsonObject.implementsTokenRanges = this.implementsTypes.map((x) => x.excerpt.tokenRange);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        const navigation = this.isExported ? "." : "~";
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep(navigation, nameComponent).withMeaning(
          "class"
          /* Meaning.Class */
        );
      }
    };
    exports2.ApiClass = ApiClass;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/DeserializerContext.js
var require_DeserializerContext = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/DeserializerContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeserializerContext = exports2.ApiJsonSchemaVersion = void 0;
    var ApiJsonSchemaVersion;
    (function(ApiJsonSchemaVersion2) {
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1000"] = 1e3] = "V_1000";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1001"] = 1001] = "V_1001";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1002"] = 1002] = "V_1002";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1003"] = 1003] = "V_1003";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1004"] = 1004] = "V_1004";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1005"] = 1005] = "V_1005";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1006"] = 1006] = "V_1006";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1007"] = 1007] = "V_1007";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1008"] = 1008] = "V_1008";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1009"] = 1009] = "V_1009";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1010"] = 1010] = "V_1010";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["V_1011"] = 1011] = "V_1011";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["LATEST"] = 1011] = "LATEST";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["OLDEST_SUPPORTED"] = 1001] = "OLDEST_SUPPORTED";
      ApiJsonSchemaVersion2[ApiJsonSchemaVersion2["OLDEST_FORWARDS_COMPATIBLE"] = 1001] = "OLDEST_FORWARDS_COMPATIBLE";
    })(ApiJsonSchemaVersion || (exports2.ApiJsonSchemaVersion = ApiJsonSchemaVersion = {}));
    var DeserializerContext = class {
      constructor(options) {
        this.apiJsonFilename = options.apiJsonFilename;
        this.toolPackage = options.toolPackage;
        this.toolVersion = options.toolVersion;
        this.versionToDeserialize = options.versionToDeserialize;
        this.tsdocConfiguration = options.tsdocConfiguration;
      }
    };
    exports2.DeserializerContext = DeserializerContext;
  }
});

// ../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/caller.js
var require_caller2 = __commonJS({
  "../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/caller.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths2 = __commonJS({
  "../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var parse = path.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/normalize-options.js
var require_normalize_options2 = __commonJS({
  "../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/normalize-options.js"(exports2, module2) {
    "use strict";
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/async.js
var require_async2 = __commonJS({
  "../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/async.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path = require("path");
    var caller = require_caller2();
    var nodeModulesPaths = require_node_modules_paths2();
    var normalizeOptions = require_normalize_options2();
    var isCore = require_is_core_module();
    var realpathFS = fs2.realpath && typeof fs2.realpath.native === "function" ? fs2.realpath.native : fs2.realpath;
    var defaultIsFile = function isFile(file, cb) {
      fs2.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs2.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolve(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs2.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || [];
      var absoluteStart = path.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2)
            cb(err2);
          else
            init(realStart);
        }
      );
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n, pkg) {
            if (err2)
              cb(err2);
            else if (n) {
              return maybeRealpath(realpath, n, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load(
                  [""].concat(extensions.slice()),
                  path.resolve(dir, r),
                  pkg
                );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path.dirname(dir), cb2);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path.dirname(dir), cb2);
            readFile(pkgfile, function(err3, body) {
              if (err3)
                cb2(err3);
              try {
                var pkg = JSON.parse(body);
              } catch (jsonErr) {
              }
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path.join(x2, "index"), fpkg, cb2);
            readFile(pkgfile, function(err3, body) {
              if (err3)
                return cb2(err3);
              try {
                var pkg = JSON.parse(body);
              } catch (jsonErr) {
              }
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                  var dir = path.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n)
                      return cb2(null, n, pkg3);
                    loadAsFile(path.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2)
            return cb2(err2);
          if (n)
            return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/core.json
var require_core4 = __commonJS({
  "../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "assert/strict": ">= 15",
      async_hooks: ">= 8",
      buffer_ieee754: "< 0.9.7",
      buffer: true,
      child_process: true,
      cluster: true,
      console: true,
      constants: true,
      crypto: true,
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      diagnostics_channel: ">= 15.1",
      dns: true,
      "dns/promises": ">= 15",
      domain: ">= 0.7.12",
      events: true,
      freelist: "< 6",
      fs: true,
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      _http_agent: ">= 0.11.1",
      _http_client: ">= 0.11.1",
      _http_common: ">= 0.11.1",
      _http_incoming: ">= 0.11.1",
      _http_outgoing: ">= 0.11.1",
      _http_server: ">= 0.11.1",
      http: true,
      http2: ">= 8.8",
      https: true,
      inspector: ">= 8.0.0",
      _linklist: "< 8",
      module: true,
      net: true,
      "node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
      os: true,
      path: true,
      perf_hooks: ">= 8.5",
      process: ">= 1",
      punycode: true,
      querystring: true,
      readline: true,
      repl: true,
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      _stream_transform: ">= 0.9.4",
      _stream_wrap: ">= 1.4.1",
      _stream_passthrough: ">= 0.9.4",
      _stream_readable: ">= 0.9.4",
      _stream_writable: ">= 0.9.4",
      stream: true,
      "stream/promises": ">= 15",
      string_decoder: true,
      sys: [">= 0.6 && < 0.7", ">= 0.8"],
      timers: true,
      "timers/promises": ">= 15",
      _tls_common: ">= 0.11.13",
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      tls: true,
      trace_events: ">= 10",
      tty: true,
      url: true,
      util: true,
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
      "v8/tools/consarray": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
      "v8/tools/csvparser": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
      "v8/tools/logreader": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
      "v8/tools/profile_view": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
      "v8/tools/splaytree": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
      v8: ">= 1",
      vm: true,
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      zlib: true
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/core.js
var require_core5 = __commonJS({
  "../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/core.js"(exports2, module2) {
    "use strict";
    var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
    function specifierIncluded(specifier) {
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(current[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        } else if (op === ">=") {
          return cur >= ver;
        } else {
          return false;
        }
      }
      return op === ">=";
    }
    function matchesRange(range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(specifierValue);
    }
    var data = require_core4();
    var core = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = versionIncluded(data[mod]);
      }
    }
    var mod;
    module2.exports = core;
  }
});

// ../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/is-core.js
var require_is_core2 = __commonJS({
  "../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/is-core.js"(exports2, module2) {
    "use strict";
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/sync.js
var require_sync2 = __commonJS({
  "../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/lib/sync.js"(exports2, module2) {
    "use strict";
    var isCore = require_is_core_module();
    var fs2 = require("fs");
    var path = require("path");
    var caller = require_caller2();
    var nodeModulesPaths = require_node_modules_paths2();
    var normalizeOptions = require_normalize_options2();
    var realpathFS = fs2.realpathSync && typeof fs2.realpathSync.native === "function" ? fs2.realpathSync.native : fs2.realpathSync;
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs2.statSync(file);
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return stat.isFile() || stat.isFIFO();
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs2.statSync(dir);
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs2.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || [];
      var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n)
          return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path.dirname(dir));
        }
        var body = readFileSync(pkgfile);
        try {
          var pkg = JSON.parse(body);
        } catch (jsonErr) {
        }
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir
          );
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var body = readFileSync(pkgfile, "UTF8");
            var pkg = JSON.parse(body);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x2
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
              if (m2)
                return m2;
              var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
              if (n2)
                return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2)
              return n2;
          }
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/index.js
var require_resolve2 = __commonJS({
  "../../node_modules/.pnpm/resolve@1.19.0/node_modules/resolve/index.js"(exports2, module2) {
    "use strict";
    var async = require_async2();
    async.core = require_core5();
    async.isCore = require_is_core2();
    async.sync = require_sync2();
    module2.exports = async;
  }
});

// ../../node_modules/.pnpm/uri-js@4.4.1/node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "../../node_modules/.pnpm/uri-js@4.4.1/node_modules/uri-js/dist/es5/uri.all.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
    })(exports2, function(exports3) {
      "use strict";
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = /* @__PURE__ */ function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse(serialize(base2, options), options);
          relative = parse(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse2(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse2(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse2(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports3.SCHEMES = SCHEMES;
      exports3.pctEncChar = pctEncChar;
      exports3.pctDecChars = pctDecChars;
      exports3.parse = parse;
      exports3.removeDotSegments = removeDotSegments;
      exports3.serialize = serialize;
      exports3.resolveComponents = resolveComponents;
      exports3.resolve = resolve;
      exports3.normalize = normalize;
      exports3.equal = equal;
      exports3.escapeComponent = escapeComponent;
      exports3.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/ucs2length.js"(exports2, module2) {
    "use strict";
    module2.exports = function ucs2length(str) {
      var length = 0, len = str.length, pos = 0, value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) == 56320)
            pos++;
        }
      }
      return length;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/util.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      copy,
      checkDataType,
      checkDataTypes,
      coerceToTypes,
      toHash,
      getProperty,
      escapeQuotes,
      equal: require_fast_deep_equal(),
      ucs2length: require_ucs2length(),
      varOccurences,
      varReplace,
      schemaHasRules,
      schemaHasRulesExcept,
      schemaUnknownRules,
      toQuotedString,
      getPathExpr,
      getPath,
      getData,
      unescapeFragment,
      unescapeJsonPointer,
      escapeFragment,
      escapeJsonPointer
    };
    function copy(o, to) {
      to = to || {};
      for (var key in o)
        to[key] = o[key];
      return to;
    }
    function checkDataType(dataType, data, strictNumbers, negate) {
      var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
      switch (dataType) {
        case "null":
          return data + EQUAL + "null";
        case "array":
          return OK + "Array.isArray(" + data + ")";
        case "object":
          return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
        case "integer":
          return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        case "number":
          return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        default:
          return "typeof " + data + EQUAL + '"' + dataType + '"';
      }
    }
    function checkDataTypes(dataTypes, data, strictNumbers) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data, strictNumbers, true);
        default:
          var code = "";
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code = types.null ? "(" : "(!" + data + " || ";
            code += "typeof " + data + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number)
            delete types.integer;
          for (var t in types)
            code += (code ? " && " : "") + checkDataType(t, data, strictNumbers, true);
          return code;
      }
    }
    var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t = dataTypes[i];
          if (COERCE_TO_TYPES[t])
            types[types.length] = t;
          else if (optionCoerceTypes === "array" && t === "array")
            types[types.length] = t;
        }
        if (types.length)
          return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === "array" && dataTypes === "array") {
        return ["array"];
      }
    }
    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++)
        hash[arr[i]] = true;
      return hash;
    }
    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
    }
    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
    }
    function varOccurences(str, dataVar) {
      dataVar += "[^0-9]";
      var matches = str.match(new RegExp(dataVar, "g"));
      return matches ? matches.length : 0;
    }
    function varReplace(str, dataVar, expr) {
      dataVar += "([^0-9])";
      expr = expr.replace(/\$/g, "$$$$");
      return str.replace(new RegExp(dataVar, "g"), expr + "$1");
    }
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (var key in schema)
        if (rules[key])
          return true;
    }
    function schemaHasRulesExcept(schema, rules, exceptKeyword) {
      if (typeof schema == "boolean")
        return !schema && exceptKeyword != "not";
      for (var key in schema)
        if (key != exceptKeyword && rules[key])
          return true;
    }
    function schemaUnknownRules(schema, rules) {
      if (typeof schema == "boolean")
        return;
      for (var key in schema)
        if (!rules[key])
          return key;
    }
    function toQuotedString(str) {
      return "'" + escapeQuotes(str) + "'";
    }
    function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
      var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
      return joinPaths(currentPath, path);
    }
    function getPath(currentPath, prop, jsonPointers) {
      var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches;
      if ($data === "")
        return "rootData";
      if ($data[0] == "/") {
        if (!JSON_POINTER.test($data))
          throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = "rootData";
      } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches)
          throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == "#") {
          if (up >= lvl)
            throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
          return paths[lvl - up];
        }
        if (up > lvl)
          throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data = "data" + (lvl - up || "");
        if (!jsonPointer)
          return data;
      }
      var expr = data;
      var segments = jsonPointer.split("/");
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += " && " + data;
        }
      }
      return expr;
    }
    function joinPaths(a, b) {
      if (a == '""')
        return b;
      return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
    }
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    function escapeJsonPointer(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/schema_obj.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    module2.exports = SchemaObject;
    function SchemaObject(obj) {
      util.copy(obj, this);
    }
  }
});

// ../../node_modules/.pnpm/json-schema-traverse@0.4.1/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "../../node_modules/.pnpm/json-schema-traverse@0.4.1/node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/resolve.js
var require_resolve3 = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/resolve.js"(exports2, module2) {
    "use strict";
    var URI = require_uri_all();
    var equal = require_fast_deep_equal();
    var util = require_util();
    var SchemaObject = require_schema_obj();
    var traverse = require_json_schema_traverse();
    module2.exports = resolve;
    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;
    function resolve(compile, root, ref) {
      var refVal = this._refs[ref];
      if (typeof refVal == "string") {
        if (this._refs[refVal])
          refVal = this._refs[refVal];
        else
          return resolve.call(this, compile, root, refVal);
      }
      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }
      var res = resolveSchema.call(this, root, ref);
      var schema, v, baseId;
      if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
      }
      if (schema instanceof SchemaObject) {
        v = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
      } else if (schema !== void 0) {
        v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);
      }
      return v;
    }
    function resolveSchema(root, ref) {
      var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
      if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate)
            this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate)
              this._compile(refVal);
            if (id == normalizeId(ref))
              return { schema: refVal, root, baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema)
          return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }
    function resolveRecursive(root, ref, parsedRef) {
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id)
          baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
      }
    }
    var PREVENT_SCOPE_CHANGE = util.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function getJsonPointer(parsedRef, baseId, schema, root) {
      parsedRef.fragment = parsedRef.fragment || "";
      if (parsedRef.fragment.slice(0, 1) != "/")
        return;
      var parts = parsedRef.fragment.split("/");
      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util.unescapeFragment(part);
          schema = schema[part];
          if (schema === void 0)
            break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema);
            if (id)
              baseId = resolveUrl(baseId, id);
            if (schema.$ref) {
              var $ref = resolveUrl(baseId, schema.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema !== void 0 && schema !== root.schema)
        return { schema, root, baseId };
    }
    var SIMPLE_INLINED = util.toHash([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum"
    ]);
    function inlineRef(schema, limit) {
      if (limit === false)
        return false;
      if (limit === void 0 || limit === true)
        return checkNoRef(schema);
      else if (limit)
        return countKeys(schema) <= limit;
    }
    function checkNoRef(schema) {
      var item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return false;
          item = schema[key];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      }
      return true;
    }
    function countKeys(schema) {
      var count = 0, item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object")
            count += countKeys(item);
          if (count == Infinity)
            return Infinity;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema[key];
            if (typeof item == "object")
              count += countKeys(item) + 1;
            if (count == Infinity)
              return Infinity;
          }
        }
      }
      return count;
    }
    function getFullPath(id, normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      var p = URI.parse(id);
      return _getFullPath(p);
    }
    function _getFullPath(p) {
      return URI.serialize(p).split("#")[0] + "#";
    }
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return URI.resolve(baseId, id);
    }
    function resolveIds(schema) {
      var schemaId = normalizeId(this._getId(schema));
      var baseIds = { "": schemaId };
      var fullPaths = { "": getFullPath(schemaId, false) };
      var localRefs = {};
      var self2 = this;
      traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "")
          return;
        var id = self2._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== void 0)
          fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
        if (typeof id == "string") {
          id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
          var refVal = self2._refs[id];
          if (typeof refVal == "string")
            refVal = self2._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == "#") {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self2._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });
      return localRefs;
    }
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/error_classes.js"(exports2, module2) {
    "use strict";
    var resolve = require_resolve3();
    module2.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };
    function ValidationError(errors) {
      this.message = "validation failed";
      this.errors = errors;
      this.ajv = this.validation = true;
    }
    MissingRefError.message = function(baseId, ref) {
      return "can't resolve reference " + ref + " from id " + baseId;
    };
    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }
    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
  }
});

// ../../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "../../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && /* @__PURE__ */ function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/validate.js
var require_validate = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/validate.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_validate(it, $keyword, $ruleType) {
      var out = "";
      var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
      if (it.opts.strictKeywords) {
        var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
        if ($unknownKwd) {
          var $keywordsMsg = "unknown keyword: " + $unknownKwd;
          if (it.opts.strictKeywords === "log")
            it.logger.warn($keywordsMsg);
          else
            throw new Error($keywordsMsg);
        }
      }
      if (it.isTop) {
        out += " var validate = ";
        if ($async) {
          it.async = true;
          out += "async ";
        }
        out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += " " + ("/*# sourceURL=" + $id + " */") + " ";
        }
      }
      if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += " var " + $valid + " = false; ";
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'boolean schema is false' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += " return data; ";
            } else {
              out += " validate.errors = null; return true; ";
            }
          } else {
            out += " var " + $valid + " = true; ";
          }
        }
        if (it.isTop) {
          out += " }; return validate; ";
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [""];
        if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
          var $defaultMsg = "default is ignored in the schema root";
          if (it.opts.strictDefaults === "log")
            it.logger.warn($defaultMsg);
          else
            throw new Error($defaultMsg);
        }
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
      } else {
        var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id)
          it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async)
          throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
      }
      var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
      var $errorKeyword;
      var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
      if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
        if ($typeIsArray) {
          if ($typeSchema.indexOf("null") == -1)
            $typeSchema = $typeSchema.concat("null");
        } else if ($typeSchema != "null") {
          $typeSchema = [$typeSchema, "null"];
          $typeIsArray = true;
        }
      }
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == "fail") {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if (it.schema.$comment && it.opts.$comment) {
        out += " " + it.RULES.all.$comment.code(it, "$comment");
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
          out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
          if ($coerceToTypes) {
            var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
            out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
            if (it.opts.coerceTypes == "array") {
              out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
            }
            out += " if (" + $coerced + " !== undefined) ; ";
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($type == "string") {
                  out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                } else if ($type == "number" || $type == "integer") {
                  out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                  if ($type == "integer") {
                    out += " && !(" + $data + " % 1)";
                  }
                  out += ")) " + $coerced + " = +" + $data + "; ";
                } else if ($type == "boolean") {
                  out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                } else if ($type == "null") {
                  out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                } else if (it.opts.coerceTypes == "array" && $type == "array") {
                  out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                }
              }
            }
            out += " else {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } if (" + $coerced + " !== undefined) {  ";
            var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
            out += " " + $data + " = " + $coerced + "; ";
            if (!$dataLvl) {
              out += "if (" + $parentData + " !== undefined)";
            }
            out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          }
          out += " } ";
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
        if ($breakOnError) {
          out += " } if (errors === ";
          if ($top) {
            out += "0";
          } else {
            out += "errs_" + $lvl;
          }
          out += ") { ";
          $closingBraces2 += "}";
        }
      } else {
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
              }
              if (it.opts.useDefaults) {
                if ($rulesGroup.type == "object" && it.schema.properties) {
                  var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== void 0) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch, $i = -1, l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== void 0) {
                        var $passData = $data + "[" + $i + "]";
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule, i5 = -1, l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += " " + $code + " ";
                      if ($breakOnError) {
                        $closingBraces1 += "}";
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += " " + $closingBraces1 + " ";
                $closingBraces1 = "";
              }
              if ($rulesGroup.type) {
                out += " } ";
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += " else { ";
                  var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                }
              }
              if ($breakOnError) {
                out += " if (errors === ";
                if ($top) {
                  out += "0";
                } else {
                  out += "errs_" + $lvl;
                }
                out += ") { ";
                $closingBraces2 += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces2 + " ";
      }
      if ($top) {
        if ($async) {
          out += " if (errors === 0) return data;           ";
          out += " else throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; ";
          out += " return errors === 0;       ";
        }
        out += " }; return validate;";
      } else {
        out += " var " + $valid + " = errors === errs_" + $lvl + ";";
      }
      function $shouldUseGroup($rulesGroup2) {
        var rules = $rulesGroup2.rules;
        for (var i = 0; i < rules.length; i++)
          if ($shouldUseRule(rules[i]))
            return true;
      }
      function $shouldUseRule($rule2) {
        return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
      }
      function $ruleImplementsSomeKeyword($rule2) {
        var impl = $rule2.implements;
        for (var i = 0; i < impl.length; i++)
          if (it.schema[impl[i]] !== void 0)
            return true;
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/index.js"(exports2, module2) {
    "use strict";
    var resolve = require_resolve3();
    var util = require_util();
    var errorClasses = require_error_classes();
    var stableStringify = require_fast_json_stable_stringify();
    var validateGenerator = require_validate();
    var ucs2length = util.ucs2length;
    var equal = require_fast_deep_equal();
    var ValidationError = errorClasses.Validation;
    module2.exports = compile;
    function compile(schema, root, localRefs, baseId) {
      var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
      root = root || { schema, refVal, refs };
      var c = checkCompiling.call(this, schema, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling)
        return compilation.callValidate = callValidate;
      var formats = this._formats;
      var RULES = this.RULES;
      try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode)
            cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema, root, baseId);
      }
      function callValidate() {
        var validate = compilation.validate;
        var result = validate.apply(this, arguments);
        callValidate.errors = validate.errors;
        return result;
      }
      function localCompile(_schema, _root, localRefs2, baseId2) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema)
          return compile.call(self2, _schema, _root, localRefs2, baseId2);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot,
          baseId: baseId2,
          root: _root,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES,
          validate: validateGenerator,
          util,
          resolve,
          resolveRef,
          usePattern,
          useDefault,
          useCustomRule,
          opts,
          formats,
          logger: self2.logger,
          self: self2
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode)
          sourceCode = opts.processCode(sourceCode, _schema);
        var validate;
        try {
          var makeValidate = new Function(
            "self",
            "RULES",
            "formats",
            "root",
            "refVal",
            "defaults",
            "customRules",
            "equal",
            "ucs2length",
            "ValidationError",
            sourceCode
          );
          validate = makeValidate(
            self2,
            RULES,
            formats,
            root,
            refVal,
            defaults,
            customRules,
            equal,
            ucs2length,
            ValidationError
          );
          refVal[0] = validate;
        } catch (e) {
          self2.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        }
        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async)
          validate.$async = true;
        if (opts.sourceCode === true) {
          validate.source = {
            code: sourceCode,
            patterns,
            defaults
          };
        }
        return validate;
      }
      function resolveRef(baseId2, ref, isRoot) {
        ref = resolve.url(baseId2, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== void 0) {
          _refVal = refVal[refIndex];
          refCode = "refVal[" + refIndex + "]";
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== void 0) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }
        refCode = addLocalRef(ref);
        var v2 = resolve.call(self2, localCompile, root, ref);
        if (v2 === void 0) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
          }
        }
        if (v2 === void 0) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v2);
          return resolvedRef(v2, refCode);
        }
      }
      function addLocalRef(ref, v2) {
        var refId = refVal.length;
        refVal[refId] = v2;
        refs[ref] = refId;
        return "refVal" + refId;
      }
      function removeLocalRef(ref) {
        delete refs[ref];
      }
      function replaceLocalRef(ref, v2) {
        var refId = refs[ref];
        refVal[refId] = v2;
      }
      function resolvedRef(refVal2, code) {
        return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
      }
      function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === void 0) {
          index = patternsHash[regexStr] = patterns.length;
          patterns[index] = regexStr;
        }
        return "pattern" + index;
      }
      function useDefault(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
            return "" + value;
          case "string":
            return util.toQuotedString(value);
          case "object":
            if (value === null)
              return "null";
            var valueStr = stableStringify(value);
            var index = defaultsHash[valueStr];
            if (index === void 0) {
              index = defaultsHash[valueStr] = defaults.length;
              defaults[index] = value;
            }
            return "default" + index;
        }
      }
      function useCustomRule(rule, schema2, parentSchema, it) {
        if (self2._opts.validateSchema !== false) {
          var deps = rule.definition.dependencies;
          if (deps && !deps.every(function(keyword) {
            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
          }))
            throw new Error("parent schema must have all required keywords: " + deps.join(","));
          var validateSchema = rule.definition.validateSchema;
          if (validateSchema) {
            var valid = validateSchema(schema2);
            if (!valid) {
              var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
              if (self2._opts.validateSchema == "log")
                self2.logger.error(message);
              else
                throw new Error(message);
            }
          }
        }
        var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate;
        if (compile2) {
          validate = compile2.call(self2, schema2, parentSchema, it);
        } else if (macro) {
          validate = macro.call(self2, schema2, parentSchema, it);
          if (opts.validateSchema !== false)
            self2.validateSchema(validate, true);
        } else if (inline) {
          validate = inline.call(self2, it, rule.keyword, schema2, parentSchema);
        } else {
          validate = rule.definition.validate;
          if (!validate)
            return;
        }
        if (validate === void 0)
          throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index = customRules.length;
        customRules[index] = validate;
        return {
          code: "customRule" + index,
          validate
        };
      }
    }
    function checkCompiling(schema, root, baseId) {
      var index = compIndex.call(this, schema, root, baseId);
      if (index >= 0)
        return { index, compiling: true };
      index = this._compilations.length;
      this._compilations[index] = {
        schema,
        root,
        baseId
      };
      return { index, compiling: false };
    }
    function endCompiling(schema, root, baseId) {
      var i = compIndex.call(this, schema, root, baseId);
      if (i >= 0)
        this._compilations.splice(i, 1);
    }
    function compIndex(schema, root, baseId) {
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId)
          return i;
      }
      return -1;
    }
    function patternCode(i, patterns) {
      return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
    }
    function defaultCode(i) {
      return "var default" + i + " = defaults[" + i + "];";
    }
    function refValCode(i, refVal) {
      return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
    }
    function customRuleCode(i) {
      return "var customRule" + i + " = customRules[" + i + "];";
    }
    function vars(arr, statement) {
      if (!arr.length)
        return "";
      var code = "";
      for (var i = 0; i < arr.length; i++)
        code += statement(i, arr);
      return code;
    }
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/cache.js
var require_cache = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/cache.js"(exports2, module2) {
    "use strict";
    var Cache = module2.exports = function Cache2() {
      this._cache = {};
    };
    Cache.prototype.put = function Cache_put(key, value) {
      this._cache[key] = value;
    };
    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };
    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };
    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/formats.js
var require_formats = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/formats.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    module2.exports = formats;
    function formats(mode) {
      mode = mode == "full" ? "full" : "fast";
      return util.copy(formats[mode]);
    }
    formats.fast = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      "uri-template": URITEMPLATE,
      url: URL,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: UUID,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    formats.full = {
      date,
      time,
      "date-time": date_time,
      uri,
      "uri-reference": URIREF,
      "uri-template": URITEMPLATE,
      url: URL,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function date(str) {
      var matches = str.match(DATE);
      if (!matches)
        return false;
      var year = +matches[1];
      var month = +matches[2];
      var day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function time(str, full) {
      var matches = str.match(TIME);
      if (!matches)
        return false;
      var hour = matches[1];
      var minute = matches[2];
      var second = matches[3];
      var timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_ref(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $async, $refCode;
      if ($schema == "#" || $schema == "#/") {
        if (it.isRoot) {
          $async = it.async;
          $refCode = "validate";
        } else {
          $async = it.root.schema.$async === true;
          $refCode = "root.refVal[0]";
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === void 0) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == "fail") {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            if ($breakOnError) {
              out += " if (false) { ";
            }
          } else if (it.opts.missingRefs == "ignore") {
            it.logger.warn($message);
            if ($breakOnError) {
              out += " if (true) { ";
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = "";
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += " " + $code + " ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
          }
        } else {
          $async = $refVal.$async === true || it.async && $refVal.$async !== false;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.opts.passContext) {
          out += " " + $refCode + ".call(this, ";
        } else {
          out += " " + $refCode + "( ";
        }
        out += " " + $data + ", (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async)
            throw new Error("async schema referenced by sync schema");
          if ($breakOnError) {
            out += " var " + $valid + "; ";
          }
          out += " try { await " + __callValidate + "; ";
          if ($breakOnError) {
            out += " " + $valid + " = true; ";
          }
          out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
          if ($breakOnError) {
            out += " " + $valid + " = false; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " if (" + $valid + ") { ";
          }
        } else {
          out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/allOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_allOf(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += " if (true) { ";
        } else {
          out += " " + $closingBraces.slice(0, -1) + " ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/anyOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_anyOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $noEmptySchema = $schema.every(function($sch2) {
        return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
            $closingBraces += "}";
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should match some schema in anyOf' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/comment.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_comment(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $comment = it.util.toQuotedString($schema);
      if (it.opts.$comment === true) {
        out += " console.log(" + $comment + ");";
      } else if (typeof it.opts.$comment == "function") {
        out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/const.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_const(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to constant' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/contains.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_contains(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        out += " if (" + $nextValid + ") break; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
      } else {
        out += " if (" + $data + ".length == 0) {";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should contain a valid item' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else { ";
      if ($nonEmptySchema) {
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      }
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/dependencies.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_dependencies(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        if ($property == "__proto__")
          continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += "var " + $errs + " = errors;";
      var $currentErrorPath = it.errorPath;
      out += "var missing" + $lvl + ";";
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          if ($breakOnError) {
            out += " && ( ";
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ")) {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            out += " ) { ";
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey, i2 = -1, l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should have ";
                    if ($deps.length == 1) {
                      out += "property " + it.util.escapeQuotes($deps[0]);
                    } else {
                      out += "properties " + it.util.escapeQuotes($deps.join(", "));
                    }
                    out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
          out += " }   ";
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          out += ") { ";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
      if ($breakOnError) {
        out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_enum(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
      if (!$isData) {
        out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + ";";
      if ($isData) {
        out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
      }
      out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to one of the allowed values' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/format.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_format(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it.async) {
          out += " var async" + $lvl + " = " + $format + ".async; ";
        }
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " (";
        if ($unknownFormats != "ignore") {
          out += " (" + $schemaValue + " && !" + $format + " ";
          if ($allowUnknown) {
            out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
          }
          out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it.async) {
          out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        } else {
          out += " " + $format + "(" + $data + ") ";
        }
        out += " : " + $format + ".test(" + $data + "))))) {";
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == "ignore") {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        if ($async) {
          if (!it.async)
            throw new Error("async format in sync schema");
          var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
          out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
        } else {
          out += " if (! ";
          var $formatRef = "formats" + it.util.getProperty($schema);
          if ($isObject)
            $formatRef += ".validate";
          if (typeof $format == "function") {
            out += " " + $formatRef + "(" + $data + ") ";
          } else {
            out += " " + $formatRef + ".test(" + $data + ") ";
          }
          out += ") { ";
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match format "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/if.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_if(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
      if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
          out += " if (" + $nextValid + ") {  ";
          $it.schema = it.schema["then"];
          $it.schemaPath = it.schemaPath + ".then";
          $it.errSchemaPath = it.errSchemaPath + "/then";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'then'; ";
          } else {
            $ifClause = "'then'";
          }
          out += " } ";
          if ($elsePresent) {
            out += " else { ";
          }
        } else {
          out += " if (!" + $nextValid + ") { ";
        }
        if ($elsePresent) {
          $it.schema = it.schema["else"];
          $it.schemaPath = it.schemaPath + ".else";
          $it.errSchemaPath = it.errSchemaPath + "/else";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'else'; ";
          } else {
            $ifClause = "'else'";
          }
          out += " } ";
        }
        out += " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " }   ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/items.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_items(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT have more than " + $schema.length + " items' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
              var $passData = $data + "[" + $i + "]";
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + ".additionalItems";
          $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limit.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limit(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
      if (!($isData || typeof $schema == "number" || $schema === void 0)) {
        throw new Error($keyword + " must be number");
      }
      if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
        throw new Error($exclusiveKeyword + " must be number or boolean");
      }
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
        if ($schema === void 0) {
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaValueExcl;
          $isData = $isDataExcl;
        }
      } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
          if ($exclIsNumber && $schema === void 0) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += "=";
          } else {
            if ($exclIsNumber)
              $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
              $notOp += "=";
            } else {
              $exclusive = false;
              $opStr += "=";
            }
          }
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be " + $opStr + " ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitItems.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxItems" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxItems") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitLength.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitLength(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxLength" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      if (it.opts.unicode === false) {
        out += " " + $data + ".length ";
      } else {
        out += " ucs2length(" + $data + ") ";
      }
      out += " " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be ";
          if ($keyword == "maxLength") {
            out += "longer";
          } else {
            out += "shorter";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " characters' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitProperties.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitProperties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxProperties" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxProperties") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " properties' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/multipleOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_multipleOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      out += "var division" + $lvl + ";if (";
      if ($isData) {
        out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
      }
      out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
      if (it.opts.multipleOfPrecision) {
        out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
      } else {
        out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
      }
      out += " ) ";
      if ($isData) {
        out += "  )  ";
      }
      out += " ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be multiple of ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/not.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_not(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += " " + it.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption)
          $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        out += "  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) {
          out += " if (false) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/oneOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_oneOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
      out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
          } else {
            out += " var " + $nextValid + " = true; ";
          }
          if ($i) {
            out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
            $closingBraces += "}";
          }
          out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match exactly one schema in oneOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/pattern.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_pattern(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $regexp + ".test(" + $data + ") ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match pattern "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/properties.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_properties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
      var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
        var $requiredHash = it.util.toHash($required);
      }
      function notProto(p) {
        return p !== "__proto__";
      }
      out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined;";
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        if ($someProperties) {
          out += " var isAdditional" + $lvl + " = !(false ";
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 8) {
              out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
              }
            }
          }
          out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = "' + " + $key + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += " delete " + $data + "[" + $key + "]; ";
            } else {
              out += " " + $nextValid + " = false; ";
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + "/additionalProperties";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is an invalid additional property";
                  } else {
                    out += "should NOT have additional properties";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += " break; ";
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == "failing") {
              out += " var " + $errs + " = errors;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += " } ";
        }
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $sch = $schema[$propertyKey];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += " var " + $nextData + " = " + $passData + "; ";
              }
              if ($hasDefault) {
                out += " " + $code + " ";
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = false; ";
                  var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + "/required";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += " } else { ";
                } else {
                  if ($breakOnError) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = true; } else { ";
                  } else {
                    out += " if (" + $useData + " !== undefined ";
                    if ($ownProperties) {
                      out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += " ) { ";
                  }
                }
                out += " " + $code + " } ";
              }
            }
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
          var $pProperty, i4 = -1, l4 = arr4.length - 1;
          while (i4 < l4) {
            $pProperty = arr4[i4 += 1];
            var $sch = $pProperties[$pProperty];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else " + $nextValid + " = true; ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/propertyNames.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_propertyNames(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      out += "var " + $errs + " = errors;";
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined; ";
        }
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        if ($breakOnError) {
          out += " break; ";
        }
        out += " } }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/required.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_required(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = "schema" + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += " var missing" + $lvl + "; ";
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += " var " + $valid + " = true; ";
            if ($isData) {
              out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
            if ($ownProperties) {
              out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += "; if (!" + $valid + ") break; } ";
            if ($isData) {
              out += "  }  ";
            }
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          } else {
            out += " if ( ";
            var arr2 = $required;
            if (arr2) {
              var $propertyKey, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ") {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) {
              out += "  }  ";
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey, i3 = -1, l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += " if (true) {";
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/uniqueItems.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        }
        out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
        var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
          out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
        } else {
          out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
          var $method = "checkDataType" + ($typeIsArray ? "s" : "");
          out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
          if ($typeIsArray) {
            out += ` if (typeof item == 'string') item = '"' + item; `;
          }
          out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
        }
        out += " } ";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "$ref": require_ref(),
      allOf: require_allOf(),
      anyOf: require_anyOf(),
      "$comment": require_comment(),
      const: require_const(),
      contains: require_contains(),
      dependencies: require_dependencies(),
      "enum": require_enum(),
      format: require_format(),
      "if": require_if(),
      items: require_items(),
      maximum: require_limit(),
      minimum: require_limit(),
      maxItems: require_limitItems(),
      minItems: require_limitItems(),
      maxLength: require_limitLength(),
      minLength: require_limitLength(),
      maxProperties: require_limitProperties(),
      minProperties: require_limitProperties(),
      multipleOf: require_multipleOf(),
      not: require_not(),
      oneOf: require_oneOf(),
      pattern: require_pattern(),
      properties: require_properties(),
      propertyNames: require_propertyNames(),
      required: require_required(),
      uniqueItems: require_uniqueItems(),
      validate: require_validate()
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/rules.js
var require_rules = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/rules.js"(exports2, module2) {
    "use strict";
    var ruleModules = require_dotjs();
    var toHash = require_util().toHash;
    module2.exports = function rules() {
      var RULES = [
        {
          type: "number",
          rules: [
            { "maximum": ["exclusiveMaximum"] },
            { "minimum": ["exclusiveMinimum"] },
            "multipleOf",
            "format"
          ]
        },
        {
          type: "string",
          rules: ["maxLength", "minLength", "pattern", "format"]
        },
        {
          type: "array",
          rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
        },
        {
          type: "object",
          rules: [
            "maxProperties",
            "minProperties",
            "required",
            "dependencies",
            "propertyNames",
            { "properties": ["additionalProperties", "patternProperties"] }
          ]
        },
        { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
      ];
      var ALL = ["type", "$comment"];
      var KEYWORDS = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else"
      ];
      var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);
      RULES.forEach(function(group) {
        group.rules = group.rules.map(function(keyword) {
          var implKeywords;
          if (typeof keyword == "object") {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function(k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });
        RULES.all.$comment = {
          keyword: "$comment",
          code: ruleModules.$comment
        };
        if (group.type)
          RULES.types[group.type] = group;
      });
      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};
      return RULES;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/data.js
var require_data = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/data.js"(exports2, module2) {
    "use strict";
    var KEYWORDS = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum",
      "maxLength",
      "minLength",
      "pattern",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "maxProperties",
      "minProperties",
      "required",
      "additionalProperties",
      "enum",
      "format",
      "const"
    ];
    module2.exports = function(metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split("/");
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++)
          keywords = keywords[segments[j]];
        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema = keywords[key];
          if (schema) {
            keywords[key] = {
              anyOf: [
                schema,
                { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
        }
      }
      return metaSchema;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/async.js
var require_async3 = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/async.js"(exports2, module2) {
    "use strict";
    var MissingRefError = require_error_classes().MissingRef;
    module2.exports = compileAsync;
    function compileAsync(schema, meta, callback) {
      var self2 = this;
      if (typeof this._opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      if (typeof meta == "function") {
        callback = meta;
        meta = void 0;
      }
      var p = loadMetaSchemaOf(schema).then(function() {
        var schemaObj = self2._addSchema(schema, void 0, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });
      if (callback) {
        p.then(
          function(v) {
            callback(null, v);
          },
          callback
        );
      }
      return p;
      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
      }
      function _compileAsync(schemaObj) {
        try {
          return self2._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError)
            return loadMissingSchema(e);
          throw e;
        }
        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref))
            throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
          var schemaPromise = self2._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }
          return schemaPromise.then(function(sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function() {
                if (!added(ref))
                  self2.addSchema(sch, ref, void 0, meta);
              });
            }
          }).then(function() {
            return _compileAsync(schemaObj);
          });
          function removePromise() {
            delete self2._loadingSchemas[ref];
          }
          function added(ref2) {
            return self2._refs[ref2] || self2._schemas[ref2];
          }
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/custom.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_custom(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate)
          return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async)
        throw new Error("async keyword in sync schema");
      if (!($inline || $macro)) {
        out += "" + $ruleErrs + " = null;";
      }
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
          $closingBraces += "}";
          out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += " " + $ruleValidate.validate + " ";
        } else {
          out += " " + $valid + " = " + $ruleValidate.validate + "; ";
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it.opts.passContext) {
          out += "this";
        } else {
          out += "self";
        }
        if ($compile || $rDef.schema === false) {
          out += " , " + $data + " ";
        } else {
          out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
        }
        out += " , (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += " " + $valid + " = ";
          if ($asyncKeyword) {
            out += "await ";
          }
          out += "" + def_callRuleValidate + "; ";
        } else {
          if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
          } else {
            out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
          }
        }
      }
      if ($rDef.modifying) {
        out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
      }
      out += "" + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        out += " if ( ";
        if ($rDef.valid === void 0) {
          out += " !";
          if ($macro) {
            out += "" + $nextValid;
          } else {
            out += "" + $valid;
          }
        } else {
          out += " " + !$rDef.valid + " ";
        }
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != "full") {
              out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } ";
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } ";
            }
          }
        } else if ($macro) {
          out += "   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } else { " + def_customError + " } ";
          }
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/definition_schema.js"(exports2, module2) {
    "use strict";
    var metaSchema = require_json_schema_draft_07();
    module2.exports = {
      $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
      definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
      },
      type: "object",
      dependencies: {
        schema: ["validate"],
        $data: ["validate"],
        statements: ["inline"],
        valid: { not: { required: ["macro"] } }
      },
      properties: {
        type: metaSchema.properties.type,
        schema: { type: "boolean" },
        statements: { type: "boolean" },
        dependencies: {
          type: "array",
          items: { type: "string" }
        },
        metaSchema: { type: "object" },
        modifying: { type: "boolean" },
        valid: { type: "boolean" },
        $data: { type: "boolean" },
        async: { type: "boolean" },
        errors: {
          anyOf: [
            { type: "boolean" },
            { const: "full" }
          ]
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/keyword.js"(exports2, module2) {
    "use strict";
    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require_custom();
    var definitionSchema = require_definition_schema();
    module2.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword,
      validate: validateKeyword
    };
    function addKeyword(keyword, definition) {
      var RULES = this.RULES;
      if (RULES.keywords[keyword])
        throw new Error("Keyword " + keyword + " is already defined");
      if (!IDENTIFIER.test(keyword))
        throw new Error("Keyword " + keyword + " is not a valid identifier");
      if (definition) {
        this.validateKeyword(definition, true);
        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          for (var i = 0; i < dataType.length; i++)
            _addRule(keyword, dataType[i], definition);
        } else {
          _addRule(keyword, dataType, definition);
        }
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if (definition.$data && this._opts.$data) {
            metaSchema = {
              anyOf: [
                metaSchema,
                { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }
      RULES.keywords[keyword] = RULES.all[keyword] = true;
      function _addRule(keyword2, dataType2, definition2) {
        var ruleGroup;
        for (var i2 = 0; i2 < RULES.length; i2++) {
          var rg = RULES[i2];
          if (rg.type == dataType2) {
            ruleGroup = rg;
            break;
          }
        }
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.push(ruleGroup);
        }
        var rule = {
          keyword: keyword2,
          definition: definition2,
          custom: true,
          code: customRuleCode,
          implements: definition2.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword2] = rule;
      }
      return this;
    }
    function getKeyword(keyword) {
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }
    function removeKeyword(keyword) {
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
    function validateKeyword(definition, throwError) {
      validateKeyword.errors = null;
      var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
      if (v(definition))
        return true;
      validateKeyword.errors = v.errors;
      if (throwError)
        throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
      else
        return false;
    }
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/data.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON Schema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" }
          ]
        }
      },
      additionalProperties: false
    };
  }
});

// ../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS({
  "../../node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/ajv.js"(exports2, module2) {
    "use strict";
    var compileSchema = require_compile();
    var resolve = require_resolve3();
    var Cache = require_cache();
    var SchemaObject = require_schema_obj();
    var stableStringify = require_fast_json_stable_stringify();
    var formats = require_formats();
    var rules = require_rules();
    var $dataMetaSchema = require_data();
    var util = require_util();
    module2.exports = Ajv;
    Ajv.prototype.validate = validate;
    Ajv.prototype.compile = compile;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;
    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;
    Ajv.prototype.compileAsync = require_async3();
    var customKeyword = require_keyword();
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;
    Ajv.prototype.validateKeyword = customKeyword.validate;
    var errorClasses = require_error_classes();
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
    var META_SUPPORT_DATA = ["/properties"];
    function Ajv(opts) {
      if (!(this instanceof Ajv))
        return new Ajv(opts);
      opts = this._opts = util.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);
      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == "property")
        opts._errorDataPathProperty = true;
      if (opts.serialize === void 0)
        opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);
      if (opts.formats)
        addInitialFormats(this);
      if (opts.keywords)
        addInitialKeywords(this);
      addDefaultMetaSchema(this);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      if (opts.nullable)
        this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
      addInitialSchemas(this);
    }
    function validate(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }
      var valid = v(data);
      if (v.$async !== true)
        this.errors = v.errors;
      return valid;
    }
    function compile(schema, _meta) {
      var schemaObj = this._addSchema(schema, void 0, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }
    function addSchema(schema, key, _skipValidation, _meta) {
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++)
          this.addSchema(schema[i], void 0, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema);
      if (id !== void 0 && typeof id != "string")
        throw new Error("schema id must be string");
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
      return this;
    }
    function addMetaSchema(schema, key, skipValidation) {
      this.addSchema(schema, key, skipValidation, true);
      return this;
    }
    function validateSchema(schema, throwOrLogError) {
      var $schema = schema.$schema;
      if ($schema !== void 0 && typeof $schema != "string")
        throw new Error("$schema must be a string");
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      var valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    function defaultMeta(self2) {
      var meta = self2._opts.meta;
      self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
      return self2._opts.defaultMeta;
    }
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case "object":
          return schemaObj.validate || this._compile(schemaObj);
        case "string":
          return this.getSchema(schemaObj);
        case "undefined":
          return _getSchemaFragment(this, keyRef);
      }
    }
    function _getSchemaFragment(self2, ref) {
      var res = resolve.schema.call(self2, { schema: {} }, ref);
      if (res) {
        var schema = res.schema, root = res.root, baseId = res.baseId;
        var v = compileSchema.call(self2, schema, root, void 0, baseId);
        self2._fragments[ref] = new SchemaObject({
          ref,
          fragment: true,
          schema,
          root,
          baseId,
          validate: v
        });
        return v;
      }
    }
    function _getSchemaObj(self2, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
    }
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case "string":
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj)
            this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case "object":
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }
    function _removeAllSchemas(self2, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self2._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }
    function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
      if (typeof schema != "object" && typeof schema != "boolean")
        throw new Error("schema should be object or boolean");
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema) : schema;
      var cached = this._cache.get(cacheKey);
      if (cached)
        return cached;
      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
      var id = resolve.normalizeId(this._getId(schema));
      if (id && shouldAddSchema)
        checkUnique(this, id);
      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
        this.validateSchema(schema, true);
      var localRefs = resolve.ids.call(this, schema);
      var schemaObj = new SchemaObject({
        id,
        schema,
        localRefs,
        cacheKey,
        meta
      });
      if (id[0] != "#" && shouldAddSchema)
        this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);
      if (willValidate && recursiveMeta)
        this.validateSchema(schema, true);
      return schemaObj;
    }
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true)
          callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;
      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }
      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
      } catch (e) {
        delete schemaObj.validate;
        throw e;
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta)
          this._opts = currentOpts;
      }
      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;
      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }
    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case "auto":
          return _get$IdOrId;
        case "id":
          return _getId;
        default:
          return _get$Id;
      }
    }
    function _getId(schema) {
      if (schema.$id)
        this.logger.warn("schema $id ignored", schema.$id);
      return schema.id;
    }
    function _get$Id(schema) {
      if (schema.id)
        this.logger.warn("schema id ignored", schema.id);
      return schema.$id;
    }
    function _get$IdOrId(schema) {
      if (schema.$id && schema.id && schema.$id != schema.id)
        throw new Error("schema $id is different from id");
      return schema.$id || schema.id;
    }
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors)
        return "No errors";
      options = options || {};
      var separator = options.separator === void 0 ? ", " : options.separator;
      var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
      var text = "";
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e)
          text += dataVar + e.dataPath + " " + e.message + separator;
      }
      return text.slice(0, -separator.length);
    }
    function addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }
    function addDefaultMetaSchema(self2) {
      var $dataSchema;
      if (self2._opts.$data) {
        $dataSchema = require_data2();
        self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self2._opts.meta === false)
        return;
      var metaSchema = require_json_schema_draft_07();
      if (self2._opts.$data)
        metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    function addInitialSchemas(self2) {
      var optsSchemas = self2._opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        self2.addSchema(optsSchemas);
      else
        for (var key in optsSchemas)
          self2.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats(self2) {
      for (var name in self2._opts.formats) {
        var format = self2._opts.formats[name];
        self2.addFormat(name, format);
      }
    }
    function addInitialKeywords(self2) {
      for (var name in self2._opts.keywords) {
        var keyword = self2._opts.keywords[name];
        self2.addKeyword(name, keyword);
      }
    }
    function checkUnique(self2, id) {
      if (self2._schemas[id] || self2._refs[id])
        throw new Error('schema with key or id "' + id + '" already exists');
    }
    function getMetaSchemaOptions(self2) {
      var metaOpts = util.copy(self2._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
        delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }
    function setLogger(self2) {
      var logger = self2._opts.logger;
      if (logger === false) {
        self2.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger === void 0)
          logger = console;
        if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
          throw new Error("logger must implement log, warn and error methods");
        self2.logger = logger;
      }
    }
    function noop() {
    }
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc-config@0.16.2/node_modules/@microsoft/tsdoc-config/lib/TSDocConfigFile.js
var require_TSDocConfigFile = __commonJS({
  "../../node_modules/.pnpm/@microsoft+tsdoc-config@0.16.2/node_modules/@microsoft/tsdoc-config/lib/TSDocConfigFile.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TSDocConfigFile = void 0;
    var tsdoc_1 = (init_lib(), __toCommonJS(lib_exports));
    var fs2 = __importStar(require("fs"));
    var resolve = __importStar(require_resolve2());
    var path = __importStar(require("path"));
    var ajv_1 = __importDefault(require_ajv());
    var jju = __importStar(require_jju());
    var ajv = new ajv_1.default({ verbose: true });
    function initializeSchemaValidator() {
      const jsonSchemaPath = resolve.sync("@microsoft/tsdoc/schemas/tsdoc.schema.json", { basedir: __dirname });
      const jsonSchemaContent = fs2.readFileSync(jsonSchemaPath).toString();
      const jsonSchema = jju.parse(jsonSchemaContent, { mode: "cjson" });
      return ajv.compile(jsonSchema);
    }
    var tsdocSchemaValidator = initializeSchemaValidator();
    var TSDocConfigFile = class _TSDocConfigFile {
      constructor() {
        this.log = new tsdoc_1.ParserMessageLog();
        this._extendsFiles = [];
        this._filePath = "";
        this._fileNotFound = false;
        this._hasErrors = false;
        this._fileMTime = 0;
        this._tsdocSchema = "";
        this._extendsPaths = [];
        this._noStandardTags = void 0;
        this._tagDefinitions = [];
        this._tagDefinitionNames = /* @__PURE__ */ new Set();
        this._supportForTags = /* @__PURE__ */ new Map();
      }
      /**
       * Other config files that this file extends from.
       */
      get extendsFiles() {
        return this._extendsFiles;
      }
      /**
       * The full path of the file that was attempted to load, or an empty string if the configuration was
       * loaded from a source that is not a file.
       */
      get filePath() {
        return this._filePath;
      }
      /**
       * If true, then the TSDocConfigFile object contains an empty state, because the `tsdoc.json` file
       * was not found by the loader.
       *
       * @remarks
       * A missing "tsdoc.json" file is not considered an error.  It simply means that the defaults will be used.
       */
      get fileNotFound() {
        return this._fileNotFound;
      }
      /**
       * If true, then at least one error was encountered while loading this file or one of its "extends" files.
       *
       * @remarks
       * You can use {@link TSDocConfigFile.getErrorSummary} to report these errors.
       *
       * The individual messages can be retrieved from the {@link TSDocConfigFile.log} property of each `TSDocConfigFile`
       * object (including the {@link TSDocConfigFile.extendsFiles} tree).
       */
      get hasErrors() {
        return this._hasErrors;
      }
      /**
       * The `$schema` field from the `tsdoc.json` file.
       */
      get tsdocSchema() {
        return this._tsdocSchema;
      }
      /**
       * The `extends` field from the `tsdoc.json` file.  For the parsed file contents,
       * use the `extendsFiles` property instead.
       */
      get extendsPaths() {
        return this._extendsPaths;
      }
      /**
       * By default, the config file loader will predefine all of the standardized TSDoc tags.  To disable this and
       * start with a completely empty configuration, set `noStandardTags` to true.
       *
       * @remarks
       * If a config file uses `"extends"` to include settings from base config files, then its setting will
       * override any settings from the base config files.  If `"noStandardTags"` is not specified, then this
       * property will be `undefined`.  The config files are applied in the order they are processed (a depth-first
       * traversal of the `"extends"` references), and files processed later can override earlier files.
       * If no config file specifies `noStandardTags` then the default value is `false`.
       */
      get noStandardTags() {
        return this._noStandardTags;
      }
      set noStandardTags(value) {
        this._noStandardTags = value;
      }
      get tagDefinitions() {
        return this._tagDefinitions;
      }
      get supportForTags() {
        return this._supportForTags;
      }
      get supportedHtmlElements() {
        return this._supportedHtmlElements && Array.from(this._supportedHtmlElements);
      }
      get reportUnsupportedHtmlElements() {
        return this._reportUnsupportedHtmlElements;
      }
      set reportUnsupportedHtmlElements(value) {
        this._reportUnsupportedHtmlElements = value;
      }
      /**
       * Removes all items from the `tagDefinitions` array.
       */
      clearTagDefinitions() {
        this._tagDefinitions.length = 0;
        this._tagDefinitionNames.clear();
      }
      /**
       * Adds a new item to the `tagDefinitions` array.
       */
      addTagDefinition(parameters) {
        const tagDefinition = new tsdoc_1.TSDocTagDefinition(parameters);
        if (this._tagDefinitionNames.has(tagDefinition.tagNameWithUpperCase)) {
          throw new Error(`A tag definition was already added with the tag name "${parameters.tagName}"`);
        }
        this._tagDefinitionNames.add(tagDefinition.tagName);
        this._tagDefinitions.push(tagDefinition);
      }
      // Similar to addTagDefinition() but reports errors using _reportError()
      _addTagDefinitionForLoad(parameters) {
        let tagDefinition;
        try {
          tagDefinition = new tsdoc_1.TSDocTagDefinition(parameters);
        } catch (error) {
          this._reportError({
            messageId: tsdoc_1.TSDocMessageId.ConfigFileInvalidTagName,
            messageText: error.message,
            textRange: tsdoc_1.TextRange.empty
          });
          return;
        }
        if (this._tagDefinitionNames.has(tagDefinition.tagNameWithUpperCase)) {
          this._reportError({
            messageId: tsdoc_1.TSDocMessageId.ConfigFileDuplicateTagName,
            messageText: `The "tagDefinitions" field specifies more than one tag with the name "${parameters.tagName}"`,
            textRange: tsdoc_1.TextRange.empty
          });
        }
        this._tagDefinitionNames.add(tagDefinition.tagNameWithUpperCase);
        this._tagDefinitions.push(tagDefinition);
      }
      /**
       * Adds a new item to the `supportedHtmlElements` array.
       */
      addSupportedHtmlElement(htmlElement) {
        if (!this._supportedHtmlElements) {
          this._supportedHtmlElements = /* @__PURE__ */ new Set();
        }
        this._supportedHtmlElements.add(htmlElement);
      }
      /**
       * Removes the explicit list of allowed html elements.
       */
      clearSupportedHtmlElements() {
        this._supportedHtmlElements = void 0;
      }
      /**
       * Removes all entries from the "supportForTags" map.
       */
      clearSupportForTags() {
        this._supportForTags.clear();
      }
      /**
       * Sets an entry in the "supportForTags" map.
       */
      setSupportForTag(tagName, supported) {
        tsdoc_1.TSDocTagDefinition.validateTSDocTagName(tagName);
        this._supportForTags.set(tagName, supported);
      }
      /**
       * This can be used for cache eviction.  It returns true if the modification timestamp has changed for
       * any of the files that were read when loading this `TSDocConfigFile`, which indicates that the file should be
       * reloaded.  It does not consider cases where `TSDocConfigFile.fileNotFound` was `true`.
       *
       * @remarks
       * This can be used for cache eviction.  An example eviction strategy might be like this:
       *
       * - call `checkForModifiedFiles()` once per second, and reload the configuration if it returns true
       *
       * - otherwise, reload the configuration when it is more than 10 seconds old (to handle less common cases such
       *   as creation of a missing file, or creation of a file at an earlier location in the search path).
       */
      checkForModifiedFiles() {
        if (this._checkForModifiedFile()) {
          return true;
        }
        for (const extendsFile of this.extendsFiles) {
          if (extendsFile.checkForModifiedFiles()) {
            return true;
          }
        }
        return false;
      }
      /**
       * Checks the last modification time for `TSDocConfigFile.filePath` and returns `true` if it has changed
       * since the file was loaded.  If the file is missing, this returns `false`.  If the timestamp cannot be read,
       * then this returns `true`.
       */
      _checkForModifiedFile() {
        if (this._fileNotFound || !this._filePath) {
          return false;
        }
        try {
          const mtimeMs = fs2.statSync(this._filePath).mtimeMs;
          return mtimeMs !== this._fileMTime;
        } catch (error) {
          return true;
        }
      }
      _reportError(parserMessageParameters) {
        this.log.addMessage(new tsdoc_1.ParserMessage(parserMessageParameters));
        this._hasErrors = true;
      }
      _loadJsonObject(configJson) {
        if (configJson.$schema !== _TSDocConfigFile.CURRENT_SCHEMA_URL) {
          this._reportError({
            messageId: tsdoc_1.TSDocMessageId.ConfigFileUnsupportedSchema,
            messageText: `Unsupported JSON "$schema" value; expecting "${_TSDocConfigFile.CURRENT_SCHEMA_URL}"`,
            textRange: tsdoc_1.TextRange.empty
          });
          return;
        }
        const success = tsdocSchemaValidator(configJson);
        if (!success) {
          const description = ajv.errorsText(tsdocSchemaValidator.errors);
          this._reportError({
            messageId: tsdoc_1.TSDocMessageId.ConfigFileSchemaError,
            messageText: "Error loading config file: " + description,
            textRange: tsdoc_1.TextRange.empty
          });
          return;
        }
        this._tsdocSchema = configJson.$schema;
        if (configJson.extends) {
          this._extendsPaths.push(...configJson.extends);
        }
        this.noStandardTags = configJson.noStandardTags;
        for (const jsonTagDefinition of configJson.tagDefinitions || []) {
          let syntaxKind;
          switch (jsonTagDefinition.syntaxKind) {
            case "inline":
              syntaxKind = tsdoc_1.TSDocTagSyntaxKind.InlineTag;
              break;
            case "block":
              syntaxKind = tsdoc_1.TSDocTagSyntaxKind.BlockTag;
              break;
            case "modifier":
              syntaxKind = tsdoc_1.TSDocTagSyntaxKind.ModifierTag;
              break;
            default:
              throw new Error("Unexpected tag kind");
          }
          this._addTagDefinitionForLoad({
            tagName: jsonTagDefinition.tagName,
            syntaxKind,
            allowMultiple: jsonTagDefinition.allowMultiple
          });
        }
        if (configJson.supportedHtmlElements) {
          this._supportedHtmlElements = /* @__PURE__ */ new Set();
          for (const htmlElement of configJson.supportedHtmlElements) {
            this.addSupportedHtmlElement(htmlElement);
          }
        }
        this._reportUnsupportedHtmlElements = configJson.reportUnsupportedHtmlElements;
        if (configJson.supportForTags) {
          for (const tagName of Object.keys(configJson.supportForTags)) {
            const supported = configJson.supportForTags[tagName];
            this._supportForTags.set(tagName, supported);
          }
        }
      }
      _loadWithExtends(configFilePath, referencingConfigFile, alreadyVisitedPaths) {
        this._fileNotFound = true;
        if (!configFilePath) {
          this._reportError({
            messageId: tsdoc_1.TSDocMessageId.ConfigFileNotFound,
            messageText: "File not found",
            textRange: tsdoc_1.TextRange.empty
          });
          return;
        }
        this._filePath = path.resolve(configFilePath);
        if (!fs2.existsSync(this._filePath)) {
          this._reportError({
            messageId: tsdoc_1.TSDocMessageId.ConfigFileNotFound,
            messageText: "File not found",
            textRange: tsdoc_1.TextRange.empty
          });
          return;
        }
        const configJsonContent = fs2.readFileSync(this._filePath).toString();
        this._fileMTime = fs2.statSync(this._filePath).mtimeMs;
        this._fileNotFound = false;
        const hashKey = fs2.realpathSync(this._filePath);
        if (referencingConfigFile && alreadyVisitedPaths.has(hashKey)) {
          this._reportError({
            messageId: tsdoc_1.TSDocMessageId.ConfigFileCyclicExtends,
            messageText: `Circular reference encountered for "extends" field of "${referencingConfigFile.filePath}"`,
            textRange: tsdoc_1.TextRange.empty
          });
          return;
        }
        alreadyVisitedPaths.add(hashKey);
        let configJson;
        try {
          configJson = jju.parse(configJsonContent, { mode: "cjson" });
        } catch (e) {
          this._reportError({
            messageId: tsdoc_1.TSDocMessageId.ConfigInvalidJson,
            messageText: "Error parsing JSON input: " + e.message,
            textRange: tsdoc_1.TextRange.empty
          });
          return;
        }
        this._loadJsonObject(configJson);
        const configFileFolder = path.dirname(this.filePath);
        for (const extendsField of this.extendsPaths) {
          let resolvedExtendsPath;
          try {
            resolvedExtendsPath = resolve.sync(extendsField, { basedir: configFileFolder });
          } catch (e) {
            this._reportError({
              messageId: tsdoc_1.TSDocMessageId.ConfigFileUnresolvedExtends,
              messageText: `Unable to resolve "extends" reference to "${extendsField}": ` + e.message,
              textRange: tsdoc_1.TextRange.empty
            });
            return;
          }
          const baseConfigFile = new _TSDocConfigFile();
          baseConfigFile._loadWithExtends(resolvedExtendsPath, this, alreadyVisitedPaths);
          if (baseConfigFile.fileNotFound) {
            this._reportError({
              messageId: tsdoc_1.TSDocMessageId.ConfigFileUnresolvedExtends,
              messageText: `Unable to resolve "extends" reference to "${extendsField}"`,
              textRange: tsdoc_1.TextRange.empty
            });
          }
          this._extendsFiles.push(baseConfigFile);
          if (baseConfigFile.hasErrors) {
            this._hasErrors = true;
          }
        }
      }
      /**
       * For the given folder, look for the relevant tsdoc.json file (if any), and return its path.
       *
       * @param folderPath - the path to a folder where the search should start
       * @returns the (possibly relative) path to tsdoc.json, or an empty string if not found
       */
      static findConfigPathForFolder(folderPath) {
        if (folderPath) {
          let foundFolder = folderPath;
          for (; ; ) {
            const tsconfigJsonPath = path.join(foundFolder, "tsconfig.json");
            if (fs2.existsSync(tsconfigJsonPath)) {
              return path.join(foundFolder, _TSDocConfigFile.FILENAME);
            }
            const packageJsonPath = path.join(foundFolder, "package.json");
            if (fs2.existsSync(packageJsonPath)) {
              return path.join(foundFolder, _TSDocConfigFile.FILENAME);
            }
            const previousFolder = foundFolder;
            foundFolder = path.dirname(foundFolder);
            if (!foundFolder || foundFolder === previousFolder) {
              break;
            }
          }
        }
        return "";
      }
      /**
       * Calls `TSDocConfigFile.findConfigPathForFolder()` to find the relevant tsdoc.json config file, if one exists.
       * Then calls `TSDocConfigFile.findConfigPathForFolder()` to return the loaded result.
       *
       * @remarks
       * This API does not report loading errors by throwing exceptions.  Instead, the caller is expected to check
       * for errors using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log},
       * or {@link TSDocConfigFile.getErrorSummary}.
       *
       * @param folderPath - the path to a folder where the search should start
       */
      static loadForFolder(folderPath) {
        const rootConfigPath = _TSDocConfigFile.findConfigPathForFolder(folderPath);
        return _TSDocConfigFile.loadFile(rootConfigPath);
      }
      /**
       * Loads the specified tsdoc.json and any base files that it refers to using the "extends" option.
       *
       * @remarks
       * This API does not report loading errors by throwing exceptions.  Instead, the caller is expected to check
       * for errors using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log},
       * or {@link TSDocConfigFile.getErrorSummary}.
       *
       * @param tsdocJsonFilePath - the path to the tsdoc.json config file
       */
      static loadFile(tsdocJsonFilePath) {
        const configFile = new _TSDocConfigFile();
        const alreadyVisitedPaths = /* @__PURE__ */ new Set();
        configFile._loadWithExtends(tsdocJsonFilePath, void 0, alreadyVisitedPaths);
        return configFile;
      }
      /**
       * Loads the object state from a JSON-serializable object as produced by {@link TSDocConfigFile.saveToObject}.
       *
       * @remarks
       * The serialized object has the same structure as `tsdoc.json`; however the `"extends"` field is not allowed.
       *
       * This API does not report loading errors by throwing exceptions.  Instead, the caller is expected to check
       * for errors using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log},
       * or {@link TSDocConfigFile.getErrorSummary}.
       */
      static loadFromObject(jsonObject) {
        const configFile = new _TSDocConfigFile();
        configFile._loadJsonObject(jsonObject);
        if (configFile.extendsPaths.length > 0) {
          throw new Error('The "extends" field cannot be used with TSDocConfigFile.loadFromObject()');
        }
        return configFile;
      }
      /**
       * Initializes a TSDocConfigFile object using the state from the provided `TSDocConfiguration` object.
       *
       * @remarks
       * This API does not report loading errors by throwing exceptions.  Instead, the caller is expected to check
       * for errors using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log},
       * or {@link TSDocConfigFile.getErrorSummary}.
       */
      static loadFromParser(configuration) {
        const configFile = new _TSDocConfigFile();
        configFile.noStandardTags = true;
        for (const tagDefinition of configuration.tagDefinitions) {
          configFile.addTagDefinition({
            syntaxKind: tagDefinition.syntaxKind,
            tagName: tagDefinition.tagName,
            allowMultiple: tagDefinition.allowMultiple
          });
        }
        for (const tagDefinition of configuration.supportedTagDefinitions) {
          configFile.setSupportForTag(tagDefinition.tagName, true);
        }
        for (const htmlElement of configuration.supportedHtmlElements) {
          configFile.addSupportedHtmlElement(htmlElement);
        }
        configFile.reportUnsupportedHtmlElements = configuration.validation.reportUnsupportedHtmlElements;
        return configFile;
      }
      /**
       * Writes the config file content to a JSON file with the specified file path.
       */
      saveFile(jsonFilePath) {
        const jsonObject = this.saveToObject();
        const jsonContent = JSON.stringify(jsonObject, void 0, 2);
        fs2.writeFileSync(jsonFilePath, jsonContent);
      }
      /**
       * Writes the object state into a JSON-serializable object.
       */
      saveToObject() {
        const configJson = {
          $schema: _TSDocConfigFile.CURRENT_SCHEMA_URL
        };
        if (this.noStandardTags !== void 0) {
          configJson.noStandardTags = this.noStandardTags;
        }
        if (this.tagDefinitions.length > 0) {
          configJson.tagDefinitions = [];
          for (const tagDefinition of this.tagDefinitions) {
            configJson.tagDefinitions.push(_TSDocConfigFile._serializeTagDefinition(tagDefinition));
          }
        }
        if (this.supportForTags.size > 0) {
          configJson.supportForTags = {};
          this.supportForTags.forEach((supported, tagName) => {
            configJson.supportForTags[tagName] = supported;
          });
        }
        if (this.supportedHtmlElements) {
          configJson.supportedHtmlElements = [...this.supportedHtmlElements];
        }
        if (this._reportUnsupportedHtmlElements !== void 0) {
          configJson.reportUnsupportedHtmlElements = this._reportUnsupportedHtmlElements;
        }
        return configJson;
      }
      static _serializeTagDefinition(tagDefinition) {
        let syntaxKind;
        switch (tagDefinition.syntaxKind) {
          case tsdoc_1.TSDocTagSyntaxKind.InlineTag:
            syntaxKind = "inline";
            break;
          case tsdoc_1.TSDocTagSyntaxKind.BlockTag:
            syntaxKind = "block";
            break;
          case tsdoc_1.TSDocTagSyntaxKind.ModifierTag:
            syntaxKind = "modifier";
            break;
          default:
            throw new Error("Unimplemented TSDocTagSyntaxKind");
        }
        const tagConfigJson = {
          tagName: tagDefinition.tagName,
          syntaxKind
        };
        if (tagDefinition.allowMultiple) {
          tagConfigJson.allowMultiple = true;
        }
        return tagConfigJson;
      }
      /**
       * Returns a report of any errors that occurred while attempting to load this file or any files
       * referenced via the "extends" field.
       *
       * @remarks
       * Use {@link TSDocConfigFile.hasErrors} to determine whether any errors occurred.
       */
      getErrorSummary() {
        if (!this._hasErrors) {
          return "No errors.";
        }
        let result = "";
        if (this.log.messages.length > 0) {
          const errorNoun = this.log.messages.length > 1 ? "Errors" : "Error";
          if (this.filePath) {
            result += `${errorNoun} encountered for ${this.filePath}:
`;
          } else {
            result += `${errorNoun} encountered when loading TSDoc configuration:
`;
          }
          for (const message of this.log.messages) {
            result += `  ${message.text}
`;
          }
        }
        for (const extendsFile of this.extendsFiles) {
          if (extendsFile.hasErrors) {
            if (result !== "") {
              result += "\n";
            }
            result += extendsFile.getErrorSummary();
          }
        }
        return result;
      }
      /**
       * Applies the settings from this config file to a TSDoc parser configuration.
       * Any `extendsFile` settings will also applied.
       *
       * @remarks
       * Additional validation is performed during this operation.  The caller is expected to check for errors
       * using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log}, or {@link TSDocConfigFile.getErrorSummary}.
       */
      configureParser(configuration) {
        if (this._getNoStandardTagsWithExtends()) {
          configuration.clear(true);
        } else {
          configuration.clear(false);
        }
        this.updateParser(configuration);
      }
      /**
       * This is the same as {@link configureParser}, but it preserves any previous state.
       *
       * @remarks
       * Additional validation is performed during this operation.  The caller is expected to check for errors
       * using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log}, or {@link TSDocConfigFile.getErrorSummary}.
       */
      updateParser(configuration) {
        for (const extendsFile of this.extendsFiles) {
          extendsFile.updateParser(configuration);
        }
        for (const tagDefinition of this.tagDefinitions) {
          configuration.addTagDefinition(tagDefinition);
        }
        this.supportForTags.forEach((supported, tagName) => {
          const tagDefinition = configuration.tryGetTagDefinition(tagName);
          if (tagDefinition) {
            configuration.setSupportForTag(tagDefinition, supported);
          } else {
            this._reportError({
              messageId: tsdoc_1.TSDocMessageId.ConfigFileUndefinedTag,
              messageText: `The "supportForTags" field refers to an undefined tag ${JSON.stringify(tagName)}.`,
              textRange: tsdoc_1.TextRange.empty
            });
          }
        });
        if (this.supportedHtmlElements) {
          configuration.setSupportedHtmlElements([...this.supportedHtmlElements]);
        }
        if (this._reportUnsupportedHtmlElements === false) {
          configuration.validation.reportUnsupportedHtmlElements = false;
        } else if (this._reportUnsupportedHtmlElements === true) {
          configuration.validation.reportUnsupportedHtmlElements = true;
        }
      }
      _getNoStandardTagsWithExtends() {
        if (this.noStandardTags !== void 0) {
          return this.noStandardTags;
        }
        let result = void 0;
        for (const extendsFile of this.extendsFiles) {
          const extendedValue = extendsFile._getNoStandardTagsWithExtends();
          if (extendedValue !== void 0) {
            result = extendedValue;
          }
        }
        if (result === void 0) {
          result = false;
        }
        return result;
      }
    };
    exports2.TSDocConfigFile = TSDocConfigFile;
    TSDocConfigFile.FILENAME = "tsdoc.json";
    TSDocConfigFile.CURRENT_SCHEMA_URL = "https://developer.microsoft.com/json-schemas/tsdoc/v0/tsdoc.schema.json";
  }
});

// ../../node_modules/.pnpm/@microsoft+tsdoc-config@0.16.2/node_modules/@microsoft/tsdoc-config/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/.pnpm/@microsoft+tsdoc-config@0.16.2/node_modules/@microsoft/tsdoc-config/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TSDocConfigFile_1 = require_TSDocConfigFile();
    Object.defineProperty(exports2, "TSDocConfigFile", { enumerable: true, get: function() {
      return TSDocConfigFile_1.TSDocConfigFile;
    } });
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiPackage.js
var require_ApiPackage = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiPackage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiPackage = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiItemContainerMixin_1 = require_ApiItemContainerMixin();
    var node_core_library_1 = require_lib2();
    var ApiDocumentedItem_1 = require_ApiDocumentedItem();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var DeserializerContext_1 = require_DeserializerContext();
    var tsdoc_1 = (init_lib(), __toCommonJS(lib_exports));
    var tsdoc_config_1 = require_lib3();
    var ApiPackage = class extends (0, ApiItemContainerMixin_1.ApiItemContainerMixin)((0, ApiNameMixin_1.ApiNameMixin)(ApiDocumentedItem_1.ApiDocumentedItem)) {
      constructor(options) {
        super(options);
        this._tsdocConfiguration = options.tsdocConfiguration;
        this._projectFolderUrl = options.projectFolderUrl;
      }
      /** @override */
      static onDeserializeInto(options, context, jsonObject) {
        super.onDeserializeInto(options, context, jsonObject);
        options.projectFolderUrl = jsonObject.projectFolderUrl;
      }
      static loadFromJsonFile(apiJsonFilename) {
        const jsonObject = node_core_library_1.JsonFile.load(apiJsonFilename);
        if (!jsonObject || !jsonObject.metadata || typeof jsonObject.metadata.schemaVersion !== "number") {
          throw new Error(`Error loading ${apiJsonFilename}:
The file format is not recognized; the "metadata.schemaVersion" field is missing or invalid`);
        }
        const schemaVersion = jsonObject.metadata.schemaVersion;
        if (schemaVersion < DeserializerContext_1.ApiJsonSchemaVersion.OLDEST_SUPPORTED) {
          throw new Error(`Error loading ${apiJsonFilename}:
The file format is version ${schemaVersion}, whereas ${DeserializerContext_1.ApiJsonSchemaVersion.OLDEST_SUPPORTED} is the oldest version supported by this tool`);
        }
        let oldestForwardsCompatibleVersion = schemaVersion;
        if (jsonObject.metadata.oldestForwardsCompatibleVersion) {
          if (jsonObject.metadata.oldestForwardsCompatibleVersion > schemaVersion) {
            throw new Error(`Error loading ${apiJsonFilename}:
Invalid file format; "oldestForwardsCompatibleVersion" cannot be newer than "schemaVersion"`);
          }
          oldestForwardsCompatibleVersion = jsonObject.metadata.oldestForwardsCompatibleVersion;
        }
        let versionToDeserialize = schemaVersion;
        if (versionToDeserialize > DeserializerContext_1.ApiJsonSchemaVersion.LATEST) {
          versionToDeserialize = Math.max(oldestForwardsCompatibleVersion, DeserializerContext_1.ApiJsonSchemaVersion.LATEST);
          if (versionToDeserialize > DeserializerContext_1.ApiJsonSchemaVersion.LATEST) {
            throw new Error(`Error loading ${apiJsonFilename}:
The file format version ${schemaVersion} was written by a newer release of the api-extractor-model library; you may need to upgrade your software`);
          }
        }
        const tsdocConfiguration = new tsdoc_1.TSDocConfiguration();
        if (versionToDeserialize >= DeserializerContext_1.ApiJsonSchemaVersion.V_1004) {
          const tsdocConfigFile = tsdoc_config_1.TSDocConfigFile.loadFromObject(jsonObject.metadata.tsdocConfig);
          if (tsdocConfigFile.hasErrors) {
            throw new Error(`Error loading ${apiJsonFilename}:
` + tsdocConfigFile.getErrorSummary());
          }
          tsdocConfigFile.configureParser(tsdocConfiguration);
        }
        const context = new DeserializerContext_1.DeserializerContext({
          apiJsonFilename,
          toolPackage: jsonObject.metadata.toolPackage,
          toolVersion: jsonObject.metadata.toolVersion,
          versionToDeserialize,
          tsdocConfiguration
        });
        return ApiItem_1.ApiItem.deserialize(jsonObject, context);
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.Package;
      }
      /** @override */
      get containerKey() {
        return this.name;
      }
      get entryPoints() {
        return this.members;
      }
      /**
       * The TSDoc configuration that was used when analyzing the API for this package.
       *
       * @remarks
       *
       * Normally this configuration is loaded from the project's tsdoc.json file.  It is stored
       * in the .api.json file so that doc comments can be parsed accurately when loading the file.
       */
      get tsdocConfiguration() {
        return this._tsdocConfiguration;
      }
      get projectFolderUrl() {
        return this._projectFolderUrl;
      }
      /** @override */
      addMember(member) {
        if (member.kind !== ApiItem_1.ApiItemKind.EntryPoint) {
          throw new Error("Only items of type ApiEntryPoint may be added to an ApiPackage");
        }
        super.addMember(member);
      }
      findEntryPointsByPath(importPath) {
        return this.findMembersByName(importPath);
      }
      saveToJsonFile(apiJsonFilename, options) {
        if (!options) {
          options = {};
        }
        const packageJson = node_core_library_1.PackageJsonLookup.loadOwnPackageJson(__dirname);
        const tsdocConfigFile = tsdoc_config_1.TSDocConfigFile.loadFromParser(this.tsdocConfiguration);
        const tsdocConfig = tsdocConfigFile.saveToObject();
        const jsonObject = {
          metadata: {
            toolPackage: options.toolPackage || packageJson.name,
            // In test mode, we don't write the real version, since that would cause spurious diffs whenever
            // the version is bumped.  Instead we write a placeholder string.
            toolVersion: options.testMode ? "[test mode]" : options.toolVersion || packageJson.version,
            schemaVersion: DeserializerContext_1.ApiJsonSchemaVersion.LATEST,
            oldestForwardsCompatibleVersion: DeserializerContext_1.ApiJsonSchemaVersion.OLDEST_FORWARDS_COMPATIBLE,
            tsdocConfig
          }
        };
        if (this.projectFolderUrl) {
          jsonObject.projectFolderUrl = this.projectFolderUrl;
        }
        this.serializeInto(jsonObject);
        node_core_library_1.JsonFile.save(jsonObject, apiJsonFilename, options);
      }
      /** @beta @override */
      buildCanonicalReference() {
        return DeclarationReference_1.DeclarationReference.package(this.name);
      }
    };
    exports2.ApiPackage = ApiPackage;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiEntryPoint.js
var require_ApiEntryPoint = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiEntryPoint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiEntryPoint = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiItemContainerMixin_1 = require_ApiItemContainerMixin();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiPackage_1 = require_ApiPackage();
    var ApiEntryPoint = class extends (0, ApiItemContainerMixin_1.ApiItemContainerMixin)((0, ApiNameMixin_1.ApiNameMixin)(ApiItem_1.ApiItem)) {
      constructor(options) {
        super(options);
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.EntryPoint;
      }
      /** @override */
      get containerKey() {
        return this.name;
      }
      /**
       * The module path for this entry point, relative to the parent `ApiPackage`.  In the current implementation,
       * this is always the empty string, indicating the default entry point.
       *
       * @remarks
       *
       * API Extractor does not currently support analysis of multiple entry points.  If that feature is implemented
       * in the future, then the `ApiEntryPoint.importPath` will be used to distinguish different entry points,
       * for example: `controls/Button` in `import { Button } from "example-package/controls/Button";`.
       *
       * The `ApiEntryPoint.name` property stores the same value as `ApiEntryPoint.importPath`.
       */
      get importPath() {
        return this.name;
      }
      /** @beta @override */
      buildCanonicalReference() {
        if (this.parent instanceof ApiPackage_1.ApiPackage) {
          return DeclarationReference_1.DeclarationReference.package(this.parent.name, this.importPath);
        }
        return DeclarationReference_1.DeclarationReference.empty();
      }
    };
    exports2.ApiEntryPoint = ApiEntryPoint;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiProtectedMixin.js
var require_ApiProtectedMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiProtectedMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiProtectedMixin = void 0;
    var _isProtected = Symbol("ApiProtectedMixin._isProtected");
    function ApiProtectedMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          this[_isProtected] = options.isProtected;
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          options.isProtected = jsonObject.isProtected;
        }
        get isProtected() {
          return this[_isProtected];
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          jsonObject.isProtected = this.isProtected;
        }
      }
      return MixedClass;
    }
    exports2.ApiProtectedMixin = ApiProtectedMixin;
    (function(ApiProtectedMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_isProtected);
      }
      ApiProtectedMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiProtectedMixin || (exports2.ApiProtectedMixin = ApiProtectedMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiStaticMixin.js
var require_ApiStaticMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiStaticMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiStaticMixin = void 0;
    var _isStatic = Symbol("ApiStaticMixin._isStatic");
    function ApiStaticMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          this[_isStatic] = options.isStatic;
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          options.isStatic = jsonObject.isStatic;
        }
        get isStatic() {
          return this[_isStatic];
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          jsonObject.isStatic = this.isStatic;
        }
      }
      return MixedClass;
    }
    exports2.ApiStaticMixin = ApiStaticMixin;
    (function(ApiStaticMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_isStatic);
      }
      ApiStaticMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiStaticMixin || (exports2.ApiStaticMixin = ApiStaticMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiReturnTypeMixin.js
var require_ApiReturnTypeMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiReturnTypeMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiReturnTypeMixin = void 0;
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var node_core_library_1 = require_lib2();
    var _returnTypeExcerpt = Symbol("ApiReturnTypeMixin._returnTypeExcerpt");
    function ApiReturnTypeMixin2(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          if (this instanceof ApiDeclaredItem_1.ApiDeclaredItem) {
            this[_returnTypeExcerpt] = this.buildExcerpt(options.returnTypeTokenRange);
          } else {
            throw new node_core_library_1.InternalError("ApiReturnTypeMixin expects a base class that inherits from ApiDeclaredItem");
          }
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          options.returnTypeTokenRange = jsonObject.returnTypeTokenRange;
        }
        get returnTypeExcerpt() {
          return this[_returnTypeExcerpt];
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          jsonObject.returnTypeTokenRange = this.returnTypeExcerpt.tokenRange;
        }
      }
      return MixedClass;
    }
    exports2.ApiReturnTypeMixin = ApiReturnTypeMixin2;
    (function(ApiReturnTypeMixin3) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_returnTypeExcerpt);
      }
      ApiReturnTypeMixin3.isBaseClassOf = isBaseClassOf;
    })(ApiReturnTypeMixin2 || (exports2.ApiReturnTypeMixin = ApiReturnTypeMixin2 = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiOptionalMixin.js
var require_ApiOptionalMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiOptionalMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiOptionalMixin = void 0;
    var _isOptional = Symbol("ApiOptionalMixin._isOptional");
    function ApiOptionalMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          this[_isOptional] = !!options.isOptional;
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          options.isOptional = !!jsonObject.isOptional;
        }
        get isOptional() {
          return this[_isOptional];
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          jsonObject.isOptional = this.isOptional;
        }
      }
      return MixedClass;
    }
    exports2.ApiOptionalMixin = ApiOptionalMixin;
    (function(ApiOptionalMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_isOptional);
      }
      ApiOptionalMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiOptionalMixin || (exports2.ApiOptionalMixin = ApiOptionalMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiMethod.js
var require_ApiMethod = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiMethod.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiMethod = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiProtectedMixin_1 = require_ApiProtectedMixin();
    var ApiStaticMixin_1 = require_ApiStaticMixin();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiParameterListMixin_1 = require_ApiParameterListMixin();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiReturnTypeMixin_1 = require_ApiReturnTypeMixin();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiAbstractMixin_1 = require_ApiAbstractMixin();
    var ApiTypeParameterListMixin_1 = require_ApiTypeParameterListMixin();
    var ApiOptionalMixin_1 = require_ApiOptionalMixin();
    var ApiMethod = class _ApiMethod extends (0, ApiNameMixin_1.ApiNameMixin)((0, ApiAbstractMixin_1.ApiAbstractMixin)((0, ApiOptionalMixin_1.ApiOptionalMixin)((0, ApiParameterListMixin_1.ApiParameterListMixin)((0, ApiProtectedMixin_1.ApiProtectedMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiReturnTypeMixin_1.ApiReturnTypeMixin)((0, ApiStaticMixin_1.ApiStaticMixin)((0, ApiTypeParameterListMixin_1.ApiTypeParameterListMixin)(ApiDeclaredItem_1.ApiDeclaredItem))))))))) {
      constructor(options) {
        super(options);
      }
      static getContainerKey(name, isStatic, overloadIndex) {
        if (isStatic) {
          return `${name}|${ApiItem_1.ApiItemKind.Method}|static|${overloadIndex}`;
        } else {
          return `${name}|${ApiItem_1.ApiItemKind.Method}|instance|${overloadIndex}`;
        }
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.Method;
      }
      /** @override */
      get containerKey() {
        return _ApiMethod.getContainerKey(this.name, this.isStatic, this.overloadIndex);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep(this.isStatic ? "." : "#", nameComponent).withMeaning(
          "member"
          /* Meaning.Member */
        ).withOverloadIndex(this.overloadIndex);
      }
    };
    exports2.ApiMethod = ApiMethod;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ModelReferenceResolver.js
var require_ModelReferenceResolver = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ModelReferenceResolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ModelReferenceResolver = void 0;
    var tsdoc_1 = (init_lib(), __toCommonJS(lib_exports));
    var ApiItem_1 = require_ApiItem();
    var ApiItemContainerMixin_1 = require_ApiItemContainerMixin();
    var ApiParameterListMixin_1 = require_ApiParameterListMixin();
    var ModelReferenceResolver = class {
      constructor(apiModel2) {
        this._apiModel = apiModel2;
      }
      resolve(declarationReference, contextApiItem) {
        const result = {
          resolvedApiItem: void 0,
          errorMessage: void 0
        };
        let apiPackage = void 0;
        if (declarationReference.packageName !== void 0) {
          apiPackage = this._apiModel.tryGetPackageByName(declarationReference.packageName);
          if (apiPackage === void 0) {
            result.errorMessage = `The package "${declarationReference.packageName}" could not be located`;
            return result;
          }
        } else {
          if (contextApiItem !== void 0) {
            apiPackage = contextApiItem.getAssociatedPackage();
          }
          if (apiPackage === void 0) {
            result.errorMessage = `The reference does not include a package name, and the package could not be inferred from the context`;
            return result;
          }
        }
        const importPath = declarationReference.importPath || "";
        const foundEntryPoints = apiPackage.findEntryPointsByPath(importPath);
        if (foundEntryPoints.length !== 1) {
          result.errorMessage = `The import path "${importPath}" could not be resolved`;
          return result;
        }
        let currentItem = foundEntryPoints[0];
        for (const memberReference of declarationReference.memberReferences) {
          if (memberReference.memberSymbol !== void 0) {
            result.errorMessage = `Symbols are not yet supported in declaration references`;
            return result;
          }
          if (memberReference.memberIdentifier === void 0) {
            result.errorMessage = `Missing member identifier`;
            return result;
          }
          const identifier = memberReference.memberIdentifier.identifier;
          if (!ApiItemContainerMixin_1.ApiItemContainerMixin.isBaseClassOf(currentItem)) {
            result.errorMessage = `Unable to resolve ${JSON.stringify(identifier)} because ${currentItem.getScopedNameWithinPackage()} cannot act as a container`;
            return result;
          }
          const foundMembers = currentItem.findMembersByName(identifier);
          if (foundMembers.length === 0) {
            result.errorMessage = `The member reference ${JSON.stringify(identifier)} was not found`;
            return result;
          }
          const memberSelector = memberReference.selector;
          if (memberSelector === void 0) {
            if (foundMembers.length > 1) {
              result.errorMessage = `The member reference ${JSON.stringify(identifier)} was ambiguous`;
              return result;
            }
            currentItem = foundMembers[0];
          } else {
            let memberSelectorResult;
            switch (memberSelector.selectorKind) {
              case tsdoc_1.SelectorKind.System:
                memberSelectorResult = this._selectUsingSystemSelector(foundMembers, memberSelector, identifier);
                break;
              case tsdoc_1.SelectorKind.Index:
                memberSelectorResult = this._selectUsingIndexSelector(foundMembers, memberSelector, identifier);
                break;
              default:
                result.errorMessage = `The selector "${memberSelector.selector}" is not a supported selector type`;
                return result;
            }
            if (memberSelectorResult.resolvedApiItem === void 0) {
              return memberSelectorResult;
            }
            currentItem = memberSelectorResult.resolvedApiItem;
          }
        }
        result.resolvedApiItem = currentItem;
        return result;
      }
      _selectUsingSystemSelector(foundMembers, memberSelector, identifier) {
        const result = {
          resolvedApiItem: void 0,
          errorMessage: void 0
        };
        const selectorName = memberSelector.selector;
        let selectorItemKind;
        switch (selectorName) {
          case "class":
            selectorItemKind = ApiItem_1.ApiItemKind.Class;
            break;
          case "enum":
            selectorItemKind = ApiItem_1.ApiItemKind.Enum;
            break;
          case "function":
            selectorItemKind = ApiItem_1.ApiItemKind.Function;
            break;
          case "interface":
            selectorItemKind = ApiItem_1.ApiItemKind.Interface;
            break;
          case "namespace":
            selectorItemKind = ApiItem_1.ApiItemKind.Namespace;
            break;
          case "type":
            selectorItemKind = ApiItem_1.ApiItemKind.TypeAlias;
            break;
          case "variable":
            selectorItemKind = ApiItem_1.ApiItemKind.Variable;
            break;
          default:
            result.errorMessage = `Unsupported system selector "${selectorName}"`;
            return result;
        }
        const matches = foundMembers.filter((x) => x.kind === selectorItemKind);
        if (matches.length === 0) {
          result.errorMessage = `A declaration for "${identifier}" was not found that matches the TSDoc selector "${selectorName}"`;
          return result;
        }
        if (matches.length > 1) {
          result.errorMessage = `More than one declaration "${identifier}" matches the TSDoc selector "${selectorName}"`;
        }
        result.resolvedApiItem = matches[0];
        return result;
      }
      _selectUsingIndexSelector(foundMembers, memberSelector, identifier) {
        const result = {
          resolvedApiItem: void 0,
          errorMessage: void 0
        };
        const selectedMembers = [];
        const selectorOverloadIndex = parseInt(memberSelector.selector, 10);
        for (const foundMember of foundMembers) {
          if (ApiParameterListMixin_1.ApiParameterListMixin.isBaseClassOf(foundMember)) {
            if (foundMember.overloadIndex === selectorOverloadIndex) {
              selectedMembers.push(foundMember);
            }
          }
        }
        if (selectedMembers.length === 0) {
          result.errorMessage = `An overload for ${JSON.stringify(identifier)} was not found that matches the TSDoc selector ":${selectorOverloadIndex}"`;
          return result;
        }
        if (selectedMembers.length === 1) {
          result.resolvedApiItem = selectedMembers[0];
          return result;
        }
        result.errorMessage = `The member reference ${JSON.stringify(identifier)} was ambiguous`;
        return result;
      }
    };
    exports2.ModelReferenceResolver = ModelReferenceResolver;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiModel.js
var require_ApiModel = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiModel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiModel = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiItemContainerMixin_1 = require_ApiItemContainerMixin();
    var ApiPackage_1 = require_ApiPackage();
    var node_core_library_1 = require_lib2();
    var ModelReferenceResolver_1 = require_ModelReferenceResolver();
    var tsdoc_1 = (init_lib(), __toCommonJS(lib_exports));
    var ApiModel2 = class extends (0, ApiItemContainerMixin_1.ApiItemContainerMixin)(ApiItem_1.ApiItem) {
      constructor() {
        super({});
        this._packagesByName = void 0;
        this._apiItemsByCanonicalReference = void 0;
        this._resolver = new ModelReferenceResolver_1.ModelReferenceResolver(this);
      }
      loadPackage(apiJsonFilename) {
        const apiPackage = ApiPackage_1.ApiPackage.loadFromJsonFile(apiJsonFilename);
        this.addMember(apiPackage);
        return apiPackage;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.Model;
      }
      /** @override */
      get containerKey() {
        return "";
      }
      get packages() {
        return this.members;
      }
      /** @override */
      addMember(member) {
        if (member.kind !== ApiItem_1.ApiItemKind.Package) {
          throw new Error("Only items of type ApiPackage may be added to an ApiModel");
        }
        super.addMember(member);
        this._packagesByName = void 0;
        this._apiItemsByCanonicalReference = void 0;
      }
      /**
       * Efficiently finds a package by the NPM package name.
       *
       * @remarks
       *
       * If the NPM scope is omitted in the package name, it will still be found provided that it is an unambiguous match.
       * For example, it's often convenient to write `{@link node-core-library#JsonFile}` instead of
       * `{@link @rushstack/node-core-library#JsonFile}`.
       */
      tryGetPackageByName(packageName) {
        if (this._packagesByName === void 0) {
          this._packagesByName = /* @__PURE__ */ new Map();
          const unscopedMap = /* @__PURE__ */ new Map();
          for (const apiPackage of this.packages) {
            if (this._packagesByName.get(apiPackage.name)) {
              throw new Error(`The model contains multiple packages with the name ${apiPackage.name}`);
            }
            this._packagesByName.set(apiPackage.name, apiPackage);
            const unscopedName = node_core_library_1.PackageName.parse(apiPackage.name).unscopedName;
            if (unscopedMap.has(unscopedName)) {
              unscopedMap.set(unscopedName, void 0);
            } else {
              unscopedMap.set(unscopedName, apiPackage);
            }
          }
          for (const [unscopedName, apiPackage] of unscopedMap) {
            if (apiPackage) {
              if (!this._packagesByName.has(unscopedName)) {
                this._packagesByName.set(unscopedName, apiPackage);
              }
            }
          }
        }
        return this._packagesByName.get(packageName);
      }
      resolveDeclarationReference(declarationReference, contextApiItem) {
        if (declarationReference instanceof tsdoc_1.DocDeclarationReference) {
          return this._resolver.resolve(declarationReference, contextApiItem);
        } else if (declarationReference instanceof DeclarationReference_1.DeclarationReference) {
          if (!this._apiItemsByCanonicalReference) {
            this._apiItemsByCanonicalReference = /* @__PURE__ */ new Map();
            for (const apiPackage of this.packages) {
              this._initApiItemsRecursive(apiPackage, this._apiItemsByCanonicalReference);
            }
          }
          const result = {
            resolvedApiItem: void 0,
            errorMessage: void 0
          };
          const apiItem = this._apiItemsByCanonicalReference.get(declarationReference.toString());
          if (!apiItem) {
            result.errorMessage = `${declarationReference.toString()} can not be located`;
          } else {
            result.resolvedApiItem = apiItem;
          }
          return result;
        } else {
          throw new Error('The "declarationReference" parameter must be an instance of DocDeclarationReference or DeclarationReference');
        }
      }
      _initApiItemsRecursive(apiItem, apiItemsByCanonicalReference) {
        if (apiItem.canonicalReference && !apiItem.canonicalReference.isEmpty) {
          apiItemsByCanonicalReference.set(apiItem.canonicalReference.toString(), apiItem);
        }
        if (ApiItemContainerMixin_1.ApiItemContainerMixin.isBaseClassOf(apiItem)) {
          for (const apiMember of apiItem.members) {
            this._initApiItemsRecursive(apiMember, apiItemsByCanonicalReference);
          }
        }
      }
      /** @beta @override */
      buildCanonicalReference() {
        return DeclarationReference_1.DeclarationReference.empty();
      }
    };
    exports2.ApiModel = ApiModel2;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiNamespace.js
var require_ApiNamespace = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiNamespace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiNamespace = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiItemContainerMixin_1 = require_ApiItemContainerMixin();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiExportedMixin_1 = require_ApiExportedMixin();
    var ApiNamespace = class _ApiNamespace extends (0, ApiItemContainerMixin_1.ApiItemContainerMixin)((0, ApiNameMixin_1.ApiNameMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiExportedMixin_1.ApiExportedMixin)(ApiDeclaredItem_1.ApiDeclaredItem)))) {
      constructor(options) {
        super(options);
      }
      static getContainerKey(name) {
        return `${name}|${ApiItem_1.ApiItemKind.Namespace}`;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.Namespace;
      }
      /** @override */
      get containerKey() {
        return _ApiNamespace.getContainerKey(this.name);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        const navigation = this.isExported ? "." : "~";
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep(navigation, nameComponent).withMeaning(
          "namespace"
          /* Meaning.Namespace */
        );
      }
    };
    exports2.ApiNamespace = ApiNamespace;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiInterface.js
var require_ApiInterface = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiInterface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiInterface = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiItemContainerMixin_1 = require_ApiItemContainerMixin();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var HeritageType_1 = require_HeritageType();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiTypeParameterListMixin_1 = require_ApiTypeParameterListMixin();
    var ApiExportedMixin_1 = require_ApiExportedMixin();
    var ApiInterface2 = class _ApiInterface extends (0, ApiItemContainerMixin_1.ApiItemContainerMixin)((0, ApiNameMixin_1.ApiNameMixin)((0, ApiTypeParameterListMixin_1.ApiTypeParameterListMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiExportedMixin_1.ApiExportedMixin)(ApiDeclaredItem_1.ApiDeclaredItem))))) {
      constructor(options) {
        super(options);
        this._extendsTypes = [];
        for (const extendsTokenRange of options.extendsTokenRanges) {
          this._extendsTypes.push(new HeritageType_1.HeritageType(this.buildExcerpt(extendsTokenRange)));
        }
      }
      static getContainerKey(name) {
        return `${name}|${ApiItem_1.ApiItemKind.Interface}`;
      }
      /** @override */
      static onDeserializeInto(options, context, jsonObject) {
        super.onDeserializeInto(options, context, jsonObject);
        options.extendsTokenRanges = jsonObject.extendsTokenRanges;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.Interface;
      }
      /** @override */
      get containerKey() {
        return _ApiInterface.getContainerKey(this.name);
      }
      /**
       * The list of base interfaces that this interface inherits from using the `extends` keyword.
       */
      get extendsTypes() {
        return this._extendsTypes;
      }
      /** @override */
      serializeInto(jsonObject) {
        super.serializeInto(jsonObject);
        jsonObject.extendsTokenRanges = this.extendsTypes.map((x) => x.excerpt.tokenRange);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        const navigation = this.isExported ? "." : "~";
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep(navigation, nameComponent).withMeaning(
          "interface"
          /* Meaning.Interface */
        );
      }
    };
    exports2.ApiInterface = ApiInterface2;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiReadonlyMixin.js
var require_ApiReadonlyMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiReadonlyMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiReadonlyMixin = void 0;
    var _isReadonly = Symbol("ApiReadonlyMixin._isReadonly");
    function ApiReadonlyMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          this[_isReadonly] = options.isReadonly;
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          options.isReadonly = jsonObject.isReadonly || false;
        }
        get isReadonly() {
          return this[_isReadonly];
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          jsonObject.isReadonly = this.isReadonly;
        }
      }
      return MixedClass;
    }
    exports2.ApiReadonlyMixin = ApiReadonlyMixin;
    (function(ApiReadonlyMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_isReadonly);
      }
      ApiReadonlyMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiReadonlyMixin || (exports2.ApiReadonlyMixin = ApiReadonlyMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/items/ApiPropertyItem.js
var require_ApiPropertyItem = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/items/ApiPropertyItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiPropertyItem = void 0;
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiOptionalMixin_1 = require_ApiOptionalMixin();
    var ApiReadonlyMixin_1 = require_ApiReadonlyMixin();
    var ApiPropertyItem = class extends (0, ApiNameMixin_1.ApiNameMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiOptionalMixin_1.ApiOptionalMixin)((0, ApiReadonlyMixin_1.ApiReadonlyMixin)(ApiDeclaredItem_1.ApiDeclaredItem)))) {
      constructor(options) {
        super(options);
        this.propertyTypeExcerpt = this.buildExcerpt(options.propertyTypeTokenRange);
      }
      /** @override */
      static onDeserializeInto(options, context, jsonObject) {
        super.onDeserializeInto(options, context, jsonObject);
        options.propertyTypeTokenRange = jsonObject.propertyTypeTokenRange;
      }
      /**
       * Returns true if this property should be documented as an event.
       *
       * @remarks
       * The `@eventProperty` TSDoc modifier can be added to readonly properties to indicate that they return an
       * event object that event handlers can be attached to.  The event-handling API is implementation-defined, but
       * typically the return type would be a class with members such as `addHandler()` and `removeHandler()`.
       * The documentation should display such properties under an "Events" heading instead of the
       * usual "Properties" heading.
       */
      get isEventProperty() {
        if (this.tsdocComment) {
          return this.tsdocComment.modifierTagSet.isEventProperty();
        }
        return false;
      }
      /** @override */
      serializeInto(jsonObject) {
        super.serializeInto(jsonObject);
        jsonObject.propertyTypeTokenRange = this.propertyTypeExcerpt.tokenRange;
      }
    };
    exports2.ApiPropertyItem = ApiPropertyItem;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiPropertySignature.js
var require_ApiPropertySignature = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiPropertySignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiPropertySignature = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiPropertyItem_1 = require_ApiPropertyItem();
    var ApiPropertySignature = class _ApiPropertySignature extends ApiPropertyItem_1.ApiPropertyItem {
      constructor(options) {
        super(options);
      }
      static getContainerKey(name) {
        return `${name}|${ApiItem_1.ApiItemKind.PropertySignature}`;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.PropertySignature;
      }
      /** @override */
      get containerKey() {
        return _ApiPropertySignature.getContainerKey(this.name);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep("#", nameComponent).withMeaning(
          "member"
          /* Meaning.Member */
        );
      }
    };
    exports2.ApiPropertySignature = ApiPropertySignature;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiMethodSignature.js
var require_ApiMethodSignature = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiMethodSignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiMethodSignature = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiParameterListMixin_1 = require_ApiParameterListMixin();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiReturnTypeMixin_1 = require_ApiReturnTypeMixin();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiTypeParameterListMixin_1 = require_ApiTypeParameterListMixin();
    var ApiOptionalMixin_1 = require_ApiOptionalMixin();
    var ApiMethodSignature = class _ApiMethodSignature extends (0, ApiNameMixin_1.ApiNameMixin)((0, ApiTypeParameterListMixin_1.ApiTypeParameterListMixin)((0, ApiParameterListMixin_1.ApiParameterListMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiReturnTypeMixin_1.ApiReturnTypeMixin)((0, ApiOptionalMixin_1.ApiOptionalMixin)(ApiDeclaredItem_1.ApiDeclaredItem)))))) {
      constructor(options) {
        super(options);
      }
      static getContainerKey(name, overloadIndex) {
        return `${name}|${ApiItem_1.ApiItemKind.MethodSignature}|${overloadIndex}`;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.MethodSignature;
      }
      /** @override */
      get containerKey() {
        return _ApiMethodSignature.getContainerKey(this.name, this.overloadIndex);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep("#", nameComponent).withMeaning(
          "member"
          /* Meaning.Member */
        ).withOverloadIndex(this.overloadIndex);
      }
    };
    exports2.ApiMethodSignature = ApiMethodSignature;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiInitializerMixin.js
var require_ApiInitializerMixin = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/mixins/ApiInitializerMixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiInitializerMixin = void 0;
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var node_core_library_1 = require_lib2();
    var _initializerExcerpt = Symbol("ApiInitializerMixin._initializerExcerpt");
    function ApiInitializerMixin(baseClass) {
      class MixedClass extends baseClass {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args2) {
          super(...args2);
          const options = args2[0];
          if (this instanceof ApiDeclaredItem_1.ApiDeclaredItem) {
            if (options.initializerTokenRange) {
              this[_initializerExcerpt] = this.buildExcerpt(options.initializerTokenRange);
            }
          } else {
            throw new node_core_library_1.InternalError("ApiInitializerMixin expects a base class that inherits from ApiDeclaredItem");
          }
        }
        /** @override */
        static onDeserializeInto(options, context, jsonObject) {
          baseClass.onDeserializeInto(options, context, jsonObject);
          options.initializerTokenRange = jsonObject.initializerTokenRange;
        }
        get initializerExcerpt() {
          return this[_initializerExcerpt];
        }
        /** @override */
        serializeInto(jsonObject) {
          super.serializeInto(jsonObject);
          if (this.initializerExcerpt) {
            jsonObject.initializerTokenRange = this.initializerExcerpt.tokenRange;
          }
        }
      }
      return MixedClass;
    }
    exports2.ApiInitializerMixin = ApiInitializerMixin;
    (function(ApiInitializerMixin2) {
      function isBaseClassOf(apiItem) {
        return apiItem.hasOwnProperty(_initializerExcerpt);
      }
      ApiInitializerMixin2.isBaseClassOf = isBaseClassOf;
    })(ApiInitializerMixin || (exports2.ApiInitializerMixin = ApiInitializerMixin = {}));
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiProperty.js
var require_ApiProperty = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiProperty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiProperty = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiAbstractMixin_1 = require_ApiAbstractMixin();
    var ApiProtectedMixin_1 = require_ApiProtectedMixin();
    var ApiStaticMixin_1 = require_ApiStaticMixin();
    var ApiInitializerMixin_1 = require_ApiInitializerMixin();
    var ApiPropertyItem_1 = require_ApiPropertyItem();
    var ApiProperty = class _ApiProperty extends (0, ApiAbstractMixin_1.ApiAbstractMixin)((0, ApiProtectedMixin_1.ApiProtectedMixin)((0, ApiStaticMixin_1.ApiStaticMixin)((0, ApiInitializerMixin_1.ApiInitializerMixin)(ApiPropertyItem_1.ApiPropertyItem)))) {
      constructor(options) {
        super(options);
      }
      static getContainerKey(name, isStatic) {
        if (isStatic) {
          return `${name}|${ApiItem_1.ApiItemKind.Property}|static`;
        } else {
          return `${name}|${ApiItem_1.ApiItemKind.Property}|instance`;
        }
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.Property;
      }
      /** @override */
      get containerKey() {
        return _ApiProperty.getContainerKey(this.name, this.isStatic);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep(this.isStatic ? "." : "#", nameComponent).withMeaning(
          "member"
          /* Meaning.Member */
        );
      }
    };
    exports2.ApiProperty = ApiProperty;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiEnumMember.js
var require_ApiEnumMember = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiEnumMember.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiEnumMember = exports2.EnumMemberOrder = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiInitializerMixin_1 = require_ApiInitializerMixin();
    var EnumMemberOrder;
    (function(EnumMemberOrder2) {
      EnumMemberOrder2["ByName"] = "by-name";
      EnumMemberOrder2["Preserve"] = "preserve";
    })(EnumMemberOrder || (exports2.EnumMemberOrder = EnumMemberOrder = {}));
    var ApiEnumMember = class _ApiEnumMember extends (0, ApiNameMixin_1.ApiNameMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiInitializerMixin_1.ApiInitializerMixin)(ApiDeclaredItem_1.ApiDeclaredItem))) {
      constructor(options) {
        super(options);
      }
      static getContainerKey(name) {
        return name;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.EnumMember;
      }
      /** @override */
      get containerKey() {
        return _ApiEnumMember.getContainerKey(this.name);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep(".", nameComponent).withMeaning(
          "member"
          /* Meaning.Member */
        );
      }
    };
    exports2.ApiEnumMember = ApiEnumMember;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiEnum.js
var require_ApiEnum = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiEnum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiEnum = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiItemContainerMixin_1 = require_ApiItemContainerMixin();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiExportedMixin_1 = require_ApiExportedMixin();
    var ApiEnum = class _ApiEnum extends (0, ApiItemContainerMixin_1.ApiItemContainerMixin)((0, ApiNameMixin_1.ApiNameMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiExportedMixin_1.ApiExportedMixin)(ApiDeclaredItem_1.ApiDeclaredItem)))) {
      constructor(options) {
        super(options);
      }
      static getContainerKey(name) {
        return `${name}|${ApiItem_1.ApiItemKind.Enum}`;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.Enum;
      }
      /** @override */
      get members() {
        return super.members;
      }
      /** @override */
      get containerKey() {
        return _ApiEnum.getContainerKey(this.name);
      }
      /** @override */
      addMember(member) {
        if (member.kind !== ApiItem_1.ApiItemKind.EnumMember) {
          throw new Error("Only ApiEnumMember objects can be added to an ApiEnum");
        }
        super.addMember(member);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        const navigation = this.isExported ? "." : "~";
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep(navigation, nameComponent).withMeaning(
          "enum"
          /* Meaning.Enum */
        );
      }
    };
    exports2.ApiEnum = ApiEnum;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiConstructor.js
var require_ApiConstructor = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiConstructor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiConstructor = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiParameterListMixin_1 = require_ApiParameterListMixin();
    var ApiProtectedMixin_1 = require_ApiProtectedMixin();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiConstructor = class _ApiConstructor extends (0, ApiParameterListMixin_1.ApiParameterListMixin)((0, ApiProtectedMixin_1.ApiProtectedMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)(ApiDeclaredItem_1.ApiDeclaredItem))) {
      constructor(options) {
        super(options);
      }
      static getContainerKey(overloadIndex) {
        return `|${ApiItem_1.ApiItemKind.Constructor}|${overloadIndex}`;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.Constructor;
      }
      /** @override */
      get containerKey() {
        return _ApiConstructor.getContainerKey(this.overloadIndex);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const parent = this.parent ? this.parent.canonicalReference : (
          // .withMeaning() requires some kind of component
          DeclarationReference_1.DeclarationReference.empty().addNavigationStep("#", "(parent)")
        );
        return parent.withMeaning(
          "constructor"
          /* Meaning.Constructor */
        ).withOverloadIndex(this.overloadIndex);
      }
    };
    exports2.ApiConstructor = ApiConstructor;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiConstructSignature.js
var require_ApiConstructSignature = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiConstructSignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiConstructSignature = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiParameterListMixin_1 = require_ApiParameterListMixin();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiReturnTypeMixin_1 = require_ApiReturnTypeMixin();
    var ApiTypeParameterListMixin_1 = require_ApiTypeParameterListMixin();
    var ApiConstructSignature = class _ApiConstructSignature extends (0, ApiTypeParameterListMixin_1.ApiTypeParameterListMixin)((0, ApiParameterListMixin_1.ApiParameterListMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiReturnTypeMixin_1.ApiReturnTypeMixin)(ApiDeclaredItem_1.ApiDeclaredItem)))) {
      constructor(options) {
        super(options);
      }
      static getContainerKey(overloadIndex) {
        return `|${ApiItem_1.ApiItemKind.ConstructSignature}|${overloadIndex}`;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.ConstructSignature;
      }
      /** @override */
      get containerKey() {
        return _ApiConstructSignature.getContainerKey(this.overloadIndex);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const parent = this.parent ? this.parent.canonicalReference : (
          // .withMeaning() requires some kind of component
          DeclarationReference_1.DeclarationReference.empty().addNavigationStep("#", "(parent)")
        );
        return parent.withMeaning(
          "new"
          /* Meaning.ConstructSignature */
        ).withOverloadIndex(this.overloadIndex);
      }
    };
    exports2.ApiConstructSignature = ApiConstructSignature;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiFunction.js
var require_ApiFunction = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiFunction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiFunction = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiParameterListMixin_1 = require_ApiParameterListMixin();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiReturnTypeMixin_1 = require_ApiReturnTypeMixin();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiTypeParameterListMixin_1 = require_ApiTypeParameterListMixin();
    var ApiExportedMixin_1 = require_ApiExportedMixin();
    var ApiFunction = class _ApiFunction extends (0, ApiNameMixin_1.ApiNameMixin)((0, ApiTypeParameterListMixin_1.ApiTypeParameterListMixin)((0, ApiParameterListMixin_1.ApiParameterListMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiReturnTypeMixin_1.ApiReturnTypeMixin)((0, ApiExportedMixin_1.ApiExportedMixin)(ApiDeclaredItem_1.ApiDeclaredItem)))))) {
      constructor(options) {
        super(options);
      }
      static getContainerKey(name, overloadIndex) {
        return `${name}|${ApiItem_1.ApiItemKind.Function}|${overloadIndex}`;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.Function;
      }
      /** @override */
      get containerKey() {
        return _ApiFunction.getContainerKey(this.name, this.overloadIndex);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        const navigation = this.isExported ? "." : "~";
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep(navigation, nameComponent).withMeaning(
          "function"
          /* Meaning.Function */
        ).withOverloadIndex(this.overloadIndex);
      }
    };
    exports2.ApiFunction = ApiFunction;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiCallSignature.js
var require_ApiCallSignature = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiCallSignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiCallSignature = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiParameterListMixin_1 = require_ApiParameterListMixin();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiReturnTypeMixin_1 = require_ApiReturnTypeMixin();
    var ApiTypeParameterListMixin_1 = require_ApiTypeParameterListMixin();
    var ApiCallSignature = class _ApiCallSignature extends (0, ApiTypeParameterListMixin_1.ApiTypeParameterListMixin)((0, ApiParameterListMixin_1.ApiParameterListMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiReturnTypeMixin_1.ApiReturnTypeMixin)(ApiDeclaredItem_1.ApiDeclaredItem)))) {
      constructor(options) {
        super(options);
      }
      static getContainerKey(overloadIndex) {
        return `|${ApiItem_1.ApiItemKind.CallSignature}|${overloadIndex}`;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.CallSignature;
      }
      /** @override */
      get containerKey() {
        return _ApiCallSignature.getContainerKey(this.overloadIndex);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const parent = this.parent ? this.parent.canonicalReference : (
          // .withMeaning() requires some kind of component
          DeclarationReference_1.DeclarationReference.empty().addNavigationStep("#", "(parent)")
        );
        return parent.withMeaning(
          "call"
          /* Meaning.CallSignature */
        ).withOverloadIndex(this.overloadIndex);
      }
    };
    exports2.ApiCallSignature = ApiCallSignature;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiIndexSignature.js
var require_ApiIndexSignature = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiIndexSignature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiIndexSignature = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiParameterListMixin_1 = require_ApiParameterListMixin();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiReturnTypeMixin_1 = require_ApiReturnTypeMixin();
    var ApiReadonlyMixin_1 = require_ApiReadonlyMixin();
    var ApiIndexSignature = class _ApiIndexSignature extends (0, ApiParameterListMixin_1.ApiParameterListMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiReturnTypeMixin_1.ApiReturnTypeMixin)((0, ApiReadonlyMixin_1.ApiReadonlyMixin)(ApiDeclaredItem_1.ApiDeclaredItem)))) {
      constructor(options) {
        super(options);
      }
      static getContainerKey(overloadIndex) {
        return `|${ApiItem_1.ApiItemKind.IndexSignature}|${overloadIndex}`;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.IndexSignature;
      }
      /** @override */
      get containerKey() {
        return _ApiIndexSignature.getContainerKey(this.overloadIndex);
      }
      /** @beta @override */
      buildCanonicalReference() {
        const parent = this.parent ? this.parent.canonicalReference : (
          // .withMeaning() requires some kind of component
          DeclarationReference_1.DeclarationReference.empty().addNavigationStep("#", "(parent)")
        );
        return parent.withMeaning(
          "index"
          /* Meaning.IndexSignature */
        ).withOverloadIndex(this.overloadIndex);
      }
    };
    exports2.ApiIndexSignature = ApiIndexSignature;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiTypeAlias.js
var require_ApiTypeAlias = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiTypeAlias.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiTypeAlias = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiTypeParameterListMixin_1 = require_ApiTypeParameterListMixin();
    var ApiExportedMixin_1 = require_ApiExportedMixin();
    var ApiTypeAlias2 = class _ApiTypeAlias extends (0, ApiTypeParameterListMixin_1.ApiTypeParameterListMixin)((0, ApiNameMixin_1.ApiNameMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiExportedMixin_1.ApiExportedMixin)(ApiDeclaredItem_1.ApiDeclaredItem)))) {
      constructor(options) {
        super(options);
        this.typeExcerpt = this.buildExcerpt(options.typeTokenRange);
      }
      /** @override */
      static onDeserializeInto(options, context, jsonObject) {
        super.onDeserializeInto(options, context, jsonObject);
        options.typeTokenRange = jsonObject.typeTokenRange;
      }
      static getContainerKey(name) {
        return `${name}|${ApiItem_1.ApiItemKind.TypeAlias}`;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.TypeAlias;
      }
      /** @override */
      get containerKey() {
        return _ApiTypeAlias.getContainerKey(this.name);
      }
      /** @override */
      serializeInto(jsonObject) {
        super.serializeInto(jsonObject);
        jsonObject.typeTokenRange = this.typeExcerpt.tokenRange;
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        const navigation = this.isExported ? "." : "~";
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep(navigation, nameComponent).withMeaning(
          "type"
          /* Meaning.TypeAlias */
        );
      }
    };
    exports2.ApiTypeAlias = ApiTypeAlias2;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiVariable.js
var require_ApiVariable = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/ApiVariable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiVariable = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiItem_1 = require_ApiItem();
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    var ApiReadonlyMixin_1 = require_ApiReadonlyMixin();
    var ApiNameMixin_1 = require_ApiNameMixin();
    var ApiInitializerMixin_1 = require_ApiInitializerMixin();
    var ApiExportedMixin_1 = require_ApiExportedMixin();
    var ApiVariable = class _ApiVariable extends (0, ApiNameMixin_1.ApiNameMixin)((0, ApiReleaseTagMixin_1.ApiReleaseTagMixin)((0, ApiReadonlyMixin_1.ApiReadonlyMixin)((0, ApiInitializerMixin_1.ApiInitializerMixin)((0, ApiExportedMixin_1.ApiExportedMixin)(ApiDeclaredItem_1.ApiDeclaredItem))))) {
      constructor(options) {
        super(options);
        this.variableTypeExcerpt = this.buildExcerpt(options.variableTypeTokenRange);
      }
      /** @override */
      static onDeserializeInto(options, context, jsonObject) {
        super.onDeserializeInto(options, context, jsonObject);
        options.variableTypeTokenRange = jsonObject.variableTypeTokenRange;
      }
      static getContainerKey(name) {
        return `${name}|${ApiItem_1.ApiItemKind.Variable}`;
      }
      /** @override */
      get kind() {
        return ApiItem_1.ApiItemKind.Variable;
      }
      /** @override */
      get containerKey() {
        return _ApiVariable.getContainerKey(this.name);
      }
      /** @override */
      serializeInto(jsonObject) {
        super.serializeInto(jsonObject);
        jsonObject.variableTypeTokenRange = this.variableTypeExcerpt.tokenRange;
      }
      /** @beta @override */
      buildCanonicalReference() {
        const nameComponent = DeclarationReference_1.DeclarationReference.parseComponent(this.name);
        const navigation = this.isExported ? "." : "~";
        return (this.parent ? this.parent.canonicalReference : DeclarationReference_1.DeclarationReference.empty()).addNavigationStep(navigation, nameComponent).withMeaning(
          "var"
          /* Meaning.Variable */
        );
      }
    };
    exports2.ApiVariable = ApiVariable;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/Deserializer.js
var require_Deserializer = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/Deserializer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deserializer = void 0;
    var ApiItem_1 = require_ApiItem();
    var ApiClass_1 = require_ApiClass();
    var ApiEntryPoint_1 = require_ApiEntryPoint();
    var ApiMethod_1 = require_ApiMethod();
    var ApiModel_1 = require_ApiModel();
    var ApiNamespace_1 = require_ApiNamespace();
    var ApiPackage_1 = require_ApiPackage();
    var ApiInterface_1 = require_ApiInterface();
    var ApiPropertySignature_1 = require_ApiPropertySignature();
    var ApiMethodSignature_1 = require_ApiMethodSignature();
    var ApiProperty_1 = require_ApiProperty();
    var ApiEnumMember_1 = require_ApiEnumMember();
    var ApiEnum_1 = require_ApiEnum();
    var ApiConstructor_1 = require_ApiConstructor();
    var ApiConstructSignature_1 = require_ApiConstructSignature();
    var ApiFunction_1 = require_ApiFunction();
    var ApiCallSignature_1 = require_ApiCallSignature();
    var ApiIndexSignature_1 = require_ApiIndexSignature();
    var ApiTypeAlias_1 = require_ApiTypeAlias();
    var ApiVariable_1 = require_ApiVariable();
    var Deserializer = class {
      static deserialize(context, jsonObject) {
        const options = {};
        switch (jsonObject.kind) {
          case ApiItem_1.ApiItemKind.Class:
            ApiClass_1.ApiClass.onDeserializeInto(options, context, jsonObject);
            return new ApiClass_1.ApiClass(options);
          case ApiItem_1.ApiItemKind.CallSignature:
            ApiCallSignature_1.ApiCallSignature.onDeserializeInto(options, context, jsonObject);
            return new ApiCallSignature_1.ApiCallSignature(options);
          case ApiItem_1.ApiItemKind.Constructor:
            ApiConstructor_1.ApiConstructor.onDeserializeInto(options, context, jsonObject);
            return new ApiConstructor_1.ApiConstructor(options);
          case ApiItem_1.ApiItemKind.ConstructSignature:
            ApiConstructSignature_1.ApiConstructSignature.onDeserializeInto(options, context, jsonObject);
            return new ApiConstructSignature_1.ApiConstructSignature(options);
          case ApiItem_1.ApiItemKind.EntryPoint:
            ApiEntryPoint_1.ApiEntryPoint.onDeserializeInto(options, context, jsonObject);
            return new ApiEntryPoint_1.ApiEntryPoint(options);
          case ApiItem_1.ApiItemKind.Enum:
            ApiEnum_1.ApiEnum.onDeserializeInto(options, context, jsonObject);
            return new ApiEnum_1.ApiEnum(options);
          case ApiItem_1.ApiItemKind.EnumMember:
            ApiEnumMember_1.ApiEnumMember.onDeserializeInto(options, context, jsonObject);
            return new ApiEnumMember_1.ApiEnumMember(options);
          case ApiItem_1.ApiItemKind.Function:
            ApiFunction_1.ApiFunction.onDeserializeInto(options, context, jsonObject);
            return new ApiFunction_1.ApiFunction(options);
          case ApiItem_1.ApiItemKind.IndexSignature:
            ApiIndexSignature_1.ApiIndexSignature.onDeserializeInto(options, context, jsonObject);
            return new ApiIndexSignature_1.ApiIndexSignature(options);
          case ApiItem_1.ApiItemKind.Interface:
            ApiInterface_1.ApiInterface.onDeserializeInto(options, context, jsonObject);
            return new ApiInterface_1.ApiInterface(options);
          case ApiItem_1.ApiItemKind.Method:
            ApiMethod_1.ApiMethod.onDeserializeInto(options, context, jsonObject);
            return new ApiMethod_1.ApiMethod(options);
          case ApiItem_1.ApiItemKind.MethodSignature:
            ApiMethodSignature_1.ApiMethodSignature.onDeserializeInto(options, context, jsonObject);
            return new ApiMethodSignature_1.ApiMethodSignature(options);
          case ApiItem_1.ApiItemKind.Model:
            return new ApiModel_1.ApiModel();
          case ApiItem_1.ApiItemKind.Namespace:
            ApiNamespace_1.ApiNamespace.onDeserializeInto(options, context, jsonObject);
            return new ApiNamespace_1.ApiNamespace(options);
          case ApiItem_1.ApiItemKind.Package:
            ApiPackage_1.ApiPackage.onDeserializeInto(options, context, jsonObject);
            return new ApiPackage_1.ApiPackage(options);
          case ApiItem_1.ApiItemKind.Property:
            ApiProperty_1.ApiProperty.onDeserializeInto(options, context, jsonObject);
            return new ApiProperty_1.ApiProperty(options);
          case ApiItem_1.ApiItemKind.PropertySignature:
            ApiPropertySignature_1.ApiPropertySignature.onDeserializeInto(options, context, jsonObject);
            return new ApiPropertySignature_1.ApiPropertySignature(options);
          case ApiItem_1.ApiItemKind.TypeAlias:
            ApiTypeAlias_1.ApiTypeAlias.onDeserializeInto(options, context, jsonObject);
            return new ApiTypeAlias_1.ApiTypeAlias(options);
          case ApiItem_1.ApiItemKind.Variable:
            ApiVariable_1.ApiVariable.onDeserializeInto(options, context, jsonObject);
            return new ApiVariable_1.ApiVariable(options);
          default:
            throw new Error(`Failed to deserialize unsupported API item type ${JSON.stringify(jsonObject.kind)}`);
        }
      }
    };
    exports2.Deserializer = Deserializer;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/items/ApiItem.js
var require_ApiItem = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/items/ApiItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiItem = exports2.apiItem_onParentChanged = exports2.ApiItemKind = void 0;
    var ApiParameterListMixin_1 = require_ApiParameterListMixin();
    var node_core_library_1 = require_lib2();
    var ApiItemContainerMixin_1 = require_ApiItemContainerMixin();
    var ApiItemKind2;
    (function(ApiItemKind3) {
      ApiItemKind3["CallSignature"] = "CallSignature";
      ApiItemKind3["Class"] = "Class";
      ApiItemKind3["Constructor"] = "Constructor";
      ApiItemKind3["ConstructSignature"] = "ConstructSignature";
      ApiItemKind3["EntryPoint"] = "EntryPoint";
      ApiItemKind3["Enum"] = "Enum";
      ApiItemKind3["EnumMember"] = "EnumMember";
      ApiItemKind3["Function"] = "Function";
      ApiItemKind3["IndexSignature"] = "IndexSignature";
      ApiItemKind3["Interface"] = "Interface";
      ApiItemKind3["Method"] = "Method";
      ApiItemKind3["MethodSignature"] = "MethodSignature";
      ApiItemKind3["Model"] = "Model";
      ApiItemKind3["Namespace"] = "Namespace";
      ApiItemKind3["Package"] = "Package";
      ApiItemKind3["Property"] = "Property";
      ApiItemKind3["PropertySignature"] = "PropertySignature";
      ApiItemKind3["TypeAlias"] = "TypeAlias";
      ApiItemKind3["Variable"] = "Variable";
      ApiItemKind3["None"] = "None";
    })(ApiItemKind2 || (exports2.ApiItemKind = ApiItemKind2 = {}));
    exports2.apiItem_onParentChanged = Symbol("ApiItem._onAddToContainer");
    var ApiItem = class {
      constructor(options) {
      }
      static deserialize(jsonObject, context) {
        const deserializerModule = require_Deserializer();
        return deserializerModule.Deserializer.deserialize(context, jsonObject);
      }
      /** @virtual */
      static onDeserializeInto(options, context, jsonObject) {
      }
      /** @virtual */
      serializeInto(jsonObject) {
        jsonObject.kind = this.kind;
        jsonObject.canonicalReference = this.canonicalReference.toString();
      }
      /**
       * Identifies the subclass of the `ApiItem` base class.
       * @virtual
       */
      get kind() {
        throw new Error("ApiItem.kind was not implemented by the child class");
      }
      /**
       * Warning: This API is used internally by API extractor but is not yet ready for general usage.
       *
       * @remarks
       *
       * Returns a `DeclarationReference` object using the experimental new declaration reference notation.
       *
       * @beta
       */
      get canonicalReference() {
        if (!this._canonicalReference) {
          try {
            this._canonicalReference = this.buildCanonicalReference();
          } catch (e) {
            const name = this.getScopedNameWithinPackage() || this.displayName;
            throw new node_core_library_1.InternalError(`Error building canonical reference for ${name}:
` + e.message);
          }
        }
        return this._canonicalReference;
      }
      /**
       * Returns a string key that can be used to efficiently retrieve an `ApiItem` from an `ApiItemContainerMixin`.
       * The key is unique within the container.  Its format is undocumented and may change at any time.
       *
       * @remarks
       * Use the `getContainerKey()` static member to construct the key.  Each subclass has a different implementation
       * of this function, according to the aspects that are important for identifying it.
       *
       * @virtual
       */
      get containerKey() {
        throw new node_core_library_1.InternalError("ApiItem.containerKey was not implemented by the child class");
      }
      /**
       * Returns a name for this object that can be used in diagnostic messages, for example.
       *
       * @remarks
       * For an object that inherits ApiNameMixin, this will return the declared name (e.g. the name of a TypeScript
       * function).  Otherwise, it will return a string such as "(call signature)" or "(model)".
       *
       * @virtual
       */
      get displayName() {
        switch (this.kind) {
          case ApiItemKind2.CallSignature:
            return "(call)";
          case ApiItemKind2.Constructor:
            return "(constructor)";
          case ApiItemKind2.ConstructSignature:
            return "(new)";
          case ApiItemKind2.IndexSignature:
            return "(indexer)";
          case ApiItemKind2.Model:
            return "(model)";
        }
        return "(???)";
      }
      /**
       * If this item was added to a ApiItemContainerMixin item, then this returns the container item.
       * If this is an Parameter that was added to a method or function, then this returns the function item.
       * Otherwise, it returns undefined.
       * @virtual
       */
      get parent() {
        return this._parent;
      }
      /**
       * This property supports a visitor pattern for walking the tree.
       * For items with ApiItemContainerMixin, it returns the contained items, sorted alphabetically.
       * Otherwise it returns an empty array.
       * @virtual
       */
      get members() {
        return [];
      }
      /**
       * If this item has a name (i.e. extends `ApiNameMixin`), then return all items that have the same parent
       * and the same name.  Otherwise, return all items that have the same parent and the same `ApiItemKind`.
       *
       * @remarks
       * Examples: For a function, this would return all overloads for the function.  For a constructor, this would
       * return all overloads for the constructor.  For a merged declaration (e.g. a `namespace` and `enum` with the
       * same name), this would return both declarations.  If this item does not have a parent, or if it is the only
       * item of its name/kind, then the result is an array containing only this item.
       */
      getMergedSiblings() {
        const parent = this._parent;
        if (parent && ApiItemContainerMixin_1.ApiItemContainerMixin.isBaseClassOf(parent)) {
          return parent._getMergedSiblingsForMember(this);
        }
        return [];
      }
      /**
       * Returns the chain of ancestors, starting from the root of the tree, and ending with the this item.
       */
      getHierarchy() {
        const hierarchy = [];
        for (let current = this; current !== void 0; current = current.parent) {
          hierarchy.push(current);
        }
        hierarchy.reverse();
        return hierarchy;
      }
      /**
       * This returns a scoped name such as `"Namespace1.Namespace2.MyClass.myMember()"`.  It does not include the
       * package name or entry point.
       *
       * @remarks
       * If called on an ApiEntrypoint, ApiPackage, or ApiModel item, the result is an empty string.
       */
      getScopedNameWithinPackage() {
        const reversedParts = [];
        for (let current = this; current !== void 0; current = current.parent) {
          if (current.kind === ApiItemKind2.Model || current.kind === ApiItemKind2.Package || current.kind === ApiItemKind2.EntryPoint) {
            break;
          }
          if (reversedParts.length !== 0) {
            reversedParts.push(".");
          } else {
            switch (current.kind) {
              case ApiItemKind2.CallSignature:
              case ApiItemKind2.ConstructSignature:
              case ApiItemKind2.Constructor:
              case ApiItemKind2.IndexSignature:
                break;
              default:
                if (ApiParameterListMixin_1.ApiParameterListMixin.isBaseClassOf(current)) {
                  reversedParts.push("()");
                }
            }
          }
          reversedParts.push(current.displayName);
        }
        return reversedParts.reverse().join("");
      }
      /**
       * If this item is an ApiPackage or has an ApiPackage as one of its parents, then that object is returned.
       * Otherwise undefined is returned.
       */
      getAssociatedPackage() {
        for (let current = this; current !== void 0; current = current.parent) {
          if (current.kind === ApiItemKind2.Package) {
            return current;
          }
        }
        return void 0;
      }
      /**
       * If this item is an ApiModel or has an ApiModel as one of its parents, then that object is returned.
       * Otherwise undefined is returned.
       */
      getAssociatedModel() {
        for (let current = this; current !== void 0; current = current.parent) {
          if (current.kind === ApiItemKind2.Model) {
            return current;
          }
        }
        return void 0;
      }
      /**
       * A text string whose value determines the sort order that is automatically applied by the
       * {@link (ApiItemContainerMixin:interface)} class.
       *
       * @remarks
       * The value of this string is undocumented and may change at any time.
       * If {@link (ApiItemContainerMixin:interface).preserveMemberOrder} is enabled for the `ApiItem`'s parent,
       * then no sorting is performed, and this key is not used.
       *
       * @virtual
       */
      getSortKey() {
        return this.containerKey;
      }
      /**
       * PRIVATE
       *
       * @privateRemarks
       * Allows ApiItemContainerMixin to assign the parent when the item is added to a container.
       *
       * @internal
       */
      [exports2.apiItem_onParentChanged](parent) {
        this._parent = parent;
        this._canonicalReference = void 0;
      }
      /**
       * Builds the cached object used by the `canonicalReference` property.
       * @virtual
       */
      buildCanonicalReference() {
        throw new node_core_library_1.InternalError("ApiItem.canonicalReference was not implemented by the child class");
      }
    };
    exports2.ApiItem = ApiItem;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/items/ApiDocumentedItem.js
var require_ApiDocumentedItem = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/items/ApiDocumentedItem.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiDocumentedItem = void 0;
    var tsdoc = __importStar((init_lib(), __toCommonJS(lib_exports)));
    var ApiItem_1 = require_ApiItem();
    var ApiDocumentedItem2 = class extends ApiItem_1.ApiItem {
      constructor(options) {
        super(options);
        this._tsdocComment = options.docComment;
      }
      /** @override */
      static onDeserializeInto(options, context, jsonObject) {
        super.onDeserializeInto(options, context, jsonObject);
        const documentedJson = jsonObject;
        if (documentedJson.docComment) {
          const tsdocParser = new tsdoc.TSDocParser(context.tsdocConfiguration);
          const parserContext = tsdocParser.parseString(documentedJson.docComment);
          options.docComment = parserContext.docComment;
        }
      }
      get tsdocComment() {
        return this._tsdocComment;
      }
      /** @override */
      serializeInto(jsonObject) {
        super.serializeInto(jsonObject);
        if (this.tsdocComment !== void 0) {
          jsonObject.docComment = this.tsdocComment.emitAsTsdoc();
        } else {
          jsonObject.docComment = "";
        }
      }
    };
    exports2.ApiDocumentedItem = ApiDocumentedItem2;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/SourceLocation.js
var require_SourceLocation = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/model/SourceLocation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SourceLocation = void 0;
    var url_1 = require("url");
    var SourceLocation = class {
      constructor(options) {
        this._projectFolderUrl = options.projectFolderUrl;
        this._fileUrlPath = options.fileUrlPath;
      }
      /**
       * Returns the file URL to the given source location. Returns `undefined` if the file URL
       * cannot be determined.
       */
      get fileUrl() {
        if (this._projectFolderUrl === void 0 || this._fileUrlPath === void 0) {
          return void 0;
        }
        let projectFolderUrl = this._projectFolderUrl;
        if (!projectFolderUrl.endsWith("/")) {
          projectFolderUrl += "/";
        }
        const url = new url_1.URL(this._fileUrlPath, projectFolderUrl);
        return url.href;
      }
    };
    exports2.SourceLocation = SourceLocation;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/items/ApiDeclaredItem.js
var require_ApiDeclaredItem = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/items/ApiDeclaredItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiDeclaredItem = void 0;
    var DeclarationReference_1 = require_DeclarationReference();
    var ApiDocumentedItem_1 = require_ApiDocumentedItem();
    var Excerpt_1 = require_Excerpt();
    var SourceLocation_1 = require_SourceLocation();
    var ApiDeclaredItem = class _ApiDeclaredItem extends ApiDocumentedItem_1.ApiDocumentedItem {
      constructor(options) {
        super(options);
        this._excerptTokens = options.excerptTokens.map((token) => {
          const canonicalReference = token.canonicalReference === void 0 ? void 0 : DeclarationReference_1.DeclarationReference.parse(token.canonicalReference);
          return new Excerpt_1.ExcerptToken(token.kind, token.text, canonicalReference);
        });
        this._excerpt = new Excerpt_1.Excerpt(this.excerptTokens, { startIndex: 0, endIndex: this.excerptTokens.length });
        this._fileUrlPath = options.fileUrlPath;
      }
      /** @override */
      static onDeserializeInto(options, context, jsonObject) {
        super.onDeserializeInto(options, context, jsonObject);
        options.excerptTokens = jsonObject.excerptTokens;
        options.fileUrlPath = jsonObject.fileUrlPath;
      }
      /**
       * The source code excerpt where the API item is declared.
       */
      get excerpt() {
        return this._excerpt;
      }
      /**
       * The individual source code tokens that comprise the main excerpt.
       */
      get excerptTokens() {
        return this._excerptTokens;
      }
      /**
       * The file URL path relative to the `projectFolder` and `projectFolderURL` fields
       * as defined in the `api-extractor.json` config. Is `undefined` if the path is
       * the same as the parent API item's.
       */
      get fileUrlPath() {
        return this._fileUrlPath;
      }
      /**
       * Returns the source location where the API item is declared.
       */
      get sourceLocation() {
        if (!this._sourceLocation) {
          this._sourceLocation = this._buildSourceLocation();
        }
        return this._sourceLocation;
      }
      /**
       * If the API item has certain important modifier tags such as `@sealed`, `@virtual`, or `@override`,
       * this prepends them as a doc comment above the excerpt.
       */
      getExcerptWithModifiers() {
        const excerpt = this.excerpt.text;
        const modifierTags = [];
        if (excerpt.length > 0) {
          if (this instanceof ApiDocumentedItem_1.ApiDocumentedItem) {
            if (this.tsdocComment) {
              if (this.tsdocComment.modifierTagSet.isSealed()) {
                modifierTags.push("@sealed");
              }
              if (this.tsdocComment.modifierTagSet.isVirtual()) {
                modifierTags.push("@virtual");
              }
              if (this.tsdocComment.modifierTagSet.isOverride()) {
                modifierTags.push("@override");
              }
            }
            if (modifierTags.length > 0) {
              return "/** " + modifierTags.join(" ") + " */\n" + excerpt;
            }
          }
        }
        return excerpt;
      }
      /** @override */
      serializeInto(jsonObject) {
        super.serializeInto(jsonObject);
        jsonObject.excerptTokens = this.excerptTokens.map((x) => {
          const excerptToken = { kind: x.kind, text: x.text };
          if (x.canonicalReference !== void 0) {
            excerptToken.canonicalReference = x.canonicalReference.toString();
          }
          return excerptToken;
        });
        if (this.fileUrlPath) {
          if (!(this.parent instanceof _ApiDeclaredItem) || this.fileUrlPath !== this.parent.fileUrlPath) {
            jsonObject.fileUrlPath = this.fileUrlPath;
          }
        }
      }
      /**
       * Constructs a new {@link Excerpt} corresponding to the provided token range.
       */
      buildExcerpt(tokenRange) {
        return new Excerpt_1.Excerpt(this.excerptTokens, tokenRange);
      }
      /**
       * Builds the cached object used by the `sourceLocation` property.
       */
      _buildSourceLocation() {
        var _a;
        const projectFolderUrl = (_a = this.getAssociatedPackage()) === null || _a === void 0 ? void 0 : _a.projectFolderUrl;
        let fileUrlPath;
        for (let current = this; current !== void 0; current = current.parent) {
          if (current instanceof _ApiDeclaredItem && current.fileUrlPath) {
            fileUrlPath = current.fileUrlPath;
            break;
          }
        }
        return new SourceLocation_1.SourceLocation({
          projectFolderUrl,
          fileUrlPath
        });
      }
    };
    exports2.ApiDeclaredItem = ApiDeclaredItem;
  }
});

// ../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/.pnpm/@microsoft+api-extractor-model@7.28.17_@types+node@20.12.12/node_modules/@microsoft/api-extractor-model/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SourceLocation = exports2.HeritageType = exports2.ApiVariable = exports2.TypeParameter = exports2.ApiTypeAlias = exports2.ApiPropertySignature = exports2.ApiProperty = exports2.Parameter = exports2.ApiPackage = exports2.ApiNamespace = exports2.ApiModel = exports2.ApiMethodSignature = exports2.ApiMethod = exports2.ApiInterface = exports2.ApiIndexSignature = exports2.ApiFunction = exports2.EnumMemberOrder = exports2.ApiEnumMember = exports2.ApiEnum = exports2.ApiEntryPoint = exports2.ApiConstructSignature = exports2.ApiConstructor = exports2.ApiClass = exports2.ApiCallSignature = exports2.Excerpt = exports2.ExcerptToken = exports2.ExcerptTokenKind = exports2.FindApiItemsMessageId = exports2.ApiExportedMixin = exports2.ApiInitializerMixin = exports2.ApiReadonlyMixin = exports2.ApiOptionalMixin = exports2.ApiNameMixin = exports2.ApiStaticMixin = exports2.ApiReturnTypeMixin = exports2.ApiReleaseTagMixin = exports2.ApiProtectedMixin = exports2.ApiItemContainerMixin = exports2.ApiAbstractMixin = exports2.ApiTypeParameterListMixin = exports2.ApiParameterListMixin = exports2.ApiPropertyItem = exports2.ApiItem = exports2.ApiItemKind = exports2.ApiDocumentedItem = exports2.ApiDeclaredItem = exports2.ReleaseTag = exports2.AedocDefinitions = void 0;
    var AedocDefinitions_1 = require_AedocDefinitions();
    Object.defineProperty(exports2, "AedocDefinitions", { enumerable: true, get: function() {
      return AedocDefinitions_1.AedocDefinitions;
    } });
    var ReleaseTag_1 = require_ReleaseTag();
    Object.defineProperty(exports2, "ReleaseTag", { enumerable: true, get: function() {
      return ReleaseTag_1.ReleaseTag;
    } });
    var ApiDeclaredItem_1 = require_ApiDeclaredItem();
    Object.defineProperty(exports2, "ApiDeclaredItem", { enumerable: true, get: function() {
      return ApiDeclaredItem_1.ApiDeclaredItem;
    } });
    var ApiDocumentedItem_1 = require_ApiDocumentedItem();
    Object.defineProperty(exports2, "ApiDocumentedItem", { enumerable: true, get: function() {
      return ApiDocumentedItem_1.ApiDocumentedItem;
    } });
    var ApiItem_1 = require_ApiItem();
    Object.defineProperty(exports2, "ApiItemKind", { enumerable: true, get: function() {
      return ApiItem_1.ApiItemKind;
    } });
    Object.defineProperty(exports2, "ApiItem", { enumerable: true, get: function() {
      return ApiItem_1.ApiItem;
    } });
    var ApiPropertyItem_1 = require_ApiPropertyItem();
    Object.defineProperty(exports2, "ApiPropertyItem", { enumerable: true, get: function() {
      return ApiPropertyItem_1.ApiPropertyItem;
    } });
    var ApiParameterListMixin_1 = require_ApiParameterListMixin();
    Object.defineProperty(exports2, "ApiParameterListMixin", { enumerable: true, get: function() {
      return ApiParameterListMixin_1.ApiParameterListMixin;
    } });
    var ApiTypeParameterListMixin_1 = require_ApiTypeParameterListMixin();
    Object.defineProperty(exports2, "ApiTypeParameterListMixin", { enumerable: true, get: function() {
      return ApiTypeParameterListMixin_1.ApiTypeParameterListMixin;
    } });
    var ApiAbstractMixin_1 = require_ApiAbstractMixin();
    Object.defineProperty(exports2, "ApiAbstractMixin", { enumerable: true, get: function() {
      return ApiAbstractMixin_1.ApiAbstractMixin;
    } });
    var ApiItemContainerMixin_1 = require_ApiItemContainerMixin();
    Object.defineProperty(exports2, "ApiItemContainerMixin", { enumerable: true, get: function() {
      return ApiItemContainerMixin_1.ApiItemContainerMixin;
    } });
    var ApiProtectedMixin_1 = require_ApiProtectedMixin();
    Object.defineProperty(exports2, "ApiProtectedMixin", { enumerable: true, get: function() {
      return ApiProtectedMixin_1.ApiProtectedMixin;
    } });
    var ApiReleaseTagMixin_1 = require_ApiReleaseTagMixin();
    Object.defineProperty(exports2, "ApiReleaseTagMixin", { enumerable: true, get: function() {
      return ApiReleaseTagMixin_1.ApiReleaseTagMixin;
    } });
    var ApiReturnTypeMixin_1 = require_ApiReturnTypeMixin();
    Object.defineProperty(exports2, "ApiReturnTypeMixin", { enumerable: true, get: function() {
      return ApiReturnTypeMixin_1.ApiReturnTypeMixin;
    } });
    var ApiStaticMixin_1 = require_ApiStaticMixin();
    Object.defineProperty(exports2, "ApiStaticMixin", { enumerable: true, get: function() {
      return ApiStaticMixin_1.ApiStaticMixin;
    } });
    var ApiNameMixin_1 = require_ApiNameMixin();
    Object.defineProperty(exports2, "ApiNameMixin", { enumerable: true, get: function() {
      return ApiNameMixin_1.ApiNameMixin;
    } });
    var ApiOptionalMixin_1 = require_ApiOptionalMixin();
    Object.defineProperty(exports2, "ApiOptionalMixin", { enumerable: true, get: function() {
      return ApiOptionalMixin_1.ApiOptionalMixin;
    } });
    var ApiReadonlyMixin_1 = require_ApiReadonlyMixin();
    Object.defineProperty(exports2, "ApiReadonlyMixin", { enumerable: true, get: function() {
      return ApiReadonlyMixin_1.ApiReadonlyMixin;
    } });
    var ApiInitializerMixin_1 = require_ApiInitializerMixin();
    Object.defineProperty(exports2, "ApiInitializerMixin", { enumerable: true, get: function() {
      return ApiInitializerMixin_1.ApiInitializerMixin;
    } });
    var ApiExportedMixin_1 = require_ApiExportedMixin();
    Object.defineProperty(exports2, "ApiExportedMixin", { enumerable: true, get: function() {
      return ApiExportedMixin_1.ApiExportedMixin;
    } });
    var IFindApiItemsResult_1 = require_IFindApiItemsResult();
    Object.defineProperty(exports2, "FindApiItemsMessageId", { enumerable: true, get: function() {
      return IFindApiItemsResult_1.FindApiItemsMessageId;
    } });
    var Excerpt_1 = require_Excerpt();
    Object.defineProperty(exports2, "ExcerptTokenKind", { enumerable: true, get: function() {
      return Excerpt_1.ExcerptTokenKind;
    } });
    Object.defineProperty(exports2, "ExcerptToken", { enumerable: true, get: function() {
      return Excerpt_1.ExcerptToken;
    } });
    Object.defineProperty(exports2, "Excerpt", { enumerable: true, get: function() {
      return Excerpt_1.Excerpt;
    } });
    var ApiCallSignature_1 = require_ApiCallSignature();
    Object.defineProperty(exports2, "ApiCallSignature", { enumerable: true, get: function() {
      return ApiCallSignature_1.ApiCallSignature;
    } });
    var ApiClass_1 = require_ApiClass();
    Object.defineProperty(exports2, "ApiClass", { enumerable: true, get: function() {
      return ApiClass_1.ApiClass;
    } });
    var ApiConstructor_1 = require_ApiConstructor();
    Object.defineProperty(exports2, "ApiConstructor", { enumerable: true, get: function() {
      return ApiConstructor_1.ApiConstructor;
    } });
    var ApiConstructSignature_1 = require_ApiConstructSignature();
    Object.defineProperty(exports2, "ApiConstructSignature", { enumerable: true, get: function() {
      return ApiConstructSignature_1.ApiConstructSignature;
    } });
    var ApiEntryPoint_1 = require_ApiEntryPoint();
    Object.defineProperty(exports2, "ApiEntryPoint", { enumerable: true, get: function() {
      return ApiEntryPoint_1.ApiEntryPoint;
    } });
    var ApiEnum_1 = require_ApiEnum();
    Object.defineProperty(exports2, "ApiEnum", { enumerable: true, get: function() {
      return ApiEnum_1.ApiEnum;
    } });
    var ApiEnumMember_1 = require_ApiEnumMember();
    Object.defineProperty(exports2, "ApiEnumMember", { enumerable: true, get: function() {
      return ApiEnumMember_1.ApiEnumMember;
    } });
    Object.defineProperty(exports2, "EnumMemberOrder", { enumerable: true, get: function() {
      return ApiEnumMember_1.EnumMemberOrder;
    } });
    var ApiFunction_1 = require_ApiFunction();
    Object.defineProperty(exports2, "ApiFunction", { enumerable: true, get: function() {
      return ApiFunction_1.ApiFunction;
    } });
    var ApiIndexSignature_1 = require_ApiIndexSignature();
    Object.defineProperty(exports2, "ApiIndexSignature", { enumerable: true, get: function() {
      return ApiIndexSignature_1.ApiIndexSignature;
    } });
    var ApiInterface_1 = require_ApiInterface();
    Object.defineProperty(exports2, "ApiInterface", { enumerable: true, get: function() {
      return ApiInterface_1.ApiInterface;
    } });
    var ApiMethod_1 = require_ApiMethod();
    Object.defineProperty(exports2, "ApiMethod", { enumerable: true, get: function() {
      return ApiMethod_1.ApiMethod;
    } });
    var ApiMethodSignature_1 = require_ApiMethodSignature();
    Object.defineProperty(exports2, "ApiMethodSignature", { enumerable: true, get: function() {
      return ApiMethodSignature_1.ApiMethodSignature;
    } });
    var ApiModel_1 = require_ApiModel();
    Object.defineProperty(exports2, "ApiModel", { enumerable: true, get: function() {
      return ApiModel_1.ApiModel;
    } });
    var ApiNamespace_1 = require_ApiNamespace();
    Object.defineProperty(exports2, "ApiNamespace", { enumerable: true, get: function() {
      return ApiNamespace_1.ApiNamespace;
    } });
    var ApiPackage_1 = require_ApiPackage();
    Object.defineProperty(exports2, "ApiPackage", { enumerable: true, get: function() {
      return ApiPackage_1.ApiPackage;
    } });
    var Parameter_1 = require_Parameter();
    Object.defineProperty(exports2, "Parameter", { enumerable: true, get: function() {
      return Parameter_1.Parameter;
    } });
    var ApiProperty_1 = require_ApiProperty();
    Object.defineProperty(exports2, "ApiProperty", { enumerable: true, get: function() {
      return ApiProperty_1.ApiProperty;
    } });
    var ApiPropertySignature_1 = require_ApiPropertySignature();
    Object.defineProperty(exports2, "ApiPropertySignature", { enumerable: true, get: function() {
      return ApiPropertySignature_1.ApiPropertySignature;
    } });
    var ApiTypeAlias_1 = require_ApiTypeAlias();
    Object.defineProperty(exports2, "ApiTypeAlias", { enumerable: true, get: function() {
      return ApiTypeAlias_1.ApiTypeAlias;
    } });
    var TypeParameter_1 = require_TypeParameter();
    Object.defineProperty(exports2, "TypeParameter", { enumerable: true, get: function() {
      return TypeParameter_1.TypeParameter;
    } });
    var ApiVariable_1 = require_ApiVariable();
    Object.defineProperty(exports2, "ApiVariable", { enumerable: true, get: function() {
      return ApiVariable_1.ApiVariable;
    } });
    var HeritageType_1 = require_HeritageType();
    Object.defineProperty(exports2, "HeritageType", { enumerable: true, get: function() {
      return HeritageType_1.HeritageType;
    } });
    var SourceLocation_1 = require_SourceLocation();
    Object.defineProperty(exports2, "SourceLocation", { enumerable: true, get: function() {
      return SourceLocation_1.SourceLocation;
    } });
  }
});

// scripts/index.ts
var fs = __toESM(require("fs"), 1);
var import_node_process = __toESM(require("process"), 1);
var import_api_extractor_model3 = __toESM(require_lib4(), 1);

// scripts/JsonDocumenter.ts
init_lib();
var import_api_extractor_model = __toESM(require_lib4(), 1);
var import_api_extractor_model2 = __toESM(require_lib4(), 1);
var JsonDocumenter = class {
  _apiModel;
  _namesToFilter;
  constructor(apiModel2, namesToFilter2) {
    this._apiModel = apiModel2;
    this._namesToFilter = namesToFilter2;
  }
  generate() {
    const output = {
      components: [],
      hooks: [],
      utilities: []
    };
    for (const apiPackage of this._apiModel.packages) {
      const packageMembers = apiPackage.members[0].members.filter(
        (apiItem) => this._namesToFilter.length === 0 || this._namesToFilter.includes(apiItem.displayName)
      );
      for (const apiMember of packageMembers) {
        const kindValue = this._getKindFromApiItem(apiMember);
        if (kindValue) {
          const apiItem = this._generateJsonApiItem(apiMember, kindValue);
          switch (kindValue) {
            case "component":
              output.components.push(apiItem);
              break;
            case "hook":
              output.hooks.push(apiItem);
              break;
            case "utility":
              output.utilities.push(apiItem);
              break;
          }
        }
      }
    }
    return output;
  }
  _getKindFromApiItem(apiItem) {
    if (apiItem instanceof import_api_extractor_model2.ApiDocumentedItem && apiItem.tsdocComment) {
      const kindBlock = apiItem.tsdocComment.customBlocks.find(
        (block) => block.blockTag.tagNameWithUpperCase === "@KIND"
      );
      if (kindBlock) {
        const kindValue = kindBlock.content.getChildNodes().filter((node) => node.kind === DocNodeKind.Paragraph)[0];
        return this._renderParagraph(kindValue);
      }
    }
    return void 0;
  }
  _generateJsonApiItem(apiItem, kind) {
    const output = {
      name: apiItem.displayName,
      kind
    };
    if (apiItem instanceof import_api_extractor_model2.ApiDocumentedItem) {
      const tsdocComment = apiItem.tsdocComment;
      if (tsdocComment) {
        if (tsdocComment.summarySection)
          output.description = this._renderMarkdown(tsdocComment.summarySection);
        if (tsdocComment.remarksBlock)
          output.remarks = this._renderMarkdown(tsdocComment.remarksBlock.content).split("\n");
        if (tsdocComment.customBlocks.length > 0) {
          const exampleBlocks = tsdocComment.customBlocks.filter(
            (block) => block.blockTag.tagNameWithUpperCase === StandardTags.example.tagNameWithUpperCase
          );
          const seeBlocks = tsdocComment.customBlocks.filter(
            (block) => block.blockTag.tagNameWithUpperCase === StandardTags.see.tagNameWithUpperCase
          );
          output.examples = exampleBlocks.map((exampleBlock) => this._renderMarkdown(exampleBlock.content));
          output.see = seeBlocks.map((seeBlock) => this._renderMarkdown(seeBlock.content));
        }
      }
      const props = this._getPropsFromComponent(apiItem, kind);
      if (kind === "component") {
        if (props)
          output.props = this._renderComponentProperties(apiItem, props);
      } else {
        if (props)
          output.params = this._renderComponentProperties(apiItem, props);
        else
          output.params = this._renderParameters(apiItem);
        if (import_api_extractor_model2.ApiReturnTypeMixin.isBaseClassOf(apiItem))
          output.returnType = apiItem.returnTypeExcerpt.text;
      }
    }
    return output;
  }
  _getPropsFromComponent(apiItem, kind) {
    const suffix = kind === "component" ? "Props" : "Options";
    let name = apiItem.displayName;
    if (kind === "hook")
      name = name.replace("use", "");
    name += suffix;
    return this._apiModel.members[0].members[0].members.find(
      (member) => member.displayName === name && member.kind === import_api_extractor_model2.ApiItemKind.Interface
    ) ?? null;
  }
  _renderComponentProperties(apiItem, props) {
    const properties = {};
    if (!props)
      return properties;
    if (props instanceof import_api_extractor_model.ApiInterface) {
      for (const apiMember of props.members) {
        if (apiMember.kind === import_api_extractor_model2.ApiItemKind.Property || apiMember.kind === import_api_extractor_model2.ApiItemKind.PropertySignature) {
          const apiProperty = apiMember;
          if (apiProperty.isEventProperty)
            continue;
          properties[apiProperty.displayName] = {
            type: apiProperty.propertyTypeExcerpt.text,
            description: apiProperty.tsdocComment?.summarySection ? this._renderMarkdown(apiProperty.tsdocComment?.summarySection) : "",
            required: !apiProperty.isOptional
          };
          const customBlocks = apiProperty.tsdocComment?.customBlocks ?? [];
          const defaultValueBlock = customBlocks.find(
            (block) => block.blockTag.tagNameWithUpperCase === "@DEFAULTVALUE"
          );
          if (defaultValueBlock) {
            const defaultValue = defaultValueBlock.content.getChildNodes().filter((node) => node.kind === DocNodeKind.Paragraph)[0];
            properties[apiProperty.displayName].defaultValue = this._renderParagraph(defaultValue);
          }
        }
      }
    }
    return properties;
  }
  _renderParameters(apiItem) {
    const parameters = {};
    for (const parameter of apiItem.parameters) {
      parameters[parameter.name] = {
        type: parameter.parameterTypeExcerpt.text,
        description: parameter.tsdocParamBlock?.content ? this._renderMarkdown(parameter.tsdocParamBlock.content) : "",
        required: !parameter.isOptional
      };
    }
    return parameters;
  }
  _renderMarkdown(docSection) {
    const builder = new StringBuilder();
    for (const node of docSection.nodes) {
      if (node.kind === DocNodeKind.Paragraph)
        builder.append(this._renderParagraph(node));
      else if (node.kind === DocNodeKind.SoftBreak)
        continue;
      else if (node.kind === DocNodeKind.FencedCode)
        builder.append(this._renderFencedCode(node));
      else
        builder.append(node.toString());
    }
    return builder.toString();
  }
  _renderParagraph(node) {
    const builder = new StringBuilder();
    for (const childNode of node.getChildNodes()) {
      switch (childNode.kind) {
        case DocNodeKind.CodeSpan:
          builder.append("`");
          builder.append(childNode.code);
          builder.append("`");
          break;
        case DocNodeKind.EscapedText:
          builder.append(childNode.decodedText);
          break;
        case DocNodeKind.PlainText:
          builder.append(childNode.text);
          break;
        case DocNodeKind.SoftBreak:
          continue;
        default:
          builder.append(childNode.toString());
      }
    }
    return builder.toString();
  }
  _renderFencedCode(node) {
    const builder = new StringBuilder();
    builder.append("```");
    if (node.language)
      builder.append(node.language);
    builder.append("\n");
    builder.append(node.code);
    builder.append("\n```");
    return builder.toString();
  }
};

// scripts/index.ts
var args = import_node_process.default.argv.slice(2);
var showJson = args.includes("--showJson");
var summary = args.includes("--summary");
var namesToFilter = args.filter((arg) => arg.startsWith("--name=")).map((arg) => arg.split("=")[1]);
var apiModel = new import_api_extractor_model3.ApiModel();
apiModel.loadPackage("docs/framer-toolbox.api.json");
console.log(`Generating JSON documentation for ${apiModel.packages[0].name}...`);
var jsonDocumenter = new JsonDocumenter(apiModel, namesToFilter);
var json = jsonDocumenter.generate();
if (showJson)
  console.log(JSON.stringify(json, null, 2));
if (summary) {
  console.log({
    components: {
      total: json.components.length,
      names: json.components.map((component) => component.name)
    },
    hooks: {
      total: json.hooks.length,
      names: json.hooks.map((hook) => hook.name)
    },
    utilities: {
      total: json.utilities.length,
      names: json.utilities.map((utility) => utility.name)
    }
  });
}
fs.writeFileSync("docs/framer-toolbox.json", JSON.stringify(json, null, 2));
/*! Bundled license information:

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)
*/
